#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Aug 14 05:46:28 2021 by generateDS.py version 2.39.3.
# Python 3.9.5 (v3.9.5:0a7dcbdb13, May  3 2021, 13:17:02)  [Clang 6.0 (clang-600.0.57)]
#
# Command line options:
#   ('-o', 'musicxml.py')
#   ('--root-element', 'score_partwise')
#
# Command line arguments:
#   schema/musicxml.xsd
#
# Command line:
#   /Users/taube/Software/musx/venv/bin/generateDS -o "musicxml.py" --root-element="score_partwise" schema/musicxml.xsd
#
# Current working directory (os.getcwd()):
#   mxml
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ModulenotfoundExp_ :
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class above_below(str, Enum):
    """above-below -- The above-below type is used to indicate whether one element appears above or below another element.
    
    """
    ABOVE='above'
    BELOW='below'


class accidental_value(str, Enum):
    """accidental-value -- The accidental-value type represents notated accidentals supported by MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be included. The XSD strengthens the data typing to an enumerated list. The quarter- and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The -down and -up accidentals are quarter-tone accidentals that include arrows pointing down or up. The slash- accidentals are used in Turkish classical music. The numbered sharp and flat accidentals are superscripted versions of the accidental signs, used in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat accidentals used in Iranian and Persian music. The other accidental covers accidentals other than those listed here. It is usually used in combination with the smufl attribute to specify a particular SMuFL accidental. The smufl attribute may be used with any accidental value to help specify the appearance of symbols that share the same MusicXML semantics.
    
    """
    SHARP='sharp'
    NATURAL='natural'
    FLAT='flat'
    DOUBLESHARP='double-sharp'
    SHARPSHARP='sharp-sharp'
    FLATFLAT='flat-flat'
    NATURALSHARP='natural-sharp'
    NATURALFLAT='natural-flat'
    QUARTERFLAT='quarter-flat'
    QUARTERSHARP='quarter-sharp'
    THREEQUARTERSFLAT='three-quarters-flat'
    THREEQUARTERSSHARP='three-quarters-sharp'
    SHARPDOWN='sharp-down'
    SHARPUP='sharp-up'
    NATURALDOWN='natural-down'
    NATURALUP='natural-up'
    FLATDOWN='flat-down'
    FLATUP='flat-up'
    DOUBLESHARPDOWN='double-sharp-down'
    DOUBLESHARPUP='double-sharp-up'
    FLATFLATDOWN='flat-flat-down'
    FLATFLATUP='flat-flat-up'
    ARROWDOWN='arrow-down'
    ARROWUP='arrow-up'
    TRIPLESHARP='triple-sharp'
    TRIPLEFLAT='triple-flat'
    SLASHQUARTERSHARP='slash-quarter-sharp'
    SLASHSHARP='slash-sharp'
    SLASHFLAT='slash-flat'
    DOUBLESLASHFLAT='double-slash-flat'
    SHARP_1='sharp-1'
    SHARP_2='sharp-2'
    SHARP_3='sharp-3'
    SHARP_5='sharp-5'
    FLAT_1='flat-1'
    FLAT_2='flat-2'
    FLAT_3='flat-3'
    FLAT_4='flat-4'
    SORI='sori'
    KORON='koron'
    OTHER='other'


class arrow_direction(str, Enum):
    """arrow-direction -- The arrow-direction type represents the direction in which an arrow points, using Unicode arrow terminology.
    
    """
    LEFT='left'
    UP='up'
    RIGHT='right'
    DOWN='down'
    NORTHWEST='northwest'
    NORTHEAST='northeast'
    SOUTHEAST='southeast'
    SOUTHWEST='southwest'
    LEFTRIGHT='left right'
    UPDOWN='up down'
    NORTHWESTSOUTHEAST='northwest southeast'
    NORTHEASTSOUTHWEST='northeast southwest'
    OTHER='other'


class arrow_style(str, Enum):
    """arrow-style -- The arrow-style type represents the style of an arrow, using Unicode arrow terminology. Filled and hollow arrows indicate polygonal single arrows. Paired arrows are duplicate single arrows in the same direction. Combined arrows apply to double direction arrows like left right, indicating that an arrow in one direction should be combined with an arrow in the other direction.
    
    """
    SINGLE='single'
    DOUBLE='double'
    FILLED='filled'
    HOLLOW='hollow'
    PAIRED='paired'
    COMBINED='combined'
    OTHER='other'


class backward_forward(str, Enum):
    """backward-forward -- The backward-forward type is used to specify repeat directions. The start of the repeat has a forward direction while the end of the repeat has a backward direction.
    
    """
    BACKWARD='backward'
    FORWARD='forward'


class bar_style(str, Enum):
    """bar-style -- The bar-style type represents barline style information. Choices are regular, dotted, dashed, heavy, light-light, light-heavy, heavy-light, heavy-heavy, tick (a short stroke through the top line), short (a partial barline between the 2nd and 4th lines), and none.
    
    """
    REGULAR='regular'
    DOTTED='dotted'
    DASHED='dashed'
    HEAVY='heavy'
    LIGHTLIGHT='light-light'
    LIGHTHEAVY='light-heavy'
    HEAVYLIGHT='heavy-light'
    HEAVYHEAVY='heavy-heavy'
    TICK='tick'
    SHORT='short'
    NONE='none'


class beam_value(str, Enum):
    """beam-value -- The beam-value type represents the type of beam associated with each of 8 beam levels (up to 1024th notes) available for each note.
    
    """
    BEGIN='begin'
    CONTINUE='continue'
    END='end'
    FORWARDHOOK='forward hook'
    BACKWARDHOOK='backward hook'


class beater_value(str, Enum):
    """beater-value -- The beater-value type represents pictograms for beaters, mallets, and sticks that do not have different materials represented in the pictogram. The finger and hammer values are in addition to Stone's list.
    
    """
    BOW='bow'
    CHIMEHAMMER='chime hammer'
    COIN='coin'
    DRUMSTICK='drum stick'
    FINGER='finger'
    FINGERNAIL='fingernail'
    FIST='fist'
    GUIROSCRAPER='guiro scraper'
    HAMMER='hammer'
    HAND='hand'
    JAZZSTICK='jazz stick'
    KNITTINGNEEDLE='knitting needle'
    METALHAMMER='metal hammer'
    SLIDEBRUSHONGONG='slide brush on gong'
    SNARESTICK='snare stick'
    SPOONMALLET='spoon mallet'
    SUPERBALL='superball'
    TRIANGLEBEATER='triangle beater'
    TRIANGLEBEATERPLAIN='triangle beater plain'
    WIREBRUSH='wire brush'


class bend_shape(str, Enum):
    """bend-shape -- The bend-shape type distinguishes between the angled bend symbols commonly used in standard notation and the curved bend symbols commonly used in both tablature and standard notation.
    
    """
    ANGLED='angled'
    CURVED='curved'


class breath_mark_value(str, Enum):
    """breath-mark-value -- The breath-mark-value type represents the symbol used for a breath mark.
    
    """
    _=''
    COMMA='comma'
    TICK='tick'
    UPBOW='upbow'
    SALZEDO='salzedo'


class caesura_value(str, Enum):
    """caesura-value -- The caesura-value type represents the shape of the caesura sign.
    
    """
    NORMAL='normal'
    THICK='thick'
    SHORT='short'
    CURVED='curved'
    SINGLE='single'
    _=''


class cancel_location(str, Enum):
    """cancel-location -- The cancel-location type is used to indicate where a key signature cancellation appears relative to a new key signature: to the left, to the right, or before the barline and to the left. It is left by default. For mid-measure key elements, a cancel-location of before-barline should be treated like a cancel-location of left.
    
    """
    LEFT='left'
    RIGHT='right'
    BEFOREBARLINE='before-barline'


class circular_arrow(str, Enum):
    """circular-arrow -- The circular-arrow type represents the direction in which a circular arrow points, using Unicode arrow terminology.
    
    """
    CLOCKWISE='clockwise'
    ANTICLOCKWISE='anticlockwise'


class clef_sign(str, Enum):
    """clef-sign -- The clef-sign type represents the different clef symbols. The jianpu sign indicates that the music that follows should be in jianpu numbered notation, just as the TAB sign indicates that the music that follows should be in tablature notation. Unlike TAB, a jianpu sign does not correspond to a visual clef notation.
    The none sign is deprecated as of MusicXML 4.0. Use the clef element's print-object attribute instead. When the none sign is used, notes should be displayed as if in treble clef.
    
    """
    G='G'
    F='F'
    C='C'
    PERCUSSION='percussion'
    TAB='TAB'
    JIANPU='jianpu'
    NONE='none'


class css_font_size(str, Enum):
    """css-font-size -- The css-font-size type includes the CSS font sizes used as an alternative to a numeric point size.
    
    """
    XXSMALL='xx-small'
    XSMALL='x-small'
    SMALL='small'
    MEDIUM='medium'
    LARGE='large'
    XLARGE='x-large'
    XXLARGE='xx-large'


class degree_symbol_value(str, Enum):
    """degree-symbol-value -- The degree-symbol-value type indicates which symbol should be used in specifying a degree.
    
    """
    MAJOR='major'
    MINOR='minor'
    AUGMENTED='augmented'
    DIMINISHED='diminished'
    HALFDIMINISHED='half-diminished'


class degree_type_value(str, Enum):
    """degree-type-value -- The degree-type-value type indicates whether the current degree element is an addition, alteration, or subtraction to the kind of the current chord in the harmony element.
    
    """
    ADD='add'
    ALTER='alter'
    SUBTRACT='subtract'


class effect_value(str, Enum):
    """effect-value -- The effect-value type represents pictograms for sound effect percussion instruments. The cannon, lotus flute, and megaphone values are in addition to Stone's list.
    
    """
    ANVIL='anvil'
    AUTOHORN='auto horn'
    BIRDWHISTLE='bird whistle'
    CANNON='cannon'
    DUCKCALL='duck call'
    GUNSHOT='gun shot'
    KLAXONHORN='klaxon horn'
    LIONSROAR='lions roar'
    LOTUSFLUTE='lotus flute'
    MEGAPHONE='megaphone'
    POLICEWHISTLE='police whistle'
    SIREN='siren'
    SLIDEWHISTLE='slide whistle'
    THUNDERSHEET='thunder sheet'
    WINDMACHINE='wind machine'
    WINDWHISTLE='wind whistle'


class enclosure_shape(str, Enum):
    """enclosure-shape -- The enclosure-shape type describes the shape and presence / absence of an enclosure around text or symbols. A bracket enclosure is similar to a rectangle with the bottom line missing, as is common in jazz notation. An inverted-bracket enclosure is similar to a rectangle with the top line missing.
    
    """
    RECTANGLE='rectangle'
    SQUARE='square'
    OVAL='oval'
    CIRCLE='circle'
    BRACKET='bracket'
    INVERTEDBRACKET='inverted-bracket'
    TRIANGLE='triangle'
    DIAMOND='diamond'
    PENTAGON='pentagon'
    HEXAGON='hexagon'
    HEPTAGON='heptagon'
    OCTAGON='octagon'
    NONAGON='nonagon'
    DECAGON='decagon'
    NONE='none'


class fan(str, Enum):
    """fan -- The fan type represents the type of beam fanning present on a note, used to represent accelerandos and ritardandos.
    
    """
    ACCEL='accel'
    RIT='rit'
    NONE='none'


class fermata_shape(str, Enum):
    """fermata-shape -- The fermata-shape type represents the shape of the fermata sign. The empty value is equivalent to the normal value.
    
    """
    NORMAL='normal'
    ANGLED='angled'
    SQUARE='square'
    DOUBLEANGLED='double-angled'
    DOUBLESQUARE='double-square'
    DOUBLEDOT='double-dot'
    HALFCURVE='half-curve'
    CURLEW='curlew'
    _=''


class font_style(str, Enum):
    """font-style -- The font-style type represents a simplified version of the CSS font-style property.
    
    """
    NORMAL='normal'
    ITALIC='italic'


class font_weight(str, Enum):
    """font-weight -- The font-weight type represents a simplified version of the CSS font-weight property.
    
    """
    NORMAL='normal'
    BOLD='bold'


class glass_value(str, Enum):
    """glass-value -- The glass-value type represents pictograms for glass percussion instruments.
    
    """
    GLASSHARMONICA='glass harmonica'
    GLASSHARP='glass harp'
    WINDCHIMES='wind chimes'


class group_barline_value(str, Enum):
    """group-barline-value -- The group-barline-value type indicates if the group should have common barlines.
    
    """
    YES='yes'
    NO='no'
    MENSURSTRICH='Mensurstrich'


class group_symbol_value(str, Enum):
    """group-symbol-value -- The group-symbol-value type indicates how the symbol for a group or multi-staff part is indicated in the score.
    
    """
    NONE='none'
    BRACE='brace'
    LINE='line'
    BRACKET='bracket'
    SQUARE='square'


class handbell_value(str, Enum):
    """handbell-value -- The handbell-value type represents the type of handbell technique being notated.
    
    """
    BELLTREE='belltree'
    DAMP='damp'
    ECHO='echo'
    GYRO='gyro'
    HANDMARTELLATO='hand martellato'
    MALLETLIFT='mallet lift'
    MALLETTABLE='mallet table'
    MARTELLATO='martellato'
    MARTELLATOLIFT='martellato lift'
    MUTEDMARTELLATO='muted martellato'
    PLUCKLIFT='pluck lift'
    SWING='swing'


class harmon_closed_location(str, Enum):
    """harmon-closed-location -- The harmon-closed-location type indicates which portion of the symbol is filled in when the corresponding harmon-closed-value is half.
    
    """
    RIGHT='right'
    BOTTOM='bottom'
    LEFT='left'
    TOP='top'


class harmon_closed_value(str, Enum):
    """harmon-closed-value -- The harmon-closed-value type represents whether the harmon mute is closed, open, or half-open.
    
    """
    YES='yes'
    NO='no'
    HALF='half'


class harmony_arrangement(str, Enum):
    """harmony-arrangement -- The harmony-arrangement type indicates how stacked chords and bass notes are displayed within a harmony element. The vertical value specifies that the second element appears below the first. The horizontal value specifies that the second element appears to the right of the first. The diagonal value specifies that the second element appears both below and to the right of the first.
    
    """
    VERTICAL='vertical'
    HORIZONTAL='horizontal'
    DIAGONAL='diagonal'


class harmony_type(str, Enum):
    """harmony-type -- The harmony-type type differentiates different types of harmonies when alternate harmonies are possible. Explicit harmonies have all note present in the music; implied have some notes missing but implied; alternate represents alternate analyses.
    
    """
    EXPLICIT='explicit'
    IMPLIED='implied'
    ALTERNATE='alternate'


class hole_closed_location(str, Enum):
    """hole-closed-location -- The hole-closed-location type indicates which portion of the hole is filled in when the corresponding hole-closed-value is half.
    
    """
    RIGHT='right'
    BOTTOM='bottom'
    LEFT='left'
    TOP='top'


class hole_closed_value(str, Enum):
    """hole-closed-value -- The hole-closed-value type represents whether the hole is closed, open, or half-open.
    
    """
    YES='yes'
    NO='no'
    HALF='half'


class kind_value(str, Enum):
    """kind-value -- A kind-value indicates the type of chord. Degree elements can then add, subtract, or alter from these starting points. Values include:
    Triads:
    major (major third, perfect fifth)
    minor (minor third, perfect fifth)
    augmented (major third, augmented fifth)
    diminished (minor third, diminished fifth)
    Sevenths:
    dominant (major triad, minor seventh)
    major-seventh (major triad, major seventh)
    minor-seventh (minor triad, minor seventh)
    diminished-seventh (diminished triad, diminished seventh)
    augmented-seventh (augmented triad, minor seventh)
    half-diminished (diminished triad, minor seventh)
    major-minor (minor triad, major seventh)
    Sixths:
    major-sixth (major triad, added sixth)
    minor-sixth (minor triad, added sixth)
    Ninths:
    dominant-ninth (dominant-seventh, major ninth)
    major-ninth (major-seventh, major ninth)
    minor-ninth (minor-seventh, major ninth)
    11ths (usually as the basis for alteration):
    dominant-11th (dominant-ninth, perfect 11th)
    major-11th (major-ninth, perfect 11th)
    minor-11th (minor-ninth, perfect 11th)
    13ths (usually as the basis for alteration):
    dominant-13th (dominant-11th, major 13th)
    major-13th (major-11th, major 13th)
    minor-13th (minor-11th, major 13th)
    Suspended:
    suspended-second (major second, perfect fifth)
    suspended-fourth (perfect fourth, perfect fifth)
    Functional sixths:
    Neapolitan
    Italian
    French
    German
    Other:
    pedal (pedal-point bass)
    power (perfect fifth)
    Tristan
    The "other" kind is used when the harmony is entirely composed of add elements.
    The "none" kind is used to explicitly encode absence of chords or functional harmony. In this case, the root, numeral, or function element has no meaning. When using the root or numeral element, the root-step or numeral-step text attribute should be set to the empty string to keep the root or numeral from being displayed.
    
    """
    MAJOR='major'
    MINOR='minor'
    AUGMENTED='augmented'
    DIMINISHED='diminished'
    DOMINANT='dominant'
    MAJORSEVENTH='major-seventh'
    MINORSEVENTH='minor-seventh'
    DIMINISHEDSEVENTH='diminished-seventh'
    AUGMENTEDSEVENTH='augmented-seventh'
    HALFDIMINISHED='half-diminished'
    MAJORMINOR='major-minor'
    MAJORSIXTH='major-sixth'
    MINORSIXTH='minor-sixth'
    DOMINANTNINTH='dominant-ninth'
    MAJORNINTH='major-ninth'
    MINORNINTH='minor-ninth'
    DOMINANT_11_TH='dominant-11th'
    MAJOR_11_TH='major-11th'
    MINOR_11_TH='minor-11th'
    DOMINANT_13_TH='dominant-13th'
    MAJOR_13_TH='major-13th'
    MINOR_13_TH='minor-13th'
    SUSPENDEDSECOND='suspended-second'
    SUSPENDEDFOURTH='suspended-fourth'
    NEAPOLITAN='Neapolitan'
    ITALIAN='Italian'
    FRENCH='French'
    GERMAN='German'
    PEDAL='pedal'
    POWER='power'
    TRISTAN='Tristan'
    OTHER='other'
    NONE='none'


class left_center_right(str, Enum):
    """left-center-right -- The left-center-right type is used to define horizontal alignment and text justification.
    
    """
    LEFT='left'
    CENTER='center'
    RIGHT='right'


class left_right(str, Enum):
    """left-right -- The left-right type is used to indicate whether one element appears to the left or the right of another element.
    
    """
    LEFT='left'
    RIGHT='right'


class line_end(str, Enum):
    """line-end -- The line-end type specifies if there is a jog up or down (or both), an arrow, or nothing at the start or end of a bracket.
    
    """
    UP='up'
    DOWN='down'
    BOTH='both'
    ARROW='arrow'
    NONE='none'


class line_length(str, Enum):
    """line-length -- The line-length type distinguishes between different line lengths for doit, falloff, plop, and scoop articulations.
    
    """
    SHORT='short'
    MEDIUM='medium'
    LONG='long'


class line_shape(str, Enum):
    """line-shape -- The line-shape type distinguishes between straight and curved lines.
    
    """
    STRAIGHT='straight'
    CURVED='curved'


class line_type(str, Enum):
    """line-type -- The line-type type distinguishes between solid, dashed, dotted, and wavy lines.
    
    """
    SOLID='solid'
    DASHED='dashed'
    DOTTED='dotted'
    WAVY='wavy'


class margin_type(str, Enum):
    """margin-type -- The margin-type type specifies whether margins apply to even page, odd pages, or both.
    
    """
    ODD='odd'
    EVEN='even'
    BOTH='both'


class measure_numbering_value(str, Enum):
    """measure-numbering-value -- The measure-numbering-value type describes how measure numbers are displayed on this part: no numbers, numbers every measure, or numbers every system.
    
    """
    NONE='none'
    MEASURE='measure'
    SYSTEM='system'


class membrane_value(str, Enum):
    """membrane-value -- The membrane-value type represents pictograms for membrane percussion instruments.
    
    """
    BASSDRUM='bass drum'
    BASSDRUMONSIDE='bass drum on side'
    BONGOS='bongos'
    CHINESETOMTOM='Chinese tomtom'
    CONGADRUM='conga drum'
    CUICA='cuica'
    GOBLETDRUM='goblet drum'
    INDO_AMERICANTOMTOM='Indo-American tomtom'
    JAPANESETOMTOM='Japanese tomtom'
    MILITARYDRUM='military drum'
    SNAREDRUM='snare drum'
    SNAREDRUMSNARESOFF='snare drum snares off'
    TABLA='tabla'
    TAMBOURINE='tambourine'
    TENORDRUM='tenor drum'
    TIMBALES='timbales'
    TOMTOM='tomtom'


class metal_value(str, Enum):
    """metal-value -- The metal-value type represents pictograms for metal percussion instruments. The hi-hat value refers to a pictogram like Stone's high-h
    at cymbals but without the long vertical line at the bottom.
    
    """
    AGOGO='agogo'
    ALMGLOCKEN='almglocken'
    BELL='bell'
    BELLPLATE='bell plate'
    BELLTREE='bell tree'
    BRAKEDRUM='brake drum'
    CENCERRO='cencerro'
    CHAINRATTLE='chain rattle'
    CHINESECYMBAL='Chinese cymbal'
    COWBELL='cowbell'
    CRASHCYMBALS='crash cymbals'
    CROTALE='crotale'
    CYMBALTONGS='cymbal tongs'
    DOMEDGONG='domed gong'
    FINGERCYMBALS='finger cymbals'
    FLEXATONE='flexatone'
    GONG='gong'
    HIHAT='hi-hat'
    HIGHHATCYMBALS='high-hat cymbals'
    HANDBELL='handbell'
    JAWHARP='jaw harp'
    JINGLEBELLS='jingle bells'
    MUSICALSAW='musical saw'
    SHELLBELLS='shell bells'
    SISTRUM='sistrum'
    SIZZLECYMBAL='sizzle cymbal'
    SLEIGHBELLS='sleigh bells'
    SUSPENDEDCYMBAL='suspended cymbal'
    TAMTAM='tam tam'
    TAMTAMWITHBEATER='tam tam with beater'
    TRIANGLE='triangle'
    VIETNAMESEHAT='Vietnamese hat'


class mute(str, Enum):
    """mute -- The mute type represents muting for different instruments, including brass, winds, and strings. The on and off values are used for undifferentiated mutes. The remaining values represent specific mutes.
    
    """
    ON='on'
    OFF='off'
    STRAIGHT='straight'
    CUP='cup'
    HARMONNOSTEM='harmon-no-stem'
    HARMONSTEM='harmon-stem'
    BUCKET='bucket'
    PLUNGER='plunger'
    HAT='hat'
    SOLOTONE='solotone'
    PRACTICE='practice'
    STOPMUTE='stop-mute'
    STOPHAND='stop-hand'
    ECHO='echo'
    PALM='palm'


class note_size_type(str, Enum):
    """note-size-type -- The note-size-type type indicates the type of note being defined by a note-size element. The grace-cue type is used for notes of grace-cue size. The grace type is used for notes of cue size that include a grace element. The cue type is used for all other notes with cue size, whether defined explicitly or implicitly via a cue element. The large type is used for notes of large size.
    
    """
    CUE='cue'
    GRACE='grace'
    GRACECUE='grace-cue'
    LARGE='large'


class note_type_value(str, Enum):
    """note-type-value -- The note-type-value type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).
    
    """
    _1_024_TH='1024th'
    _5_12_TH='512th'
    _2_56_TH='256th'
    _1_28_TH='128th'
    _6_4_TH='64th'
    _3_2_ND='32nd'
    _1_6_TH='16th'
    EIGHTH='eighth'
    QUARTER='quarter'
    HALF='half'
    WHOLE='whole'
    BREVE='breve'
    LONG='long'
    MAXIMA='maxima'


class notehead_value(str, Enum):
    """notehead-value --
    The notehead-value type indicates shapes other than the open and closed ovals associated with note durations.
    The values do, re, mi, fa, fa up, so, la, and ti correspond to Aikin's 7-shape system.  The fa up shape is typically used with upstems; the fa shape is typically used with downstems or no stems.
    The arrow shapes differ from triangle and inverted triangle by being centered on the stem. Slashed and back slashed notes include both the normal notehead and a slash. The triangle shape has the tip of the triangle pointing up; the inverted triangle shape has the tip of the triangle pointing down. The left triangle shape is a right triangle with the hypotenuse facing up and to the left.
    The other notehead covers noteheads other than those listed here. It is usually used in combination with the smufl attribute to specify a particular SMuFL notehead. The smufl attribute may be used with any notehead value to help specify the appearance of symbols that share the same MusicXML semantics. Noteheads in the SMuFL Note name noteheads and Note name noteheads supplement ranges (U+E150
    –
    U+E1AF and U+EEE0
    –
    U+EEFF) should not use the smufl attribute or the "other" value, but instead use the notehead-text element.
    
    """
    SLASH='slash'
    TRIANGLE='triangle'
    DIAMOND='diamond'
    SQUARE='square'
    CROSS='cross'
    X='x'
    CIRCLEX='circle-x'
    INVERTEDTRIANGLE='inverted triangle'
    ARROWDOWN='arrow down'
    ARROWUP='arrow up'
    CIRCLED='circled'
    SLASHED='slashed'
    BACKSLASHED='back slashed'
    NORMAL='normal'
    CLUSTER='cluster'
    CIRCLEDOT='circle dot'
    LEFTTRIANGLE='left triangle'
    RECTANGLE='rectangle'
    NONE='none'
    DO='do'
    RE='re'
    MI='mi'
    FA='fa'
    FAUP='fa up'
    SO='so'
    LA='la'
    TI='ti'
    OTHER='other'


class number_or_normal(str, Enum):
    """number-or-normal -- The number-or-normal values can be either a decimal number or the string "normal". This is used by the line-height and letter-spacing attributes.
    
    """
    NORMAL='normal'


class numeral_mode(str, Enum):
    """numeral-mode -- The numeral-mode type specifies the mode similar to the mode type, but with a restricted set of values. The different minor values are used to interpret numeral-root values of 6 and 7 when present in a minor key. The harmonic minor value sharpens the 7 and the melodic minor value sharpens both 6 and 7. If a minor mode is used without qualification, either in the mode or numeral-mode elements, natural minor is used.
    
    """
    MAJOR='major'
    MINOR='minor'
    NATURALMINOR='natural minor'
    MELODICMINOR='melodic minor'
    HARMONICMINOR='harmonic minor'


class on_off(str, Enum):
    """on-off -- The on-off type is used for notation elements such as string mutes.
    
    """
    ON='on'
    OFF='off'


class over_under(str, Enum):
    """over-under -- The over-under type is used to indicate whether the tips of curved lines such as slurs and ties are overhand (tips down) or underhand (tips up).
    
    """
    OVER='over'
    UNDER='under'


class pedal_type(str, Enum):
    """pedal-type -- The pedal-type simple type is used to distinguish types of pedal directions. The start value indicates the start of a damper pedal, while the sostenuto value indicates the start of a sostenuto pedal. The other values can be used with either the damper or sostenuto pedal. The soft pedal is not included here because there is no special symbol or graphic used for it beyond what can be specified with words and bracket elements.
    The change, continue, discontinue, and resume types are used when the line attribute is yes. The change type indicates a pedal lift and retake indicated with an inverted V marking. The continue type allows more precise formatting across system breaks and for more complex pedaling lines. The discontinue type indicates the end of a pedal line that does not include the explicit lift represented by the stop type. The resume type indicates the start of a pedal line that does not include the downstroke represented by the start type. It can be used when a line resumes after being discontinued, or to start a pedal line that is preceded by a text or symbol representation of the pedal.
    
    """
    START='start'
    STOP='stop'
    SOSTENUTO='sostenuto'
    CHANGE='change'
    CONTINUE='continue'
    DISCONTINUE='discontinue'
    RESUME='resume'


class pitched_value(str, Enum):
    """pitched-value -- The pitched-value type represents pictograms for pitched percussion instruments. The chimes and tubular chimes values distinguish the single-line and double-line versions of the pictogram.
    
    """
    CELESTA='celesta'
    CHIMES='chimes'
    GLOCKENSPIEL='glockenspiel'
    LITHOPHONE='lithophone'
    MALLET='mallet'
    MARIMBA='marimba'
    STEELDRUMS='steel drums'
    TUBAPHONE='tubaphone'
    TUBULARCHIMES='tubular chimes'
    VIBRAPHONE='vibraphone'
    XYLOPHONE='xylophone'


class positive_integer_or_empty(str, Enum):
    """positive-integer-or-empty -- The positive-integer-or-empty values can be either a positive integer or an empty string.
    
    """
    _=''


class principal_voice_symbol(str, Enum):
    """principal-voice-symbol -- The principal-voice-symbol type represents the type of symbol used to indicate a principal or secondary voice. The "plain" value represents a plain square bracket. The value of "none" is used for analysis markup when the principal-voice element does not have a corresponding appearance in the score.
    
    """
    HAUPTSTIMME='Hauptstimme'
    NEBENSTIMME='Nebenstimme'
    PLAIN='plain'
    NONE='none'


class right_left_middle(str, Enum):
    """right-left-middle -- The right-left-middle type is used to specify barline location.
    
    """
    RIGHT='right'
    LEFT='left'
    MIDDLE='middle'


class semi_pitched(str, Enum):
    """semi-pitched -- The semi-pitched type represents categories of indefinite pitch for percussion instruments.
    
    """
    HIGH='high'
    MEDIUMHIGH='medium-high'
    MEDIUM='medium'
    MEDIUMLOW='medium-low'
    LOW='low'
    VERYLOW='very-low'


class show_frets(str, Enum):
    """show-frets -- The show-frets type indicates whether to show tablature frets as numbers (0, 1, 2) or letters (a, b, c). The default choice is numbers.
    
    """
    NUMBERS='numbers'
    LETTERS='letters'


class show_tuplet(str, Enum):
    """show-tuplet -- The show-tuplet type indicates whether to show a part of a tuplet relating to the tuplet-actual element, both the tuplet-actual and tuplet-normal elements, or neither.
    
    """
    ACTUAL='actual'
    BOTH='both'
    NONE='none'


class staff_divide_symbol(str, Enum):
    """staff-divide-symbol -- The staff-divide-symbol type is used for staff division symbols. The down, up, and up-down values correspond to SMuFL code points U+E00B, U+E00C, and U+E00D respectively.
    
    """
    DOWN='down'
    UP='up'
    UPDOWN='up-down'


class staff_type(str, Enum):
    """staff-type -- The staff-type value can be ossia, editorial, cue, alternate, or regular. An ossia staff represents music that can be played instead of what appears on the regular staff. An editorial staff also represents musical alternatives, but is created by an editor rather than the composer. It can be used for suggested interpretations or alternatives from other sources. A cue staff represents music from another part. An alternate staff shares the same music as the prior staff, but displayed differently (e.g., treble and bass clef, standard notation and tablature). It is not included in playback. An alternate staff provides more information to an application reading a file than encoding the same music in separate parts, so its use is preferred in this situation if feasible. A regular staff is the standard default staff-type.
    
    """
    OSSIA='ossia'
    EDITORIAL='editorial'
    CUE='cue'
    ALTERNATE='alternate'
    REGULAR='regular'


class start_note(str, Enum):
    """start-note -- The start-note type describes the starting note of trills and mordents for playback, relative to the current note.
    
    """
    UPPER='upper'
    MAIN='main'
    BELOW='below'


class start_stop(str, Enum):
    """start-stop -- The start-stop type is used for an attribute of musical elements that can either start or stop, such as tuplets.
    The values of start and stop refer to how an element appears in musical score order, not in MusicXML document order. An element with a stop attribute may precede the corresponding element with a start attribute within a MusicXML document. This is particularly common in multi-staff music. For example, the stopping point for a tuplet may appear in staff 1 before the starting point for the tuplet appears in staff 2 later in the document.
    When multiple elements with the same tag are used within the same note, their order within the MusicXML document should match the musical score order.
    
    """
    START='start'
    STOP='stop'


class start_stop_change_continue(str, Enum):
    """start-stop-change-continue -- The start-stop-change-continue type is used to distinguish types of pedal directions.
    
    """
    START='start'
    STOP='stop'
    CHANGE='change'
    CONTINUE='continue'


class start_stop_continue(str, Enum):
    """start-stop-continue -- The start-stop-continue type is used for an attribute of musical elements that can either start or stop, but also need to refer to an intermediate point in the symbol, as for complex slurs or for formatting of symbols across system breaks.
    The values of start, stop, and continue refer to how an element appears in musical score order, not in MusicXML document order. An element with a stop attribute may precede the corresponding element with a start attribute within a MusicXML document. This is particularly common in multi-staff music. For example, the stopping point for a slur may appear in staff 1 before the starting point for the slur appears in staff 2 later in the document.
    When multiple elements with the same tag are used within the same note, their order within the MusicXML document should match the musical score order. For example, a note that marks both the end of one slur and the start of a new slur should have the incoming slur element with a type of stop precede the outgoing slur element with a type of start.
    
    """
    START='start'
    STOP='stop'
    CONTINUE='continue'


class start_stop_discontinue(str, Enum):
    """start-stop-discontinue -- The start-stop-discontinue type is used to specify ending types. Typically, the start type is associated with the left barline of the first measure in an ending. The stop and discontinue types are associated with the right barline of the last measure in an ending. Stop is used when the ending mark concludes with a downward jog, as is typical for first endings. Discontinue is used when there is no downward jog, as is typical for second endings that do not conclude a piece.
    
    """
    START='start'
    STOP='stop'
    DISCONTINUE='discontinue'


class start_stop_single(str, Enum):
    """start-stop-single -- The start-stop-single type is used for an attribute of musical elements that can be used for either multi-note or single-note musical elements, as for groupings.
    When multiple elements with the same tag are used within the same note, their order within the MusicXML document should match the musical score order.
    
    """
    START='start'
    STOP='stop'
    SINGLE='single'


class stem_value(str, Enum):
    """stem-value -- The stem-value type represents the notated stem direction.
    
    """
    DOWN='down'
    UP='up'
    DOUBLE='double'
    NONE='none'


class step(str, Enum):
    """step -- The step type represents a step of the diatonic scale, represented using the English letters A through G.
    
    """
    A='A'
    B='B'
    C='C'
    D='D'
    E='E'
    F='F'
    G='G'


class stick_location(str, Enum):
    """stick-location -- The stick-location type represents pictograms for the location of sticks, beaters, or mallets on cymbals, gongs, drums, and other instruments.
    
    """
    CENTER='center'
    RIM='rim'
    CYMBALBELL='cymbal bell'
    CYMBALEDGE='cymbal edge'


class stick_material(str, Enum):
    """stick-material -- The stick-material type represents the material being displayed in a stick pictogram.
    
    """
    SOFT='soft'
    MEDIUM='medium'
    HARD='hard'
    SHADED='shaded'
    X='x'


class stick_type(str, Enum):
    """stick-type -- The stick-type type represents the shape of pictograms where the material in the stick, mallet, or beater is represented in the pictogram.
    
    """
    BASSDRUM='bass drum'
    DOUBLEBASSDRUM='double bass drum'
    GLOCKENSPIEL='glockenspiel'
    GUM='gum'
    HAMMER='hammer'
    SUPERBALL='superball'
    TIMPANI='timpani'
    WOUND='wound'
    XYLOPHONE='xylophone'
    YARN='yarn'


class swing_type_value(str, Enum):
    """The swing-type-value type specifies the note type, either eighth or 16th, to which the ratio defined in the swing element is applied.
    swing-type-value -- The swing-type-value type specifies the note type, either eighth or 16th, to which the ratio defined in the swing element is applied.
    
    """
    _1_6_TH='16th'
    EIGHTH='eighth'


class syllabic(str, Enum):
    """syllabic -- Lyric hyphenation is indicated by the syllabic type. The single, begin, end, and middle values represent single-syllable words, word-beginning syllables, word-ending syllables, and mid-word syllables, respectively.
    
    """
    SINGLE='single'
    BEGIN='begin'
    END='end'
    MIDDLE='middle'


class symbol_size(str, Enum):
    """symbol-size -- The symbol-size type is used to distinguish between full, cue sized, grace cue sized, and oversized symbols.
    
    """
    FULL='full'
    CUE='cue'
    GRACECUE='grace-cue'
    LARGE='large'


class sync_type(str, Enum):
    """sync-type -- The sync-type type specifies the style that a score following application should use to synchronize an accompaniment with a performer. The none type indicates no synchronization to the performer. The tempo type indicates synchronization based on the performer tempo rather than individual events in the score. The event type indicates synchronization by following the performance of individual events in the score rather than the performer tempo. The mostly-tempo and mostly-event types combine these two approaches, with mostly-tempo giving more weight to tempo and mostly-event giving more weight to performed events. The always-event type provides the strictest synchronization by not being forgiving of missing performed events.
    
    """
    NONE='none'
    TEMPO='tempo'
    MOSTLYTEMPO='mostly-tempo'
    MOSTLYEVENT='mostly-event'
    EVENT='event'
    ALWAYSEVENT='always-event'


class system_relation(str, Enum):
    """system-relation -- The system-relation type distinguishes elements that are associated with a system rather than the particular part where the element appears. A value of only-top indicates that the element should appear only on the top part of the current system. A value of also-top indicates that the element should appear on both the current part and the top part of the current system. If this value appears in a score, when parts are created the element should only appear once in this part, not twice. A value of none indicates that the element is associated only with the current part, not with the system.
    
    """
    ONLYTOP='only-top'
    ALSOTOP='also-top'
    NONE='none'


class system_relation_number(str, Enum):
    """system-relation-number -- The system-relation-number type distinguishes measure numbers that are associated with a system rather than the particular part where the element appears. A value of only-top or only-bottom indicates that the number should appear only on the top or bottom part of the current system, respectively. A value of also-top or also-bottom indicates that the number should appear on both the current part and the top or bottom part of the current system, respectively. If these values appear in a score, when parts are created the number should only appear once in this part, not twice. A value of none indicates that the number is associated only with the current part, not with the system.
    
    """
    ONLYTOP='only-top'
    ONLYBOTTOM='only-bottom'
    ALSOTOP='also-top'
    ALSOBOTTOM='also-bottom'
    NONE='none'


class tap_hand(str, Enum):
    """tap-hand -- The tap-hand type represents the symbol to use for a tap element. The left and right values refer to the SMuFL guitarLeftHandTapping and guitarRightHandTapping glyphs respectively.
    
    """
    LEFT='left'
    RIGHT='right'


class text_direction(str, Enum):
    """text-direction -- The text-direction type is used to adjust and override the Unicode bidirectional text algorithm, similar to the Directionality data category in the W3C Internationalization Tag Set recommendation. Values are ltr (left-to-right embed), rtl (right-to-left embed), lro (left-to-right bidi-override), and rlo (right-to-left bidi-override). The default value is ltr. This type is typically used by applications that store text in left-to-right visual order rather than logical order. Such applications can use the lro value to better communicate with other applications that more fully support bidirectional text.
    
    """
    LTR='ltr'
    RTL='rtl'
    LRO='lro'
    RLO='rlo'


class tied_type(str, Enum):
    """tied-type -- The tied-type type is used as an attribute of the tied element to specify where the visual representation of a tie begins and ends. A tied element which joins two notes of the same pitch can be specified with tied-type start on the first note and tied-type stop on the second note. To indicate a note should be undamped, use a single tied element with tied-type let-ring. For other ties that are visually attached to a single note, such as a tie leading into or out of a repeated section or coda, use two tied elements on the same note, one start and one stop.
    In start-stop cases, ties can add more elements using a continue type. This is typically used to specify the formatting of cross-system ties.
    When multiple elements with the same tag are used within the same note, their order within the MusicXML document should match the musical score order. For example, a note with a tie at the end of a first ending should have the tied element with a type of start precede the tied element with a type of stop.
    
    """
    START='start'
    STOP='stop'
    CONTINUE='continue'
    LETRING='let-ring'


class time_relation(str, Enum):
    """time-relation -- The time-relation type indicates the symbol used to represent the interchangeable aspect of dual time signatures.
    
    """
    PARENTHESES='parentheses'
    BRACKET='bracket'
    EQUALS='equals'
    SLASH='slash'
    SPACE='space'
    HYPHEN='hyphen'


class time_separator(str, Enum):
    """time-separator -- The time-separator type indicates how to display the arrangement between the beats and beat-type values in a time signature. The default value is none. The horizontal, diagonal, and vertical values represent horizontal, diagonal lower-left to upper-right, and vertical lines respectively. For these values, the beats and beat-type values are arranged on either side of the separator line. The none value represents no separator with the beats and beat-type arranged vertically. The adjacent value represents no separator with the beats and beat-type arranged horizontally.
    
    """
    NONE='none'
    HORIZONTAL='horizontal'
    DIAGONAL='diagonal'
    VERTICAL='vertical'
    ADJACENT='adjacent'


class time_symbol(str, Enum):
    """time-symbol -- The time-symbol type indicates how to display a time signature. The normal value is the usual fractional display, and is the implied symbol type if none is specified. Other options are the common and cut time symbols, as well as a single number with an implied denominator. The note symbol indicates that the beat-type should be represented with the corresponding downstem note rather than a number. The dotted-note symbol indicates that the beat-type should be represented with a dotted downstem note that corresponds to three times the beat-type value, and a numerator that is one third the beats value.
    
    """
    COMMON='common'
    CUT='cut'
    SINGLENUMBER='single-number'
    NOTE='note'
    DOTTEDNOTE='dotted-note'
    NORMAL='normal'


class tip_direction(str, Enum):
    """tip-direction -- The tip-direction type represents the direction in which the tip of a stick or beater points, using Unicode arrow terminology.
    
    """
    UP='up'
    DOWN='down'
    LEFT='left'
    RIGHT='right'
    NORTHWEST='northwest'
    NORTHEAST='northeast'
    SOUTHEAST='southeast'
    SOUTHWEST='southwest'


class top_bottom(str, Enum):
    """top-bottom -- The top-bottom type is used to indicate the top or bottom part of a vertical shape like non-arpeggiate.
    
    """
    TOP='top'
    BOTTOM='bottom'


class tremolo_type(str, Enum):
    """tremolo-type -- The tremolo-type is used to distinguish double-note, single-note, and unmeasured tremolos.
    
    """
    START='start'
    STOP='stop'
    SINGLE='single'
    UNMEASURED='unmeasured'


class trill_step(str, Enum):
    """trill-step -- The trill-step type describes the alternating note of trills and mordents for playback, relative to the current note.
    
    """
    WHOLE='whole'
    HALF='half'
    UNISON='unison'


class two_note_turn(str, Enum):
    """two-note-turn -- The two-note-turn type describes the ending notes of trills and mordents for playback, relative to the current note.
    
    """
    WHOLE='whole'
    HALF='half'
    NONE='none'


class up_down(str, Enum):
    """up-down -- The up-down type is used for the direction of arrows and other pointed symbols like vertical accents, indicating which way the tip is pointing.
    
    """
    UP='up'
    DOWN='down'


class up_down_stop_continue(str, Enum):
    """up-down-stop-continue -- The up-down-stop-continue type is used for octave-shift elements, indicating the direction of the shift from their true pitched values because of printing difficulty.
    
    """
    UP='up'
    DOWN='down'
    STOP='stop'
    CONTINUE='continue'


class upright_inverted(str, Enum):
    """upright-inverted -- The upright-inverted type describes the appearance of a fermata element. The value is upright if not specified.
    
    """
    UPRIGHT='upright'
    INVERTED='inverted'


class valign(str, Enum):
    """valign -- The valign type is used to indicate vertical alignment to the top, middle, bottom, or baseline of the text. If the text is on multiple lines, baseline alignment refers to the baseline of the lowest line of text. Defaults are implementation-dependent.
    
    """
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valign_image(str, Enum):
    """valign-image -- The valign-image type is used to indicate vertical alignment for images and graphics, so it does not include a baseline value. Defaults are implementation-dependent.
    
    """
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'


class wedge_type(str, Enum):
    """wedge-type -- The wedge type is crescendo for the start of a wedge that is closed at the left side, diminuendo for the start of a wedge that is closed on the right side, and stop for the end of a wedge. The continue type is used for formatting wedges over a system break, or for other situations where a single wedge is divided into multiple segments.
    
    """
    CRESCENDO='crescendo'
    DIMINUENDO='diminuendo'
    STOP='stop'
    CONTINUE='continue'


class winged(str, Enum):
    """winged -- The winged attribute indicates whether the repeat has winged extensions that appear above and below the barline. The straight and curved values represent single wings, while the double-straight and double-curved values represent double wings. The none value indicates no wings and is the default.
    
    """
    NONE='none'
    STRAIGHT='straight'
    CURVED='curved'
    DOUBLESTRAIGHT='double-straight'
    DOUBLECURVED='double-curved'


class wood_value(str, Enum):
    """wood-value -- The wood-value type represents pictograms for wood percussion instruments. The maraca and maracas values distinguish the one- and two-maraca versions of the pictogram.
    
    """
    BAMBOOSCRAPER='bamboo scraper'
    BOARDCLAPPER='board clapper'
    CABASA='cabasa'
    CASTANETS='castanets'
    CASTANETSWITHHANDLE='castanets with handle'
    CLAVES='claves'
    FOOTBALLRATTLE='football rattle'
    GUIRO='guiro'
    LOGDRUM='log drum'
    MARACA='maraca'
    MARACAS='maracas'
    QUIJADA='quijada'
    RAINSTICK='rainstick'
    RATCHET='ratchet'
    RECORECO='reco-reco'
    SANDPAPERBLOCKS='sandpaper blocks'
    SLITDRUM='slit drum'
    TEMPLEBLOCK='temple block'
    VIBRASLAP='vibraslap'
    WHIP='whip'
    WOODBLOCK='wood block'


class yes_no(str, Enum):
    """yes-no -- The yes-no type is used for boolean-like attributes. We cannot use W3C XML Schema booleans due to their restrictions on expression of boolean values.
    
    """
    YES='yes'
    NO='no'


class accidental_text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, justify=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, underline=None, overline=None, line_through=None, rotation=None, letter_spacing=None, line_height=None, lang=None, space=None, dir=None, enclosure=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.underline = _cast(int, underline)
        self.underline_nsprefix_ = None
        self.overline = _cast(int, overline)
        self.overline_nsprefix_ = None
        self.line_through = _cast(int, line_through)
        self.line_through_nsprefix_ = None
        self.rotation = _cast(float, rotation)
        self.rotation_nsprefix_ = None
        self.letter_spacing = _cast(None, letter_spacing)
        self.letter_spacing_nsprefix_ = None
        self.line_height = _cast(None, line_height)
        self.line_height_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.space = _cast(None, space)
        self.space_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        self.enclosure = _cast(None, enclosure)
        self.enclosure_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accidental_text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accidental_text.subclass:
            return accidental_text.subclass(*args_, **kwargs_)
        else:
            return accidental_text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def get_overline(self):
        return self.overline
    def set_overline(self, overline):
        self.overline = overline
    def get_line_through(self):
        return self.line_through
    def set_line_through(self, line_through):
        self.line_through = line_through
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    def get_letter_spacing(self):
        return self.letter_spacing
    def set_letter_spacing(self, letter_spacing):
        self.letter_spacing = letter_spacing
    def get_line_height(self):
        return self.line_height
    def set_line_height(self, line_height):
        self.line_height = line_height
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_space(self):
        return self.space
    def set_space(self, space):
        self.space = space
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def get_enclosure(self):
        return self.enclosure
    def set_enclosure(self, enclosure):
        self.enclosure = enclosure
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_accidental_value(self, value):
        result = True
        # Validate type accidental-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['sharp', 'natural', 'flat', 'double-sharp', 'sharp-sharp', 'flat-flat', 'natural-sharp', 'natural-flat', 'quarter-flat', 'quarter-sharp', 'three-quarters-flat', 'three-quarters-sharp', 'sharp-down', 'sharp-up', 'natural-down', 'natural-up', 'flat-down', 'flat-up', 'double-sharp-down', 'double-sharp-up', 'flat-flat-down', 'flat-flat-up', 'arrow-down', 'arrow-up', 'triple-sharp', 'triple-flat', 'slash-quarter-sharp', 'slash-sharp', 'slash-flat', 'double-slash-flat', 'sharp-1', 'sharp-2', 'sharp-3', 'sharp-5', 'flat-1', 'flat-2', 'flat-3', 'flat-4', 'sori', 'koron', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on accidental-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_accidental_glyph_name(self, value):
        # Validate type smufl-accidental-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_accidental_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_accidental_glyph_name_patterns_, ))
    validate_smufl_accidental_glyph_name_patterns_ = [['^((acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)(\\c+))$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_of_lines(self, value):
        # Validate type number-of-lines, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
            if value > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
    def validate_rotation_degrees(self, value):
        # Validate type rotation-degrees, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
    def validate_number_or_normal(self, value):
        # Validate type number-or-normal, a restriction on xs:token.
        pass
    def validate_text_direction(self, value):
        # Validate type text-direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ltr', 'rtl', 'lro', 'rlo']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on text-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_enclosure_shape(self, value):
        # Validate type enclosure-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rectangle', 'square', 'oval', 'circle', 'bracket', 'inverted-bracket', 'triangle', 'diamond', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on enclosure-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accidental-text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accidental-text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accidental-text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accidental-text')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accidental-text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accidental-text'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.underline is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            outfile.write(' underline="%s"' % self.gds_format_integer(self.underline, input_name='underline'))
        if self.overline is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            outfile.write(' overline="%s"' % self.gds_format_integer(self.overline, input_name='overline'))
        if self.line_through is not None and 'line_through' not in already_processed:
            already_processed.add('line_through')
            outfile.write(' line-through="%s"' % self.gds_format_integer(self.line_through, input_name='line-through'))
        if self.rotation is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            outfile.write(' rotation="%s"' % self.gds_format_decimal(self.rotation, input_name='rotation'))
        if self.letter_spacing is not None and 'letter_spacing' not in already_processed:
            already_processed.add('letter_spacing')
            outfile.write(' letter-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.letter_spacing), input_name='letter-spacing')), ))
        if self.line_height is not None and 'line_height' not in already_processed:
            already_processed.add('line_height')
            outfile.write(' line-height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_height), input_name='line-height')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' xml:space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
        if self.enclosure is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            outfile.write(' enclosure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.enclosure), input_name='enclosure')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accidental-text', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_accidental_glyph_name(self.smufl)    # validate type smufl-accidental-glyph-name
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('underline', node)
        if value is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            self.underline = self.gds_parse_integer(value, node, 'underline')
            if self.underline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.underline)    # validate type number-of-lines
        value = find_attr_value_('overline', node)
        if value is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            self.overline = self.gds_parse_integer(value, node, 'overline')
            if self.overline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.overline)    # validate type number-of-lines
        value = find_attr_value_('line-through', node)
        if value is not None and 'line-through' not in already_processed:
            already_processed.add('line-through')
            self.line_through = self.gds_parse_integer(value, node, 'line-through')
            if self.line_through < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.line_through)    # validate type number-of-lines
        value = find_attr_value_('rotation', node)
        if value is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            value = self.gds_parse_decimal(value, node, 'rotation')
            self.rotation = value
            self.validate_rotation_degrees(self.rotation)    # validate type rotation-degrees
        value = find_attr_value_('letter-spacing', node)
        if value is not None and 'letter-spacing' not in already_processed:
            already_processed.add('letter-spacing')
            self.letter_spacing = value
            self.letter_spacing = ' '.join(self.letter_spacing.split())
            self.validate_number_or_normal(self.letter_spacing)    # validate type number-or-normal
        value = find_attr_value_('line-height', node)
        if value is not None and 'line-height' not in already_processed:
            already_processed.add('line-height')
            self.line_height = value
            self.line_height = ' '.join(self.line_height.split())
            self.validate_number_or_normal(self.line_height)    # validate type number-or-normal
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.dir = ' '.join(self.dir.split())
            self.validate_text_direction(self.dir)    # validate type text-direction
        value = find_attr_value_('enclosure', node)
        if value is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            self.enclosure = value
            self.enclosure = ' '.join(self.enclosure.split())
            self.validate_enclosure_shape(self.enclosure)    # validate type enclosure-shape
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class accidental_text


class coda(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, coda)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if coda.subclass:
            return coda.subclass(*args_, **kwargs_)
        else:
            return coda(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_smufl_coda_glyph_name(self, value):
        # Validate type smufl-coda-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_coda_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_coda_glyph_name_patterns_, ))
    validate_smufl_coda_glyph_name_patterns_ = [['^(coda\\c*)$']]
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='coda', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('coda')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'coda':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='coda')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='coda', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='coda'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='coda', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_coda_glyph_name(self.smufl)    # validate type smufl-coda-glyph-name
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class coda


class dynamics(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, placement=None, underline=None, overline=None, line_through=None, enclosure=None, id=None, p=None, pp=None, ppp=None, pppp=None, ppppp=None, pppppp=None, f=None, ff=None, fff=None, ffff=None, fffff=None, ffffff=None, mp=None, mf=None, sf=None, sfp=None, sfpp=None, fp=None, rf=None, rfz=None, sfz=None, sffz=None, fz=None, n=None, pf=None, sfzp=None, other_dynamics=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.underline = _cast(int, underline)
        self.underline_nsprefix_ = None
        self.overline = _cast(int, overline)
        self.overline_nsprefix_ = None
        self.line_through = _cast(int, line_through)
        self.line_through_nsprefix_ = None
        self.enclosure = _cast(None, enclosure)
        self.enclosure_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if p is None:
            self.p = []
        else:
            self.p = p
        self.p_nsprefix_ = None
        if pp is None:
            self.pp = []
        else:
            self.pp = pp
        self.pp_nsprefix_ = None
        if ppp is None:
            self.ppp = []
        else:
            self.ppp = ppp
        self.ppp_nsprefix_ = None
        if pppp is None:
            self.pppp = []
        else:
            self.pppp = pppp
        self.pppp_nsprefix_ = None
        if ppppp is None:
            self.ppppp = []
        else:
            self.ppppp = ppppp
        self.ppppp_nsprefix_ = None
        if pppppp is None:
            self.pppppp = []
        else:
            self.pppppp = pppppp
        self.pppppp_nsprefix_ = None
        if f is None:
            self.f = []
        else:
            self.f = f
        self.f_nsprefix_ = None
        if ff is None:
            self.ff = []
        else:
            self.ff = ff
        self.ff_nsprefix_ = None
        if fff is None:
            self.fff = []
        else:
            self.fff = fff
        self.fff_nsprefix_ = None
        if ffff is None:
            self.ffff = []
        else:
            self.ffff = ffff
        self.ffff_nsprefix_ = None
        if fffff is None:
            self.fffff = []
        else:
            self.fffff = fffff
        self.fffff_nsprefix_ = None
        if ffffff is None:
            self.ffffff = []
        else:
            self.ffffff = ffffff
        self.ffffff_nsprefix_ = None
        if mp is None:
            self.mp = []
        else:
            self.mp = mp
        self.mp_nsprefix_ = None
        if mf is None:
            self.mf = []
        else:
            self.mf = mf
        self.mf_nsprefix_ = None
        if sf is None:
            self.sf = []
        else:
            self.sf = sf
        self.sf_nsprefix_ = None
        if sfp is None:
            self.sfp = []
        else:
            self.sfp = sfp
        self.sfp_nsprefix_ = None
        if sfpp is None:
            self.sfpp = []
        else:
            self.sfpp = sfpp
        self.sfpp_nsprefix_ = None
        if fp is None:
            self.fp = []
        else:
            self.fp = fp
        self.fp_nsprefix_ = None
        if rf is None:
            self.rf = []
        else:
            self.rf = rf
        self.rf_nsprefix_ = None
        if rfz is None:
            self.rfz = []
        else:
            self.rfz = rfz
        self.rfz_nsprefix_ = None
        if sfz is None:
            self.sfz = []
        else:
            self.sfz = sfz
        self.sfz_nsprefix_ = None
        if sffz is None:
            self.sffz = []
        else:
            self.sffz = sffz
        self.sffz_nsprefix_ = None
        if fz is None:
            self.fz = []
        else:
            self.fz = fz
        self.fz_nsprefix_ = None
        if n is None:
            self.n = []
        else:
            self.n = n
        self.n_nsprefix_ = None
        if pf is None:
            self.pf = []
        else:
            self.pf = pf
        self.pf_nsprefix_ = None
        if sfzp is None:
            self.sfzp = []
        else:
            self.sfzp = sfzp
        self.sfzp_nsprefix_ = None
        if other_dynamics is None:
            self.other_dynamics = []
        else:
            self.other_dynamics = other_dynamics
        self.other_dynamics_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dynamics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dynamics.subclass:
            return dynamics.subclass(*args_, **kwargs_)
        else:
            return dynamics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_p(self):
        return self.p
    def set_p(self, p):
        self.p = p
    def add_p(self, value):
        self.p.append(value)
    def insert_p_at(self, index, value):
        self.p.insert(index, value)
    def replace_p_at(self, index, value):
        self.p[index] = value
    def get_pp(self):
        return self.pp
    def set_pp(self, pp):
        self.pp = pp
    def add_pp(self, value):
        self.pp.append(value)
    def insert_pp_at(self, index, value):
        self.pp.insert(index, value)
    def replace_pp_at(self, index, value):
        self.pp[index] = value
    def get_ppp(self):
        return self.ppp
    def set_ppp(self, ppp):
        self.ppp = ppp
    def add_ppp(self, value):
        self.ppp.append(value)
    def insert_ppp_at(self, index, value):
        self.ppp.insert(index, value)
    def replace_ppp_at(self, index, value):
        self.ppp[index] = value
    def get_pppp(self):
        return self.pppp
    def set_pppp(self, pppp):
        self.pppp = pppp
    def add_pppp(self, value):
        self.pppp.append(value)
    def insert_pppp_at(self, index, value):
        self.pppp.insert(index, value)
    def replace_pppp_at(self, index, value):
        self.pppp[index] = value
    def get_ppppp(self):
        return self.ppppp
    def set_ppppp(self, ppppp):
        self.ppppp = ppppp
    def add_ppppp(self, value):
        self.ppppp.append(value)
    def insert_ppppp_at(self, index, value):
        self.ppppp.insert(index, value)
    def replace_ppppp_at(self, index, value):
        self.ppppp[index] = value
    def get_pppppp(self):
        return self.pppppp
    def set_pppppp(self, pppppp):
        self.pppppp = pppppp
    def add_pppppp(self, value):
        self.pppppp.append(value)
    def insert_pppppp_at(self, index, value):
        self.pppppp.insert(index, value)
    def replace_pppppp_at(self, index, value):
        self.pppppp[index] = value
    def get_f(self):
        return self.f
    def set_f(self, f):
        self.f = f
    def add_f(self, value):
        self.f.append(value)
    def insert_f_at(self, index, value):
        self.f.insert(index, value)
    def replace_f_at(self, index, value):
        self.f[index] = value
    def get_ff(self):
        return self.ff
    def set_ff(self, ff):
        self.ff = ff
    def add_ff(self, value):
        self.ff.append(value)
    def insert_ff_at(self, index, value):
        self.ff.insert(index, value)
    def replace_ff_at(self, index, value):
        self.ff[index] = value
    def get_fff(self):
        return self.fff
    def set_fff(self, fff):
        self.fff = fff
    def add_fff(self, value):
        self.fff.append(value)
    def insert_fff_at(self, index, value):
        self.fff.insert(index, value)
    def replace_fff_at(self, index, value):
        self.fff[index] = value
    def get_ffff(self):
        return self.ffff
    def set_ffff(self, ffff):
        self.ffff = ffff
    def add_ffff(self, value):
        self.ffff.append(value)
    def insert_ffff_at(self, index, value):
        self.ffff.insert(index, value)
    def replace_ffff_at(self, index, value):
        self.ffff[index] = value
    def get_fffff(self):
        return self.fffff
    def set_fffff(self, fffff):
        self.fffff = fffff
    def add_fffff(self, value):
        self.fffff.append(value)
    def insert_fffff_at(self, index, value):
        self.fffff.insert(index, value)
    def replace_fffff_at(self, index, value):
        self.fffff[index] = value
    def get_ffffff(self):
        return self.ffffff
    def set_ffffff(self, ffffff):
        self.ffffff = ffffff
    def add_ffffff(self, value):
        self.ffffff.append(value)
    def insert_ffffff_at(self, index, value):
        self.ffffff.insert(index, value)
    def replace_ffffff_at(self, index, value):
        self.ffffff[index] = value
    def get_mp(self):
        return self.mp
    def set_mp(self, mp):
        self.mp = mp
    def add_mp(self, value):
        self.mp.append(value)
    def insert_mp_at(self, index, value):
        self.mp.insert(index, value)
    def replace_mp_at(self, index, value):
        self.mp[index] = value
    def get_mf(self):
        return self.mf
    def set_mf(self, mf):
        self.mf = mf
    def add_mf(self, value):
        self.mf.append(value)
    def insert_mf_at(self, index, value):
        self.mf.insert(index, value)
    def replace_mf_at(self, index, value):
        self.mf[index] = value
    def get_sf(self):
        return self.sf
    def set_sf(self, sf):
        self.sf = sf
    def add_sf(self, value):
        self.sf.append(value)
    def insert_sf_at(self, index, value):
        self.sf.insert(index, value)
    def replace_sf_at(self, index, value):
        self.sf[index] = value
    def get_sfp(self):
        return self.sfp
    def set_sfp(self, sfp):
        self.sfp = sfp
    def add_sfp(self, value):
        self.sfp.append(value)
    def insert_sfp_at(self, index, value):
        self.sfp.insert(index, value)
    def replace_sfp_at(self, index, value):
        self.sfp[index] = value
    def get_sfpp(self):
        return self.sfpp
    def set_sfpp(self, sfpp):
        self.sfpp = sfpp
    def add_sfpp(self, value):
        self.sfpp.append(value)
    def insert_sfpp_at(self, index, value):
        self.sfpp.insert(index, value)
    def replace_sfpp_at(self, index, value):
        self.sfpp[index] = value
    def get_fp(self):
        return self.fp
    def set_fp(self, fp):
        self.fp = fp
    def add_fp(self, value):
        self.fp.append(value)
    def insert_fp_at(self, index, value):
        self.fp.insert(index, value)
    def replace_fp_at(self, index, value):
        self.fp[index] = value
    def get_rf(self):
        return self.rf
    def set_rf(self, rf):
        self.rf = rf
    def add_rf(self, value):
        self.rf.append(value)
    def insert_rf_at(self, index, value):
        self.rf.insert(index, value)
    def replace_rf_at(self, index, value):
        self.rf[index] = value
    def get_rfz(self):
        return self.rfz
    def set_rfz(self, rfz):
        self.rfz = rfz
    def add_rfz(self, value):
        self.rfz.append(value)
    def insert_rfz_at(self, index, value):
        self.rfz.insert(index, value)
    def replace_rfz_at(self, index, value):
        self.rfz[index] = value
    def get_sfz(self):
        return self.sfz
    def set_sfz(self, sfz):
        self.sfz = sfz
    def add_sfz(self, value):
        self.sfz.append(value)
    def insert_sfz_at(self, index, value):
        self.sfz.insert(index, value)
    def replace_sfz_at(self, index, value):
        self.sfz[index] = value
    def get_sffz(self):
        return self.sffz
    def set_sffz(self, sffz):
        self.sffz = sffz
    def add_sffz(self, value):
        self.sffz.append(value)
    def insert_sffz_at(self, index, value):
        self.sffz.insert(index, value)
    def replace_sffz_at(self, index, value):
        self.sffz[index] = value
    def get_fz(self):
        return self.fz
    def set_fz(self, fz):
        self.fz = fz
    def add_fz(self, value):
        self.fz.append(value)
    def insert_fz_at(self, index, value):
        self.fz.insert(index, value)
    def replace_fz_at(self, index, value):
        self.fz[index] = value
    def get_n(self):
        return self.n
    def set_n(self, n):
        self.n = n
    def add_n(self, value):
        self.n.append(value)
    def insert_n_at(self, index, value):
        self.n.insert(index, value)
    def replace_n_at(self, index, value):
        self.n[index] = value
    def get_pf(self):
        return self.pf
    def set_pf(self, pf):
        self.pf = pf
    def add_pf(self, value):
        self.pf.append(value)
    def insert_pf_at(self, index, value):
        self.pf.insert(index, value)
    def replace_pf_at(self, index, value):
        self.pf[index] = value
    def get_sfzp(self):
        return self.sfzp
    def set_sfzp(self, sfzp):
        self.sfzp = sfzp
    def add_sfzp(self, value):
        self.sfzp.append(value)
    def insert_sfzp_at(self, index, value):
        self.sfzp.insert(index, value)
    def replace_sfzp_at(self, index, value):
        self.sfzp[index] = value
    def get_other_dynamics(self):
        return self.other_dynamics
    def set_other_dynamics(self, other_dynamics):
        self.other_dynamics = other_dynamics
    def add_other_dynamics(self, value):
        self.other_dynamics.append(value)
    def insert_other_dynamics_at(self, index, value):
        self.other_dynamics.insert(index, value)
    def replace_other_dynamics_at(self, index, value):
        self.other_dynamics[index] = value
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def get_overline(self):
        return self.overline
    def set_overline(self, overline):
        self.overline = overline
    def get_line_through(self):
        return self.line_through
    def set_line_through(self, line_through):
        self.line_through = line_through
    def get_enclosure(self):
        return self.enclosure
    def set_enclosure(self, enclosure):
        self.enclosure = enclosure
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_of_lines(self, value):
        # Validate type number-of-lines, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
            if value > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
    def validate_enclosure_shape(self, value):
        # Validate type enclosure-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rectangle', 'square', 'oval', 'circle', 'bracket', 'inverted-bracket', 'triangle', 'diamond', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on enclosure-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.p or
            self.pp or
            self.ppp or
            self.pppp or
            self.ppppp or
            self.pppppp or
            self.f or
            self.ff or
            self.fff or
            self.ffff or
            self.fffff or
            self.ffffff or
            self.mp or
            self.mf or
            self.sf or
            self.sfp or
            self.sfpp or
            self.fp or
            self.rf or
            self.rfz or
            self.sfz or
            self.sffz or
            self.fz or
            self.n or
            self.pf or
            self.sfzp or
            self.other_dynamics
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dynamics', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dynamics')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dynamics':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dynamics')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dynamics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dynamics'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.underline is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            outfile.write(' underline="%s"' % self.gds_format_integer(self.underline, input_name='underline'))
        if self.overline is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            outfile.write(' overline="%s"' % self.gds_format_integer(self.overline, input_name='overline'))
        if self.line_through is not None and 'line_through' not in already_processed:
            already_processed.add('line_through')
            outfile.write(' line-through="%s"' % self.gds_format_integer(self.line_through, input_name='line-through'))
        if self.enclosure is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            outfile.write(' enclosure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.enclosure), input_name='enclosure')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dynamics', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for p_ in self.p:
            namespaceprefix_ = self.p_nsprefix_ + ':' if (UseCapturedNS_ and self.p_nsprefix_) else ''
            p_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='p', pretty_print=pretty_print)
        for pp_ in self.pp:
            namespaceprefix_ = self.pp_nsprefix_ + ':' if (UseCapturedNS_ and self.pp_nsprefix_) else ''
            pp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pp', pretty_print=pretty_print)
        for ppp_ in self.ppp:
            namespaceprefix_ = self.ppp_nsprefix_ + ':' if (UseCapturedNS_ and self.ppp_nsprefix_) else ''
            ppp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ppp', pretty_print=pretty_print)
        for pppp_ in self.pppp:
            namespaceprefix_ = self.pppp_nsprefix_ + ':' if (UseCapturedNS_ and self.pppp_nsprefix_) else ''
            pppp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pppp', pretty_print=pretty_print)
        for ppppp_ in self.ppppp:
            namespaceprefix_ = self.ppppp_nsprefix_ + ':' if (UseCapturedNS_ and self.ppppp_nsprefix_) else ''
            ppppp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ppppp', pretty_print=pretty_print)
        for pppppp_ in self.pppppp:
            namespaceprefix_ = self.pppppp_nsprefix_ + ':' if (UseCapturedNS_ and self.pppppp_nsprefix_) else ''
            pppppp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pppppp', pretty_print=pretty_print)
        for f_ in self.f:
            namespaceprefix_ = self.f_nsprefix_ + ':' if (UseCapturedNS_ and self.f_nsprefix_) else ''
            f_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='f', pretty_print=pretty_print)
        for ff_ in self.ff:
            namespaceprefix_ = self.ff_nsprefix_ + ':' if (UseCapturedNS_ and self.ff_nsprefix_) else ''
            ff_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ff', pretty_print=pretty_print)
        for fff_ in self.fff:
            namespaceprefix_ = self.fff_nsprefix_ + ':' if (UseCapturedNS_ and self.fff_nsprefix_) else ''
            fff_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fff', pretty_print=pretty_print)
        for ffff_ in self.ffff:
            namespaceprefix_ = self.ffff_nsprefix_ + ':' if (UseCapturedNS_ and self.ffff_nsprefix_) else ''
            ffff_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ffff', pretty_print=pretty_print)
        for fffff_ in self.fffff:
            namespaceprefix_ = self.fffff_nsprefix_ + ':' if (UseCapturedNS_ and self.fffff_nsprefix_) else ''
            fffff_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fffff', pretty_print=pretty_print)
        for ffffff_ in self.ffffff:
            namespaceprefix_ = self.ffffff_nsprefix_ + ':' if (UseCapturedNS_ and self.ffffff_nsprefix_) else ''
            ffffff_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ffffff', pretty_print=pretty_print)
        for mp_ in self.mp:
            namespaceprefix_ = self.mp_nsprefix_ + ':' if (UseCapturedNS_ and self.mp_nsprefix_) else ''
            mp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mp', pretty_print=pretty_print)
        for mf_ in self.mf:
            namespaceprefix_ = self.mf_nsprefix_ + ':' if (UseCapturedNS_ and self.mf_nsprefix_) else ''
            mf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mf', pretty_print=pretty_print)
        for sf_ in self.sf:
            namespaceprefix_ = self.sf_nsprefix_ + ':' if (UseCapturedNS_ and self.sf_nsprefix_) else ''
            sf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sf', pretty_print=pretty_print)
        for sfp_ in self.sfp:
            namespaceprefix_ = self.sfp_nsprefix_ + ':' if (UseCapturedNS_ and self.sfp_nsprefix_) else ''
            sfp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sfp', pretty_print=pretty_print)
        for sfpp_ in self.sfpp:
            namespaceprefix_ = self.sfpp_nsprefix_ + ':' if (UseCapturedNS_ and self.sfpp_nsprefix_) else ''
            sfpp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sfpp', pretty_print=pretty_print)
        for fp_ in self.fp:
            namespaceprefix_ = self.fp_nsprefix_ + ':' if (UseCapturedNS_ and self.fp_nsprefix_) else ''
            fp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fp', pretty_print=pretty_print)
        for rf_ in self.rf:
            namespaceprefix_ = self.rf_nsprefix_ + ':' if (UseCapturedNS_ and self.rf_nsprefix_) else ''
            rf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rf', pretty_print=pretty_print)
        for rfz_ in self.rfz:
            namespaceprefix_ = self.rfz_nsprefix_ + ':' if (UseCapturedNS_ and self.rfz_nsprefix_) else ''
            rfz_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rfz', pretty_print=pretty_print)
        for sfz_ in self.sfz:
            namespaceprefix_ = self.sfz_nsprefix_ + ':' if (UseCapturedNS_ and self.sfz_nsprefix_) else ''
            sfz_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sfz', pretty_print=pretty_print)
        for sffz_ in self.sffz:
            namespaceprefix_ = self.sffz_nsprefix_ + ':' if (UseCapturedNS_ and self.sffz_nsprefix_) else ''
            sffz_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sffz', pretty_print=pretty_print)
        for fz_ in self.fz:
            namespaceprefix_ = self.fz_nsprefix_ + ':' if (UseCapturedNS_ and self.fz_nsprefix_) else ''
            fz_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fz', pretty_print=pretty_print)
        for n_ in self.n:
            namespaceprefix_ = self.n_nsprefix_ + ':' if (UseCapturedNS_ and self.n_nsprefix_) else ''
            n_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='n', pretty_print=pretty_print)
        for pf_ in self.pf:
            namespaceprefix_ = self.pf_nsprefix_ + ':' if (UseCapturedNS_ and self.pf_nsprefix_) else ''
            pf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pf', pretty_print=pretty_print)
        for sfzp_ in self.sfzp:
            namespaceprefix_ = self.sfzp_nsprefix_ + ':' if (UseCapturedNS_ and self.sfzp_nsprefix_) else ''
            sfzp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sfzp', pretty_print=pretty_print)
        for other_dynamics_ in self.other_dynamics:
            namespaceprefix_ = self.other_dynamics_nsprefix_ + ':' if (UseCapturedNS_ and self.other_dynamics_nsprefix_) else ''
            other_dynamics_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-dynamics', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('underline', node)
        if value is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            self.underline = self.gds_parse_integer(value, node, 'underline')
            if self.underline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.underline)    # validate type number-of-lines
        value = find_attr_value_('overline', node)
        if value is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            self.overline = self.gds_parse_integer(value, node, 'overline')
            if self.overline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.overline)    # validate type number-of-lines
        value = find_attr_value_('line-through', node)
        if value is not None and 'line-through' not in already_processed:
            already_processed.add('line-through')
            self.line_through = self.gds_parse_integer(value, node, 'line-through')
            if self.line_through < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.line_through)    # validate type number-of-lines
        value = find_attr_value_('enclosure', node)
        if value is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            self.enclosure = value
            self.enclosure = ' '.join(self.enclosure.split())
            self.validate_enclosure_shape(self.enclosure)    # validate type enclosure-shape
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'p':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.p.append(obj_)
            obj_.original_tagname_ = 'p'
        elif nodeName_ == 'pp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pp.append(obj_)
            obj_.original_tagname_ = 'pp'
        elif nodeName_ == 'ppp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ppp.append(obj_)
            obj_.original_tagname_ = 'ppp'
        elif nodeName_ == 'pppp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pppp.append(obj_)
            obj_.original_tagname_ = 'pppp'
        elif nodeName_ == 'ppppp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ppppp.append(obj_)
            obj_.original_tagname_ = 'ppppp'
        elif nodeName_ == 'pppppp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pppppp.append(obj_)
            obj_.original_tagname_ = 'pppppp'
        elif nodeName_ == 'f':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.f.append(obj_)
            obj_.original_tagname_ = 'f'
        elif nodeName_ == 'ff':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ff.append(obj_)
            obj_.original_tagname_ = 'ff'
        elif nodeName_ == 'fff':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fff.append(obj_)
            obj_.original_tagname_ = 'fff'
        elif nodeName_ == 'ffff':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ffff.append(obj_)
            obj_.original_tagname_ = 'ffff'
        elif nodeName_ == 'fffff':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fffff.append(obj_)
            obj_.original_tagname_ = 'fffff'
        elif nodeName_ == 'ffffff':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ffffff.append(obj_)
            obj_.original_tagname_ = 'ffffff'
        elif nodeName_ == 'mp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mp.append(obj_)
            obj_.original_tagname_ = 'mp'
        elif nodeName_ == 'mf':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mf.append(obj_)
            obj_.original_tagname_ = 'mf'
        elif nodeName_ == 'sf':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sf.append(obj_)
            obj_.original_tagname_ = 'sf'
        elif nodeName_ == 'sfp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sfp.append(obj_)
            obj_.original_tagname_ = 'sfp'
        elif nodeName_ == 'sfpp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sfpp.append(obj_)
            obj_.original_tagname_ = 'sfpp'
        elif nodeName_ == 'fp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fp.append(obj_)
            obj_.original_tagname_ = 'fp'
        elif nodeName_ == 'rf':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rf.append(obj_)
            obj_.original_tagname_ = 'rf'
        elif nodeName_ == 'rfz':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rfz.append(obj_)
            obj_.original_tagname_ = 'rfz'
        elif nodeName_ == 'sfz':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sfz.append(obj_)
            obj_.original_tagname_ = 'sfz'
        elif nodeName_ == 'sffz':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sffz.append(obj_)
            obj_.original_tagname_ = 'sffz'
        elif nodeName_ == 'fz':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fz.append(obj_)
            obj_.original_tagname_ = 'fz'
        elif nodeName_ == 'n':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.n.append(obj_)
            obj_.original_tagname_ = 'n'
        elif nodeName_ == 'pf':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pf.append(obj_)
            obj_.original_tagname_ = 'pf'
        elif nodeName_ == 'sfzp':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sfzp.append(obj_)
            obj_.original_tagname_ = 'sfzp'
        elif nodeName_ == 'other-dynamics':
            obj_ = other_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_dynamics.append(obj_)
            obj_.original_tagname_ = 'other-dynamics'
# end class dynamics


class empty(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty.subclass:
            return empty.subclass(*args_, **kwargs_)
        else:
            return empty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty


class empty_placement(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_placement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_placement.subclass:
            return empty_placement.subclass(*args_, **kwargs_)
        else:
            return empty_placement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-placement', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-placement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-placement':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-placement')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-placement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-placement'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-placement', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_placement


class empty_placement_smufl(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, smufl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_placement_smufl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_placement_smufl.subclass:
            return empty_placement_smufl.subclass(*args_, **kwargs_)
        else:
            return empty_placement_smufl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_smufl_glyph_name(self, value):
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-placement-smufl', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-placement-smufl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-placement-smufl':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-placement-smufl')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-placement-smufl', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-placement-smufl'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smufl), input_name='smufl')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-placement-smufl', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_glyph_name(self.smufl)    # validate type smufl-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_placement_smufl


class empty_print_style(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_print_style)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_print_style.subclass:
            return empty_print_style.subclass(*args_, **kwargs_)
        else:
            return empty_print_style(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-print-style', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-print-style')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-print-style':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-print-style')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-print-style', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-print-style'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-print-style', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_print_style


class empty_print_style_align(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_print_style_align)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_print_style_align.subclass:
            return empty_print_style_align.subclass(*args_, **kwargs_)
        else:
            return empty_print_style_align(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-print-style-align', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-print-style-align')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-print-style-align':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-print-style-align')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-print-style-align', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-print-style-align'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-print-style-align', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_print_style_align


class empty_print_style_align_id(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_print_style_align_id)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_print_style_align_id.subclass:
            return empty_print_style_align_id.subclass(*args_, **kwargs_)
        else:
            return empty_print_style_align_id(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-print-style-align-id', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-print-style-align-id')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-print-style-align-id':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-print-style-align-id')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-print-style-align-id', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-print-style-align-id'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-print-style-align-id', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_print_style_align_id


class empty_print_object_style_align(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, print_object=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_print_object_style_align)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_print_object_style_align.subclass:
            return empty_print_object_style_align.subclass(*args_, **kwargs_)
        else:
            return empty_print_object_style_align(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-print-object-style-align', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-print-object-style-align')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-print-object-style-align':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-print-object-style-align')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-print-object-style-align', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-print-object-style-align'):
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-print-object-style-align', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_print_object_style_align


class empty_trill_sound(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, start_note=None, trill_step=None, two_note_turn=None, accelerate=None, beats=None, second_beat=None, last_beat=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.start_note = _cast(None, start_note)
        self.start_note_nsprefix_ = None
        self.trill_step = _cast(None, trill_step)
        self.trill_step_nsprefix_ = None
        self.two_note_turn = _cast(None, two_note_turn)
        self.two_note_turn_nsprefix_ = None
        self.accelerate = _cast(None, accelerate)
        self.accelerate_nsprefix_ = None
        self.beats = _cast(float, beats)
        self.beats_nsprefix_ = None
        self.second_beat = _cast(float, second_beat)
        self.second_beat_nsprefix_ = None
        self.last_beat = _cast(float, last_beat)
        self.last_beat_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_trill_sound)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_trill_sound.subclass:
            return empty_trill_sound.subclass(*args_, **kwargs_)
        else:
            return empty_trill_sound(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_start_note(self):
        return self.start_note
    def set_start_note(self, start_note):
        self.start_note = start_note
    def get_trill_step(self):
        return self.trill_step
    def set_trill_step(self, trill_step):
        self.trill_step = trill_step
    def get_two_note_turn(self):
        return self.two_note_turn
    def set_two_note_turn(self, two_note_turn):
        self.two_note_turn = two_note_turn
    def get_accelerate(self):
        return self.accelerate
    def set_accelerate(self, accelerate):
        self.accelerate = accelerate
    def get_beats(self):
        return self.beats
    def set_beats(self, beats):
        self.beats = beats
    def get_second_beat(self):
        return self.second_beat
    def set_second_beat(self, second_beat):
        self.second_beat = second_beat
    def get_last_beat(self):
        return self.last_beat
    def set_last_beat(self, last_beat):
        self.last_beat = last_beat
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_start_note(self, value):
        # Validate type start-note, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['upper', 'main', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-note' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_trill_step(self, value):
        # Validate type trill-step, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['whole', 'half', 'unison']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on trill-step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_two_note_turn(self, value):
        # Validate type two-note-turn, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['whole', 'half', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on two-note-turn' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_trill_beats(self, value):
        # Validate type trill-beats, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on trill-beats' % {"value": value, "lineno": lineno} )
                result = False
    def validate_percent(self, value):
        # Validate type percent, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-trill-sound', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-trill-sound')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-trill-sound':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-trill-sound')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-trill-sound', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-trill-sound'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.start_note is not None and 'start_note' not in already_processed:
            already_processed.add('start_note')
            outfile.write(' start-note=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.start_note), input_name='start-note')), ))
        if self.trill_step is not None and 'trill_step' not in already_processed:
            already_processed.add('trill_step')
            outfile.write(' trill-step=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.trill_step), input_name='trill-step')), ))
        if self.two_note_turn is not None and 'two_note_turn' not in already_processed:
            already_processed.add('two_note_turn')
            outfile.write(' two-note-turn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.two_note_turn), input_name='two-note-turn')), ))
        if self.accelerate is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            outfile.write(' accelerate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accelerate), input_name='accelerate')), ))
        if self.beats is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            outfile.write(' beats="%s"' % self.gds_format_decimal(self.beats, input_name='beats'))
        if self.second_beat is not None and 'second_beat' not in already_processed:
            already_processed.add('second_beat')
            outfile.write(' second-beat="%s"' % self.gds_format_decimal(self.second_beat, input_name='second-beat'))
        if self.last_beat is not None and 'last_beat' not in already_processed:
            already_processed.add('last_beat')
            outfile.write(' last-beat="%s"' % self.gds_format_decimal(self.last_beat, input_name='last-beat'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-trill-sound', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('start-note', node)
        if value is not None and 'start-note' not in already_processed:
            already_processed.add('start-note')
            self.start_note = value
            self.start_note = ' '.join(self.start_note.split())
            self.validate_start_note(self.start_note)    # validate type start-note
        value = find_attr_value_('trill-step', node)
        if value is not None and 'trill-step' not in already_processed:
            already_processed.add('trill-step')
            self.trill_step = value
            self.trill_step = ' '.join(self.trill_step.split())
            self.validate_trill_step(self.trill_step)    # validate type trill-step
        value = find_attr_value_('two-note-turn', node)
        if value is not None and 'two-note-turn' not in already_processed:
            already_processed.add('two-note-turn')
            self.two_note_turn = value
            self.two_note_turn = ' '.join(self.two_note_turn.split())
            self.validate_two_note_turn(self.two_note_turn)    # validate type two-note-turn
        value = find_attr_value_('accelerate', node)
        if value is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            self.accelerate = value
            self.accelerate = ' '.join(self.accelerate.split())
            self.validate_yes_no(self.accelerate)    # validate type yes-no
        value = find_attr_value_('beats', node)
        if value is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            value = self.gds_parse_decimal(value, node, 'beats')
            self.beats = value
            self.validate_trill_beats(self.beats)    # validate type trill-beats
        value = find_attr_value_('second-beat', node)
        if value is not None and 'second-beat' not in already_processed:
            already_processed.add('second-beat')
            value = self.gds_parse_decimal(value, node, 'second-beat')
            self.second_beat = value
            self.validate_percent(self.second_beat)    # validate type percent
        value = find_attr_value_('last-beat', node)
        if value is not None and 'last-beat' not in already_processed:
            already_processed.add('last-beat')
            value = self.gds_parse_decimal(value, node, 'last-beat')
            self.last_beat = value
            self.validate_percent(self.last_beat)    # validate type percent
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_trill_sound


class horizontal_turn(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, slash=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, start_note=None, trill_step=None, two_note_turn=None, accelerate=None, beats=None, second_beat=None, last_beat=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.slash = _cast(None, slash)
        self.slash_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.start_note = _cast(None, start_note)
        self.start_note_nsprefix_ = None
        self.trill_step = _cast(None, trill_step)
        self.trill_step_nsprefix_ = None
        self.two_note_turn = _cast(None, two_note_turn)
        self.two_note_turn_nsprefix_ = None
        self.accelerate = _cast(None, accelerate)
        self.accelerate_nsprefix_ = None
        self.beats = _cast(float, beats)
        self.beats_nsprefix_ = None
        self.second_beat = _cast(float, second_beat)
        self.second_beat_nsprefix_ = None
        self.last_beat = _cast(float, last_beat)
        self.last_beat_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, horizontal_turn)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if horizontal_turn.subclass:
            return horizontal_turn.subclass(*args_, **kwargs_)
        else:
            return horizontal_turn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_slash(self):
        return self.slash
    def set_slash(self, slash):
        self.slash = slash
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_start_note(self):
        return self.start_note
    def set_start_note(self, start_note):
        self.start_note = start_note
    def get_trill_step(self):
        return self.trill_step
    def set_trill_step(self, trill_step):
        self.trill_step = trill_step
    def get_two_note_turn(self):
        return self.two_note_turn
    def set_two_note_turn(self, two_note_turn):
        self.two_note_turn = two_note_turn
    def get_accelerate(self):
        return self.accelerate
    def set_accelerate(self, accelerate):
        self.accelerate = accelerate
    def get_beats(self):
        return self.beats
    def set_beats(self, beats):
        self.beats = beats
    def get_second_beat(self):
        return self.second_beat
    def set_second_beat(self, second_beat):
        self.second_beat = second_beat
    def get_last_beat(self):
        return self.last_beat
    def set_last_beat(self, last_beat):
        self.last_beat = last_beat
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_start_note(self, value):
        # Validate type start-note, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['upper', 'main', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-note' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_trill_step(self, value):
        # Validate type trill-step, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['whole', 'half', 'unison']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on trill-step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_two_note_turn(self, value):
        # Validate type two-note-turn, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['whole', 'half', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on two-note-turn' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_trill_beats(self, value):
        # Validate type trill-beats, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on trill-beats' % {"value": value, "lineno": lineno} )
                result = False
    def validate_percent(self, value):
        # Validate type percent, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='horizontal-turn', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('horizontal-turn')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'horizontal-turn':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='horizontal-turn')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='horizontal-turn', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='horizontal-turn'):
        if self.slash is not None and 'slash' not in already_processed:
            already_processed.add('slash')
            outfile.write(' slash=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.slash), input_name='slash')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.start_note is not None and 'start_note' not in already_processed:
            already_processed.add('start_note')
            outfile.write(' start-note=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.start_note), input_name='start-note')), ))
        if self.trill_step is not None and 'trill_step' not in already_processed:
            already_processed.add('trill_step')
            outfile.write(' trill-step=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.trill_step), input_name='trill-step')), ))
        if self.two_note_turn is not None and 'two_note_turn' not in already_processed:
            already_processed.add('two_note_turn')
            outfile.write(' two-note-turn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.two_note_turn), input_name='two-note-turn')), ))
        if self.accelerate is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            outfile.write(' accelerate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accelerate), input_name='accelerate')), ))
        if self.beats is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            outfile.write(' beats="%s"' % self.gds_format_decimal(self.beats, input_name='beats'))
        if self.second_beat is not None and 'second_beat' not in already_processed:
            already_processed.add('second_beat')
            outfile.write(' second-beat="%s"' % self.gds_format_decimal(self.second_beat, input_name='second-beat'))
        if self.last_beat is not None and 'last_beat' not in already_processed:
            already_processed.add('last_beat')
            outfile.write(' last-beat="%s"' % self.gds_format_decimal(self.last_beat, input_name='last-beat'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='horizontal-turn', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('slash', node)
        if value is not None and 'slash' not in already_processed:
            already_processed.add('slash')
            self.slash = value
            self.slash = ' '.join(self.slash.split())
            self.validate_yes_no(self.slash)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('start-note', node)
        if value is not None and 'start-note' not in already_processed:
            already_processed.add('start-note')
            self.start_note = value
            self.start_note = ' '.join(self.start_note.split())
            self.validate_start_note(self.start_note)    # validate type start-note
        value = find_attr_value_('trill-step', node)
        if value is not None and 'trill-step' not in already_processed:
            already_processed.add('trill-step')
            self.trill_step = value
            self.trill_step = ' '.join(self.trill_step.split())
            self.validate_trill_step(self.trill_step)    # validate type trill-step
        value = find_attr_value_('two-note-turn', node)
        if value is not None and 'two-note-turn' not in already_processed:
            already_processed.add('two-note-turn')
            self.two_note_turn = value
            self.two_note_turn = ' '.join(self.two_note_turn.split())
            self.validate_two_note_turn(self.two_note_turn)    # validate type two-note-turn
        value = find_attr_value_('accelerate', node)
        if value is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            self.accelerate = value
            self.accelerate = ' '.join(self.accelerate.split())
            self.validate_yes_no(self.accelerate)    # validate type yes-no
        value = find_attr_value_('beats', node)
        if value is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            value = self.gds_parse_decimal(value, node, 'beats')
            self.beats = value
            self.validate_trill_beats(self.beats)    # validate type trill-beats
        value = find_attr_value_('second-beat', node)
        if value is not None and 'second-beat' not in already_processed:
            already_processed.add('second-beat')
            value = self.gds_parse_decimal(value, node, 'second-beat')
            self.second_beat = value
            self.validate_percent(self.second_beat)    # validate type percent
        value = find_attr_value_('last-beat', node)
        if value is not None and 'last-beat' not in already_processed:
            already_processed.add('last-beat')
            value = self.gds_parse_decimal(value, node, 'last-beat')
            self.last_beat = value
            self.validate_percent(self.last_beat)    # validate type percent
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class horizontal_turn


class fermata(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fermata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fermata.subclass:
            return fermata.subclass(*args_, **kwargs_)
        else:
            return fermata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_fermata_shape(self, value):
        result = True
        # Validate type fermata-shape, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'angled', 'square', 'double-angled', 'double-square', 'double-dot', 'half-curve', 'curlew', '']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on fermata-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_upright_inverted(self, value):
        # Validate type upright-inverted, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['upright', 'inverted']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on upright-inverted' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fermata', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fermata')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fermata':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fermata')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fermata', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fermata'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fermata', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_upright_inverted(self.type_)    # validate type upright-inverted
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class fermata


class fingering(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, substitution=None, alternate=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.substitution = _cast(None, substitution)
        self.substitution_nsprefix_ = None
        self.alternate = _cast(None, alternate)
        self.alternate_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fingering)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fingering.subclass:
            return fingering.subclass(*args_, **kwargs_)
        else:
            return fingering(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_substitution(self):
        return self.substitution
    def set_substitution(self, substitution):
        self.substitution = substitution
    def get_alternate(self):
        return self.alternate
    def set_alternate(self, alternate):
        self.alternate = alternate
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fingering', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fingering')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fingering':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fingering')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fingering', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fingering'):
        if self.substitution is not None and 'substitution' not in already_processed:
            already_processed.add('substitution')
            outfile.write(' substitution=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.substitution), input_name='substitution')), ))
        if self.alternate is not None and 'alternate' not in already_processed:
            already_processed.add('alternate')
            outfile.write(' alternate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alternate), input_name='alternate')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fingering', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('substitution', node)
        if value is not None and 'substitution' not in already_processed:
            already_processed.add('substitution')
            self.substitution = value
            self.substitution = ' '.join(self.substitution.split())
            self.validate_yes_no(self.substitution)    # validate type yes-no
        value = find_attr_value_('alternate', node)
        if value is not None and 'alternate' not in already_processed:
            already_processed.add('alternate')
            self.alternate = value
            self.alternate = ' '.join(self.alternate.split())
            self.validate_yes_no(self.alternate)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class fingering


class formatted_symbol(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, justify=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, underline=None, overline=None, line_through=None, rotation=None, letter_spacing=None, line_height=None, dir=None, enclosure=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.underline = _cast(int, underline)
        self.underline_nsprefix_ = None
        self.overline = _cast(int, overline)
        self.overline_nsprefix_ = None
        self.line_through = _cast(int, line_through)
        self.line_through_nsprefix_ = None
        self.rotation = _cast(float, rotation)
        self.rotation_nsprefix_ = None
        self.letter_spacing = _cast(None, letter_spacing)
        self.letter_spacing_nsprefix_ = None
        self.line_height = _cast(None, line_height)
        self.line_height_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        self.enclosure = _cast(None, enclosure)
        self.enclosure_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, formatted_symbol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if formatted_symbol.subclass:
            return formatted_symbol.subclass(*args_, **kwargs_)
        else:
            return formatted_symbol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def get_overline(self):
        return self.overline
    def set_overline(self, overline):
        self.overline = overline
    def get_line_through(self):
        return self.line_through
    def set_line_through(self, line_through):
        self.line_through = line_through
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    def get_letter_spacing(self):
        return self.letter_spacing
    def set_letter_spacing(self, letter_spacing):
        self.letter_spacing = letter_spacing
    def get_line_height(self):
        return self.line_height
    def set_line_height(self, line_height):
        self.line_height = line_height
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def get_enclosure(self):
        return self.enclosure
    def set_enclosure(self, enclosure):
        self.enclosure = enclosure
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_smufl_glyph_name(self, value):
        result = True
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_of_lines(self, value):
        # Validate type number-of-lines, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
            if value > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
    def validate_rotation_degrees(self, value):
        # Validate type rotation-degrees, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
    def validate_number_or_normal(self, value):
        # Validate type number-or-normal, a restriction on xs:token.
        pass
    def validate_text_direction(self, value):
        # Validate type text-direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ltr', 'rtl', 'lro', 'rlo']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on text-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_enclosure_shape(self, value):
        # Validate type enclosure-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rectangle', 'square', 'oval', 'circle', 'bracket', 'inverted-bracket', 'triangle', 'diamond', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on enclosure-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formatted-symbol', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('formatted-symbol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'formatted-symbol':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='formatted-symbol')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='formatted-symbol', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='formatted-symbol'):
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.underline is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            outfile.write(' underline="%s"' % self.gds_format_integer(self.underline, input_name='underline'))
        if self.overline is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            outfile.write(' overline="%s"' % self.gds_format_integer(self.overline, input_name='overline'))
        if self.line_through is not None and 'line_through' not in already_processed:
            already_processed.add('line_through')
            outfile.write(' line-through="%s"' % self.gds_format_integer(self.line_through, input_name='line-through'))
        if self.rotation is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            outfile.write(' rotation="%s"' % self.gds_format_decimal(self.rotation, input_name='rotation'))
        if self.letter_spacing is not None and 'letter_spacing' not in already_processed:
            already_processed.add('letter_spacing')
            outfile.write(' letter-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.letter_spacing), input_name='letter-spacing')), ))
        if self.line_height is not None and 'line_height' not in already_processed:
            already_processed.add('line_height')
            outfile.write(' line-height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_height), input_name='line-height')), ))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
        if self.enclosure is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            outfile.write(' enclosure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.enclosure), input_name='enclosure')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formatted-symbol', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('underline', node)
        if value is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            self.underline = self.gds_parse_integer(value, node, 'underline')
            if self.underline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.underline)    # validate type number-of-lines
        value = find_attr_value_('overline', node)
        if value is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            self.overline = self.gds_parse_integer(value, node, 'overline')
            if self.overline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.overline)    # validate type number-of-lines
        value = find_attr_value_('line-through', node)
        if value is not None and 'line-through' not in already_processed:
            already_processed.add('line-through')
            self.line_through = self.gds_parse_integer(value, node, 'line-through')
            if self.line_through < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.line_through)    # validate type number-of-lines
        value = find_attr_value_('rotation', node)
        if value is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            value = self.gds_parse_decimal(value, node, 'rotation')
            self.rotation = value
            self.validate_rotation_degrees(self.rotation)    # validate type rotation-degrees
        value = find_attr_value_('letter-spacing', node)
        if value is not None and 'letter-spacing' not in already_processed:
            already_processed.add('letter-spacing')
            self.letter_spacing = value
            self.letter_spacing = ' '.join(self.letter_spacing.split())
            self.validate_number_or_normal(self.letter_spacing)    # validate type number-or-normal
        value = find_attr_value_('line-height', node)
        if value is not None and 'line-height' not in already_processed:
            already_processed.add('line-height')
            self.line_height = value
            self.line_height = ' '.join(self.line_height.split())
            self.validate_number_or_normal(self.line_height)    # validate type number-or-normal
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.dir = ' '.join(self.dir.split())
            self.validate_text_direction(self.dir)    # validate type text-direction
        value = find_attr_value_('enclosure', node)
        if value is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            self.enclosure = value
            self.enclosure = ' '.join(self.enclosure.split())
            self.validate_enclosure_shape(self.enclosure)    # validate type enclosure-shape
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class formatted_symbol


class formatted_symbol_id(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, justify=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, underline=None, overline=None, line_through=None, rotation=None, letter_spacing=None, line_height=None, dir=None, enclosure=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.underline = _cast(int, underline)
        self.underline_nsprefix_ = None
        self.overline = _cast(int, overline)
        self.overline_nsprefix_ = None
        self.line_through = _cast(int, line_through)
        self.line_through_nsprefix_ = None
        self.rotation = _cast(float, rotation)
        self.rotation_nsprefix_ = None
        self.letter_spacing = _cast(None, letter_spacing)
        self.letter_spacing_nsprefix_ = None
        self.line_height = _cast(None, line_height)
        self.line_height_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        self.enclosure = _cast(None, enclosure)
        self.enclosure_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, formatted_symbol_id)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if formatted_symbol_id.subclass:
            return formatted_symbol_id.subclass(*args_, **kwargs_)
        else:
            return formatted_symbol_id(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def get_overline(self):
        return self.overline
    def set_overline(self, overline):
        self.overline = overline
    def get_line_through(self):
        return self.line_through
    def set_line_through(self, line_through):
        self.line_through = line_through
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    def get_letter_spacing(self):
        return self.letter_spacing
    def set_letter_spacing(self, letter_spacing):
        self.letter_spacing = letter_spacing
    def get_line_height(self):
        return self.line_height
    def set_line_height(self, line_height):
        self.line_height = line_height
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def get_enclosure(self):
        return self.enclosure
    def set_enclosure(self, enclosure):
        self.enclosure = enclosure
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_smufl_glyph_name(self, value):
        result = True
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_of_lines(self, value):
        # Validate type number-of-lines, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
            if value > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
    def validate_rotation_degrees(self, value):
        # Validate type rotation-degrees, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
    def validate_number_or_normal(self, value):
        # Validate type number-or-normal, a restriction on xs:token.
        pass
    def validate_text_direction(self, value):
        # Validate type text-direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ltr', 'rtl', 'lro', 'rlo']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on text-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_enclosure_shape(self, value):
        # Validate type enclosure-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rectangle', 'square', 'oval', 'circle', 'bracket', 'inverted-bracket', 'triangle', 'diamond', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on enclosure-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formatted-symbol-id', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('formatted-symbol-id')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'formatted-symbol-id':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='formatted-symbol-id')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='formatted-symbol-id', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='formatted-symbol-id'):
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.underline is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            outfile.write(' underline="%s"' % self.gds_format_integer(self.underline, input_name='underline'))
        if self.overline is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            outfile.write(' overline="%s"' % self.gds_format_integer(self.overline, input_name='overline'))
        if self.line_through is not None and 'line_through' not in already_processed:
            already_processed.add('line_through')
            outfile.write(' line-through="%s"' % self.gds_format_integer(self.line_through, input_name='line-through'))
        if self.rotation is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            outfile.write(' rotation="%s"' % self.gds_format_decimal(self.rotation, input_name='rotation'))
        if self.letter_spacing is not None and 'letter_spacing' not in already_processed:
            already_processed.add('letter_spacing')
            outfile.write(' letter-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.letter_spacing), input_name='letter-spacing')), ))
        if self.line_height is not None and 'line_height' not in already_processed:
            already_processed.add('line_height')
            outfile.write(' line-height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_height), input_name='line-height')), ))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
        if self.enclosure is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            outfile.write(' enclosure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.enclosure), input_name='enclosure')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formatted-symbol-id', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('underline', node)
        if value is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            self.underline = self.gds_parse_integer(value, node, 'underline')
            if self.underline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.underline)    # validate type number-of-lines
        value = find_attr_value_('overline', node)
        if value is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            self.overline = self.gds_parse_integer(value, node, 'overline')
            if self.overline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.overline)    # validate type number-of-lines
        value = find_attr_value_('line-through', node)
        if value is not None and 'line-through' not in already_processed:
            already_processed.add('line-through')
            self.line_through = self.gds_parse_integer(value, node, 'line-through')
            if self.line_through < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.line_through)    # validate type number-of-lines
        value = find_attr_value_('rotation', node)
        if value is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            value = self.gds_parse_decimal(value, node, 'rotation')
            self.rotation = value
            self.validate_rotation_degrees(self.rotation)    # validate type rotation-degrees
        value = find_attr_value_('letter-spacing', node)
        if value is not None and 'letter-spacing' not in already_processed:
            already_processed.add('letter-spacing')
            self.letter_spacing = value
            self.letter_spacing = ' '.join(self.letter_spacing.split())
            self.validate_number_or_normal(self.letter_spacing)    # validate type number-or-normal
        value = find_attr_value_('line-height', node)
        if value is not None and 'line-height' not in already_processed:
            already_processed.add('line-height')
            self.line_height = value
            self.line_height = ' '.join(self.line_height.split())
            self.validate_number_or_normal(self.line_height)    # validate type number-or-normal
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.dir = ' '.join(self.dir.split())
            self.validate_text_direction(self.dir)    # validate type text-direction
        value = find_attr_value_('enclosure', node)
        if value is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            self.enclosure = value
            self.enclosure = ' '.join(self.enclosure.split())
            self.validate_enclosure_shape(self.enclosure)    # validate type enclosure-shape
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class formatted_symbol_id


class formatted_text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, justify=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, underline=None, overline=None, line_through=None, rotation=None, letter_spacing=None, line_height=None, lang=None, space=None, dir=None, enclosure=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.underline = _cast(int, underline)
        self.underline_nsprefix_ = None
        self.overline = _cast(int, overline)
        self.overline_nsprefix_ = None
        self.line_through = _cast(int, line_through)
        self.line_through_nsprefix_ = None
        self.rotation = _cast(float, rotation)
        self.rotation_nsprefix_ = None
        self.letter_spacing = _cast(None, letter_spacing)
        self.letter_spacing_nsprefix_ = None
        self.line_height = _cast(None, line_height)
        self.line_height_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.space = _cast(None, space)
        self.space_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        self.enclosure = _cast(None, enclosure)
        self.enclosure_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, formatted_text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if formatted_text.subclass:
            return formatted_text.subclass(*args_, **kwargs_)
        else:
            return formatted_text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def get_overline(self):
        return self.overline
    def set_overline(self, overline):
        self.overline = overline
    def get_line_through(self):
        return self.line_through
    def set_line_through(self, line_through):
        self.line_through = line_through
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    def get_letter_spacing(self):
        return self.letter_spacing
    def set_letter_spacing(self, letter_spacing):
        self.letter_spacing = letter_spacing
    def get_line_height(self):
        return self.line_height
    def set_line_height(self, line_height):
        self.line_height = line_height
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_space(self):
        return self.space
    def set_space(self, space):
        self.space = space
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def get_enclosure(self):
        return self.enclosure
    def set_enclosure(self, enclosure):
        self.enclosure = enclosure
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_of_lines(self, value):
        # Validate type number-of-lines, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
            if value > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
    def validate_rotation_degrees(self, value):
        # Validate type rotation-degrees, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
    def validate_number_or_normal(self, value):
        # Validate type number-or-normal, a restriction on xs:token.
        pass
    def validate_text_direction(self, value):
        # Validate type text-direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ltr', 'rtl', 'lro', 'rlo']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on text-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_enclosure_shape(self, value):
        # Validate type enclosure-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rectangle', 'square', 'oval', 'circle', 'bracket', 'inverted-bracket', 'triangle', 'diamond', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on enclosure-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formatted-text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('formatted-text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'formatted-text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='formatted-text')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='formatted-text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='formatted-text'):
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.underline is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            outfile.write(' underline="%s"' % self.gds_format_integer(self.underline, input_name='underline'))
        if self.overline is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            outfile.write(' overline="%s"' % self.gds_format_integer(self.overline, input_name='overline'))
        if self.line_through is not None and 'line_through' not in already_processed:
            already_processed.add('line_through')
            outfile.write(' line-through="%s"' % self.gds_format_integer(self.line_through, input_name='line-through'))
        if self.rotation is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            outfile.write(' rotation="%s"' % self.gds_format_decimal(self.rotation, input_name='rotation'))
        if self.letter_spacing is not None and 'letter_spacing' not in already_processed:
            already_processed.add('letter_spacing')
            outfile.write(' letter-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.letter_spacing), input_name='letter-spacing')), ))
        if self.line_height is not None and 'line_height' not in already_processed:
            already_processed.add('line_height')
            outfile.write(' line-height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_height), input_name='line-height')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' xml:space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
        if self.enclosure is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            outfile.write(' enclosure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.enclosure), input_name='enclosure')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formatted-text', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('underline', node)
        if value is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            self.underline = self.gds_parse_integer(value, node, 'underline')
            if self.underline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.underline)    # validate type number-of-lines
        value = find_attr_value_('overline', node)
        if value is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            self.overline = self.gds_parse_integer(value, node, 'overline')
            if self.overline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.overline)    # validate type number-of-lines
        value = find_attr_value_('line-through', node)
        if value is not None and 'line-through' not in already_processed:
            already_processed.add('line-through')
            self.line_through = self.gds_parse_integer(value, node, 'line-through')
            if self.line_through < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.line_through)    # validate type number-of-lines
        value = find_attr_value_('rotation', node)
        if value is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            value = self.gds_parse_decimal(value, node, 'rotation')
            self.rotation = value
            self.validate_rotation_degrees(self.rotation)    # validate type rotation-degrees
        value = find_attr_value_('letter-spacing', node)
        if value is not None and 'letter-spacing' not in already_processed:
            already_processed.add('letter-spacing')
            self.letter_spacing = value
            self.letter_spacing = ' '.join(self.letter_spacing.split())
            self.validate_number_or_normal(self.letter_spacing)    # validate type number-or-normal
        value = find_attr_value_('line-height', node)
        if value is not None and 'line-height' not in already_processed:
            already_processed.add('line-height')
            self.line_height = value
            self.line_height = ' '.join(self.line_height.split())
            self.validate_number_or_normal(self.line_height)    # validate type number-or-normal
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.dir = ' '.join(self.dir.split())
            self.validate_text_direction(self.dir)    # validate type text-direction
        value = find_attr_value_('enclosure', node)
        if value is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            self.enclosure = value
            self.enclosure = ' '.join(self.enclosure.split())
            self.validate_enclosure_shape(self.enclosure)    # validate type enclosure-shape
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class formatted_text


class formatted_text_id(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, justify=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, underline=None, overline=None, line_through=None, rotation=None, letter_spacing=None, line_height=None, lang=None, space=None, dir=None, enclosure=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.underline = _cast(int, underline)
        self.underline_nsprefix_ = None
        self.overline = _cast(int, overline)
        self.overline_nsprefix_ = None
        self.line_through = _cast(int, line_through)
        self.line_through_nsprefix_ = None
        self.rotation = _cast(float, rotation)
        self.rotation_nsprefix_ = None
        self.letter_spacing = _cast(None, letter_spacing)
        self.letter_spacing_nsprefix_ = None
        self.line_height = _cast(None, line_height)
        self.line_height_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.space = _cast(None, space)
        self.space_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        self.enclosure = _cast(None, enclosure)
        self.enclosure_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, formatted_text_id)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if formatted_text_id.subclass:
            return formatted_text_id.subclass(*args_, **kwargs_)
        else:
            return formatted_text_id(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def get_overline(self):
        return self.overline
    def set_overline(self, overline):
        self.overline = overline
    def get_line_through(self):
        return self.line_through
    def set_line_through(self, line_through):
        self.line_through = line_through
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    def get_letter_spacing(self):
        return self.letter_spacing
    def set_letter_spacing(self, letter_spacing):
        self.letter_spacing = letter_spacing
    def get_line_height(self):
        return self.line_height
    def set_line_height(self, line_height):
        self.line_height = line_height
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_space(self):
        return self.space
    def set_space(self, space):
        self.space = space
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def get_enclosure(self):
        return self.enclosure
    def set_enclosure(self, enclosure):
        self.enclosure = enclosure
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_of_lines(self, value):
        # Validate type number-of-lines, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
            if value > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
    def validate_rotation_degrees(self, value):
        # Validate type rotation-degrees, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
    def validate_number_or_normal(self, value):
        # Validate type number-or-normal, a restriction on xs:token.
        pass
    def validate_text_direction(self, value):
        # Validate type text-direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ltr', 'rtl', 'lro', 'rlo']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on text-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_enclosure_shape(self, value):
        # Validate type enclosure-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rectangle', 'square', 'oval', 'circle', 'bracket', 'inverted-bracket', 'triangle', 'diamond', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on enclosure-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formatted-text-id', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('formatted-text-id')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'formatted-text-id':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='formatted-text-id')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='formatted-text-id', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='formatted-text-id'):
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.underline is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            outfile.write(' underline="%s"' % self.gds_format_integer(self.underline, input_name='underline'))
        if self.overline is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            outfile.write(' overline="%s"' % self.gds_format_integer(self.overline, input_name='overline'))
        if self.line_through is not None and 'line_through' not in already_processed:
            already_processed.add('line_through')
            outfile.write(' line-through="%s"' % self.gds_format_integer(self.line_through, input_name='line-through'))
        if self.rotation is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            outfile.write(' rotation="%s"' % self.gds_format_decimal(self.rotation, input_name='rotation'))
        if self.letter_spacing is not None and 'letter_spacing' not in already_processed:
            already_processed.add('letter_spacing')
            outfile.write(' letter-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.letter_spacing), input_name='letter-spacing')), ))
        if self.line_height is not None and 'line_height' not in already_processed:
            already_processed.add('line_height')
            outfile.write(' line-height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_height), input_name='line-height')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' xml:space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
        if self.enclosure is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            outfile.write(' enclosure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.enclosure), input_name='enclosure')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formatted-text-id', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('underline', node)
        if value is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            self.underline = self.gds_parse_integer(value, node, 'underline')
            if self.underline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.underline)    # validate type number-of-lines
        value = find_attr_value_('overline', node)
        if value is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            self.overline = self.gds_parse_integer(value, node, 'overline')
            if self.overline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.overline)    # validate type number-of-lines
        value = find_attr_value_('line-through', node)
        if value is not None and 'line-through' not in already_processed:
            already_processed.add('line-through')
            self.line_through = self.gds_parse_integer(value, node, 'line-through')
            if self.line_through < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.line_through)    # validate type number-of-lines
        value = find_attr_value_('rotation', node)
        if value is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            value = self.gds_parse_decimal(value, node, 'rotation')
            self.rotation = value
            self.validate_rotation_degrees(self.rotation)    # validate type rotation-degrees
        value = find_attr_value_('letter-spacing', node)
        if value is not None and 'letter-spacing' not in already_processed:
            already_processed.add('letter-spacing')
            self.letter_spacing = value
            self.letter_spacing = ' '.join(self.letter_spacing.split())
            self.validate_number_or_normal(self.letter_spacing)    # validate type number-or-normal
        value = find_attr_value_('line-height', node)
        if value is not None and 'line-height' not in already_processed:
            already_processed.add('line-height')
            self.line_height = value
            self.line_height = ' '.join(self.line_height.split())
            self.validate_number_or_normal(self.line_height)    # validate type number-or-normal
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.dir = ' '.join(self.dir.split())
            self.validate_text_direction(self.dir)    # validate type text-direction
        value = find_attr_value_('enclosure', node)
        if value is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            self.enclosure = value
            self.enclosure = ' '.join(self.enclosure.split())
            self.validate_enclosure_shape(self.enclosure)    # validate type enclosure-shape
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class formatted_text_id


class fret(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fret)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fret.subclass:
            return fret.subclass(*args_, **kwargs_)
        else:
            return fret(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fret', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fret')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fret':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fret')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fret', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fret'):
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fret', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class fret


class level(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, reference=None, type_=None, parentheses=None, bracket=None, size=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.parentheses = _cast(None, parentheses)
        self.parentheses_nsprefix_ = None
        self.bracket = _cast(None, bracket)
        self.bracket_nsprefix_ = None
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, level)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if level.subclass:
            return level.subclass(*args_, **kwargs_)
        else:
            return level(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_parentheses(self):
        return self.parentheses
    def set_parentheses(self, parentheses):
        self.parentheses = parentheses
    def get_bracket(self):
        return self.bracket
    def set_bracket(self, bracket):
        self.bracket = bracket
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_start_stop_single(self, value):
        # Validate type start-stop-single, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'single']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-single' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_symbol_size(self, value):
        # Validate type symbol-size, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['full', 'cue', 'grace-cue', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on symbol-size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='level', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('level')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'level':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='level')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='level', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='level'):
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.parentheses is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            outfile.write(' parentheses=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentheses), input_name='parentheses')), ))
        if self.bracket is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            outfile.write(' bracket=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bracket), input_name='bracket')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='level', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
            self.reference = ' '.join(self.reference.split())
            self.validate_yes_no(self.reference)    # validate type yes-no
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_single(self.type_)    # validate type start-stop-single
        value = find_attr_value_('parentheses', node)
        if value is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            self.parentheses = value
            self.parentheses = ' '.join(self.parentheses.split())
            self.validate_yes_no(self.parentheses)    # validate type yes-no
        value = find_attr_value_('bracket', node)
        if value is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            self.bracket = value
            self.bracket = ' '.join(self.bracket.split())
            self.validate_yes_no(self.bracket)    # validate type yes-no
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.size = ' '.join(self.size.split())
            self.validate_symbol_size(self.size)    # validate type symbol-size
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class level


class midi_device(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, port=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.port = _cast(int, port)
        self.port_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, midi_device)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if midi_device.subclass:
            return midi_device.subclass(*args_, **kwargs_)
        else:
            return midi_device(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_midi_16(self, value):
        # Validate type midi-16, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on midi-16' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on midi-16' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='midi-device', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('midi-device')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'midi-device':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='midi-device')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='midi-device', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='midi-device'):
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='midi-device', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            self.port = self.gds_parse_integer(value, node, 'port')
            if self.port <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_midi_16(self.port)    # validate type midi-16
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class midi_device


class midi_instrument(GeneratedsSuper):
    """midi-channel -- The midi-channel element specifies a MIDI 1.0 channel numbers ranging from 1 to 16.
    midi-name -- The midi-name element corresponds to a ProgramName meta-event within a Standard MIDI File.
    midi-bank -- The midi-bank element specifies a MIDI 1.0 bank number ranging from 1 to 16,384.
    midi-program -- The midi-program element specifies a MIDI 1.0 program number ranging from 1 to 128.
    midi-unpitched -- For unpitched instruments, the midi-unpitched element specifies a MIDI 1.0 note number ranging from 1 to 128. It is usually used with MIDI banks for percussion. Note that MIDI 1.0 note numbers are generally specified from 0 to 127 rather than the 1 to 128 numbering used in this element.
    volume -- The volume element value is a percentage of the maximum ranging from 0 to 100, with decimal values allowed. This corresponds to a scaling value for the MIDI 1.0 channel volume controller.
    pan -- The pan and elevation elements allow placing of sound in a 3-D space relative to the listener. Both are expressed in degrees ranging from -180 to 180. For pan, 0 is straight ahead, -90 is hard left, 90 is hard right, and -180 and 180 are directly behind the listener.
    elevation -- The elevation and pan elements allow placing of sound in a 3-D space relative to the listener. Both are expressed in degrees ranging from -180 to 180. For elevation, 0 is level with the listener, 90 is directly above, and -90 is directly below.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, midi_channel=None, midi_name=None, midi_bank=None, midi_program=None, midi_unpitched=None, volume=None, pan=None, elevation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.midi_channel = midi_channel
        self.validate_midi_16(self.midi_channel)
        self.midi_channel_nsprefix_ = None
        self.midi_name = midi_name
        self.midi_name_nsprefix_ = None
        self.midi_bank = midi_bank
        self.validate_midi_16384(self.midi_bank)
        self.midi_bank_nsprefix_ = None
        self.midi_program = midi_program
        self.validate_midi_128(self.midi_program)
        self.midi_program_nsprefix_ = None
        self.midi_unpitched = midi_unpitched
        self.validate_midi_128(self.midi_unpitched)
        self.midi_unpitched_nsprefix_ = None
        self.volume = volume
        self.validate_percent(self.volume)
        self.volume_nsprefix_ = None
        self.pan = pan
        self.validate_rotation_degrees(self.pan)
        self.pan_nsprefix_ = None
        self.elevation = elevation
        self.validate_rotation_degrees(self.elevation)
        self.elevation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, midi_instrument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if midi_instrument.subclass:
            return midi_instrument.subclass(*args_, **kwargs_)
        else:
            return midi_instrument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_midi_channel(self):
        return self.midi_channel
    def set_midi_channel(self, midi_channel):
        self.midi_channel = midi_channel
    def get_midi_name(self):
        return self.midi_name
    def set_midi_name(self, midi_name):
        self.midi_name = midi_name
    def get_midi_bank(self):
        return self.midi_bank
    def set_midi_bank(self, midi_bank):
        self.midi_bank = midi_bank
    def get_midi_program(self):
        return self.midi_program
    def set_midi_program(self, midi_program):
        self.midi_program = midi_program
    def get_midi_unpitched(self):
        return self.midi_unpitched
    def set_midi_unpitched(self, midi_unpitched):
        self.midi_unpitched = midi_unpitched
    def get_volume(self):
        return self.volume
    def set_volume(self, volume):
        self.volume = volume
    def get_pan(self):
        return self.pan
    def set_pan(self, pan):
        self.pan = pan
    def get_elevation(self):
        return self.elevation
    def set_elevation(self, elevation):
        self.elevation = elevation
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_midi_16(self, value):
        result = True
        # Validate type midi-16, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on midi-16' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on midi-16' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_midi_16384(self, value):
        result = True
        # Validate type midi-16384, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on midi-16384' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16384:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on midi-16384' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_midi_128(self, value):
        result = True
        # Validate type midi-128, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on midi-128' % {"value": value, "lineno": lineno} )
                result = False
            if value > 128:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on midi-128' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_percent(self, value):
        result = True
        # Validate type percent, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_rotation_degrees(self, value):
        result = True
        # Validate type rotation-degrees, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.midi_channel is not None or
            self.midi_name is not None or
            self.midi_bank is not None or
            self.midi_program is not None or
            self.midi_unpitched is not None or
            self.volume is not None or
            self.pan is not None or
            self.elevation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='midi-instrument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('midi-instrument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'midi-instrument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='midi-instrument')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='midi-instrument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='midi-instrument'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='midi-instrument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.midi_channel is not None:
            namespaceprefix_ = self.midi_channel_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_channel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smidi-channel>%s</%smidi-channel>%s' % (namespaceprefix_ , self.gds_format_integer(self.midi_channel, input_name='midi-channel'), namespaceprefix_ , eol_))
        if self.midi_name is not None:
            namespaceprefix_ = self.midi_name_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smidi-name>%s</%smidi-name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.midi_name), input_name='midi-name')), namespaceprefix_ , eol_))
        if self.midi_bank is not None:
            namespaceprefix_ = self.midi_bank_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_bank_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smidi-bank>%s</%smidi-bank>%s' % (namespaceprefix_ , self.gds_format_integer(self.midi_bank, input_name='midi-bank'), namespaceprefix_ , eol_))
        if self.midi_program is not None:
            namespaceprefix_ = self.midi_program_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_program_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smidi-program>%s</%smidi-program>%s' % (namespaceprefix_ , self.gds_format_integer(self.midi_program, input_name='midi-program'), namespaceprefix_ , eol_))
        if self.midi_unpitched is not None:
            namespaceprefix_ = self.midi_unpitched_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_unpitched_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smidi-unpitched>%s</%smidi-unpitched>%s' % (namespaceprefix_ , self.gds_format_integer(self.midi_unpitched, input_name='midi-unpitched'), namespaceprefix_ , eol_))
        if self.volume is not None:
            namespaceprefix_ = self.volume_nsprefix_ + ':' if (UseCapturedNS_ and self.volume_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume>%s</%svolume>%s' % (namespaceprefix_ , self.gds_format_decimal(self.volume, input_name='volume'), namespaceprefix_ , eol_))
        if self.pan is not None:
            namespaceprefix_ = self.pan_nsprefix_ + ':' if (UseCapturedNS_ and self.pan_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%span>%s</%span>%s' % (namespaceprefix_ , self.gds_format_decimal(self.pan, input_name='pan'), namespaceprefix_ , eol_))
        if self.elevation is not None:
            namespaceprefix_ = self.elevation_nsprefix_ + ':' if (UseCapturedNS_ and self.elevation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%selevation>%s</%selevation>%s' % (namespaceprefix_ , self.gds_format_decimal(self.elevation, input_name='elevation'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'midi-channel' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'midi_channel')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'midi_channel')
            self.midi_channel = ival_
            self.midi_channel_nsprefix_ = child_.prefix
            # validate type midi-16
            self.validate_midi_16(self.midi_channel)
        elif nodeName_ == 'midi-name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'midi_name')
            value_ = self.gds_validate_string(value_, node, 'midi_name')
            self.midi_name = value_
            self.midi_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'midi-bank' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'midi_bank')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'midi_bank')
            self.midi_bank = ival_
            self.midi_bank_nsprefix_ = child_.prefix
            # validate type midi-16384
            self.validate_midi_16384(self.midi_bank)
        elif nodeName_ == 'midi-program' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'midi_program')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'midi_program')
            self.midi_program = ival_
            self.midi_program_nsprefix_ = child_.prefix
            # validate type midi-128
            self.validate_midi_128(self.midi_program)
        elif nodeName_ == 'midi-unpitched' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'midi_unpitched')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'midi_unpitched')
            self.midi_unpitched = ival_
            self.midi_unpitched_nsprefix_ = child_.prefix
            # validate type midi-128
            self.validate_midi_128(self.midi_unpitched)
        elif nodeName_ == 'volume' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'volume')
            fval_ = self.gds_validate_decimal(fval_, node, 'volume')
            self.volume = fval_
            self.volume_nsprefix_ = child_.prefix
            # validate type percent
            self.validate_percent(self.volume)
        elif nodeName_ == 'pan' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'pan')
            fval_ = self.gds_validate_decimal(fval_, node, 'pan')
            self.pan = fval_
            self.pan_nsprefix_ = child_.prefix
            # validate type rotation-degrees
            self.validate_rotation_degrees(self.pan)
        elif nodeName_ == 'elevation' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'elevation')
            fval_ = self.gds_validate_decimal(fval_, node, 'elevation')
            self.elevation = fval_
            self.elevation_nsprefix_ = child_.prefix
            # validate type rotation-degrees
            self.validate_rotation_degrees(self.elevation)
# end class midi_instrument


class name_display(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, print_object=None, display_text=None, accidental_text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        if display_text is None:
            self.display_text = []
        else:
            self.display_text = display_text
        self.display_text_nsprefix_ = None
        if accidental_text is None:
            self.accidental_text = []
        else:
            self.accidental_text = accidental_text
        self.accidental_text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, name_display)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if name_display.subclass:
            return name_display.subclass(*args_, **kwargs_)
        else:
            return name_display(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_display_text(self):
        return self.display_text
    def set_display_text(self, display_text):
        self.display_text = display_text
    def add_display_text(self, value):
        self.display_text.append(value)
    def insert_display_text_at(self, index, value):
        self.display_text.insert(index, value)
    def replace_display_text_at(self, index, value):
        self.display_text[index] = value
    def get_accidental_text(self):
        return self.accidental_text
    def set_accidental_text(self, accidental_text):
        self.accidental_text = accidental_text
    def add_accidental_text(self, value):
        self.accidental_text.append(value)
    def insert_accidental_text_at(self, index, value):
        self.accidental_text.insert(index, value)
    def replace_accidental_text_at(self, index, value):
        self.accidental_text[index] = value
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.display_text or
            self.accidental_text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='name-display', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('name-display')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'name-display':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='name-display')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='name-display', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='name-display'):
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='name-display', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for display_text_ in self.display_text:
            namespaceprefix_ = self.display_text_nsprefix_ + ':' if (UseCapturedNS_ and self.display_text_nsprefix_) else ''
            display_text_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='display-text', pretty_print=pretty_print)
        for accidental_text_ in self.accidental_text:
            namespaceprefix_ = self.accidental_text_nsprefix_ + ':' if (UseCapturedNS_ and self.accidental_text_nsprefix_) else ''
            accidental_text_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accidental-text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'display-text':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.display_text.append(obj_)
            obj_.original_tagname_ = 'display-text'
        elif nodeName_ == 'accidental-text':
            obj_ = accidental_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accidental_text.append(obj_)
            obj_.original_tagname_ = 'accidental-text'
# end class name_display


class other_play(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, other_play)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if other_play.subclass:
            return other_play.subclass(*args_, **kwargs_)
        else:
            return other_play(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-play', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('other-play')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'other-play':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='other-play')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='other-play', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='other-play'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-play', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class other_play


class play(GeneratedsSuper):
    """ipa -- The ipa element represents International Phonetic Alphabet (IPA) sounds for vocal music. String content is limited to IPA 2015 symbols represented in Unicode 13.0.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, ipa=None, mute=None, semi_pitched=None, other_play=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if ipa is None:
            self.ipa = []
        else:
            self.ipa = ipa
        self.ipa_nsprefix_ = None
        if mute is None:
            self.mute = []
        else:
            self.mute = mute
        self.mute_nsprefix_ = None
        if semi_pitched is None:
            self.semi_pitched = []
        else:
            self.semi_pitched = semi_pitched
        self.semi_pitched_nsprefix_ = None
        if other_play is None:
            self.other_play = []
        else:
            self.other_play = other_play
        self.other_play_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, play)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if play.subclass:
            return play.subclass(*args_, **kwargs_)
        else:
            return play(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ipa(self):
        return self.ipa
    def set_ipa(self, ipa):
        self.ipa = ipa
    def add_ipa(self, value):
        self.ipa.append(value)
    def insert_ipa_at(self, index, value):
        self.ipa.insert(index, value)
    def replace_ipa_at(self, index, value):
        self.ipa[index] = value
    def get_mute(self):
        return self.mute
    def set_mute(self, mute):
        self.mute = mute
    def add_mute(self, value):
        self.mute.append(value)
    def insert_mute_at(self, index, value):
        self.mute.insert(index, value)
    def replace_mute_at(self, index, value):
        self.mute[index] = value
    def get_semi_pitched(self):
        return self.semi_pitched
    def set_semi_pitched(self, semi_pitched):
        self.semi_pitched = semi_pitched
    def add_semi_pitched(self, value):
        self.semi_pitched.append(value)
    def insert_semi_pitched_at(self, index, value):
        self.semi_pitched.insert(index, value)
    def replace_semi_pitched_at(self, index, value):
        self.semi_pitched[index] = value
    def get_other_play(self):
        return self.other_play
    def set_other_play(self, other_play):
        self.other_play = other_play
    def add_other_play(self, value):
        self.other_play.append(value)
    def insert_other_play_at(self, index, value):
        self.other_play.insert(index, value)
    def replace_other_play_at(self, index, value):
        self.other_play[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_mute(self, value):
        result = True
        # Validate type mute, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['on', 'off', 'straight', 'cup', 'harmon-no-stem', 'harmon-stem', 'bucket', 'plunger', 'hat', 'solotone', 'practice', 'stop-mute', 'stop-hand', 'echo', 'palm']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on mute' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_semi_pitched(self, value):
        result = True
        # Validate type semi-pitched, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['high', 'medium-high', 'medium', 'medium-low', 'low', 'very-low']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on semi-pitched' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.ipa or
            self.mute or
            self.semi_pitched or
            self.other_play
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='play', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('play')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'play':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='play')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='play', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='play'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='play', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ipa_ in self.ipa:
            namespaceprefix_ = self.ipa_nsprefix_ + ':' if (UseCapturedNS_ and self.ipa_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipa>%s</%sipa>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ipa_), input_name='ipa')), namespaceprefix_ , eol_))
        for mute_ in self.mute:
            namespaceprefix_ = self.mute_nsprefix_ + ':' if (UseCapturedNS_ and self.mute_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smute>%s</%smute>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(mute_), input_name='mute')), namespaceprefix_ , eol_))
        for semi_pitched_ in self.semi_pitched:
            namespaceprefix_ = self.semi_pitched_nsprefix_ + ':' if (UseCapturedNS_ and self.semi_pitched_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssemi-pitched>%s</%ssemi-pitched>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(semi_pitched_), input_name='semi-pitched')), namespaceprefix_ , eol_))
        for other_play_ in self.other_play:
            namespaceprefix_ = self.other_play_nsprefix_ + ':' if (UseCapturedNS_ and self.other_play_nsprefix_) else ''
            other_play_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-play', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ipa':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ipa')
            value_ = self.gds_validate_string(value_, node, 'ipa')
            self.ipa.append(value_)
            self.ipa_nsprefix_ = child_.prefix
        elif nodeName_ == 'mute':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mute')
            value_ = self.gds_validate_string(value_, node, 'mute')
            self.mute.append(value_)
            self.mute_nsprefix_ = child_.prefix
            # validate type mute
            self.validate_mute(self.mute[-1])
        elif nodeName_ == 'semi-pitched':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'semi_pitched')
            value_ = self.gds_validate_string(value_, node, 'semi_pitched')
            self.semi_pitched.append(value_)
            self.semi_pitched_nsprefix_ = child_.prefix
            # validate type semi-pitched
            self.validate_semi_pitched(self.semi_pitched[-1])
        elif nodeName_ == 'other-play':
            obj_ = other_play.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_play.append(obj_)
            obj_.original_tagname_ = 'other-play'
# end class play


class segno(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, segno)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if segno.subclass:
            return segno.subclass(*args_, **kwargs_)
        else:
            return segno(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_smufl_segno_glyph_name(self, value):
        # Validate type smufl-segno-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_segno_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_segno_glyph_name_patterns_, ))
    validate_smufl_segno_glyph_name_patterns_ = [['^(segno\\c*)$']]
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='segno', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('segno')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'segno':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='segno')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='segno', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='segno'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='segno', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_segno_glyph_name(self.smufl)    # validate type smufl-segno-glyph-name
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class segno


class string(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, string)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if string.subclass:
            return string.subclass(*args_, **kwargs_)
        else:
            return string(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_string_number(self, value):
        result = True
        # Validate type string-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='string', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('string')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'string':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='string')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='string', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='string'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='string', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class string


class typed_text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typed_text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typed_text.subclass:
            return typed_text.subclass(*args_, **kwargs_)
        else:
            return typed_text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typed-text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typed-text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typed-text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typed-text')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typed-text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typed-text'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typed-text', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class typed_text


class wavy_line(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, smufl=None, default_x=None, default_y=None, relative_x=None, relative_y=None, placement=None, color=None, start_note=None, trill_step=None, two_note_turn=None, accelerate=None, beats=None, second_beat=None, last_beat=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.start_note = _cast(None, start_note)
        self.start_note_nsprefix_ = None
        self.trill_step = _cast(None, trill_step)
        self.trill_step_nsprefix_ = None
        self.two_note_turn = _cast(None, two_note_turn)
        self.two_note_turn_nsprefix_ = None
        self.accelerate = _cast(None, accelerate)
        self.accelerate_nsprefix_ = None
        self.beats = _cast(float, beats)
        self.beats_nsprefix_ = None
        self.second_beat = _cast(float, second_beat)
        self.second_beat_nsprefix_ = None
        self.last_beat = _cast(float, last_beat)
        self.last_beat_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wavy_line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wavy_line.subclass:
            return wavy_line.subclass(*args_, **kwargs_)
        else:
            return wavy_line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_start_note(self):
        return self.start_note
    def set_start_note(self, start_note):
        self.start_note = start_note
    def get_trill_step(self):
        return self.trill_step
    def set_trill_step(self, trill_step):
        self.trill_step = trill_step
    def get_two_note_turn(self):
        return self.two_note_turn
    def set_two_note_turn(self, two_note_turn):
        self.two_note_turn = two_note_turn
    def get_accelerate(self):
        return self.accelerate
    def set_accelerate(self, accelerate):
        self.accelerate = accelerate
    def get_beats(self):
        return self.beats
    def set_beats(self, beats):
        self.beats = beats
    def get_second_beat(self):
        return self.second_beat
    def set_second_beat(self, second_beat):
        self.second_beat = second_beat
    def get_last_beat(self):
        return self.last_beat
    def set_last_beat(self, last_beat):
        self.last_beat = last_beat
    def validate_start_stop_continue(self, value):
        # Validate type start-stop-continue, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'continue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-continue' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_smufl_wavy_line_glyph_name(self, value):
        # Validate type smufl-wavy-line-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_wavy_line_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_wavy_line_glyph_name_patterns_, ))
    validate_smufl_wavy_line_glyph_name_patterns_ = [['^((wiggle\\c+)|(guitar\\c*VibratoStroke))$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_start_note(self, value):
        # Validate type start-note, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['upper', 'main', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-note' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_trill_step(self, value):
        # Validate type trill-step, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['whole', 'half', 'unison']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on trill-step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_two_note_turn(self, value):
        # Validate type two-note-turn, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['whole', 'half', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on two-note-turn' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_trill_beats(self, value):
        # Validate type trill-beats, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on trill-beats' % {"value": value, "lineno": lineno} )
                result = False
    def validate_percent(self, value):
        # Validate type percent, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='wavy-line', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wavy-line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'wavy-line':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='wavy-line')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='wavy-line', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='wavy-line'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.start_note is not None and 'start_note' not in already_processed:
            already_processed.add('start_note')
            outfile.write(' start-note=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.start_note), input_name='start-note')), ))
        if self.trill_step is not None and 'trill_step' not in already_processed:
            already_processed.add('trill_step')
            outfile.write(' trill-step=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.trill_step), input_name='trill-step')), ))
        if self.two_note_turn is not None and 'two_note_turn' not in already_processed:
            already_processed.add('two_note_turn')
            outfile.write(' two-note-turn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.two_note_turn), input_name='two-note-turn')), ))
        if self.accelerate is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            outfile.write(' accelerate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accelerate), input_name='accelerate')), ))
        if self.beats is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            outfile.write(' beats="%s"' % self.gds_format_decimal(self.beats, input_name='beats'))
        if self.second_beat is not None and 'second_beat' not in already_processed:
            already_processed.add('second_beat')
            outfile.write(' second-beat="%s"' % self.gds_format_decimal(self.second_beat, input_name='second-beat'))
        if self.last_beat is not None and 'last_beat' not in already_processed:
            already_processed.add('last_beat')
            outfile.write(' last-beat="%s"' % self.gds_format_decimal(self.last_beat, input_name='last-beat'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='wavy-line', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_continue(self.type_)    # validate type start-stop-continue
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_wavy_line_glyph_name(self.smufl)    # validate type smufl-wavy-line-glyph-name
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('start-note', node)
        if value is not None and 'start-note' not in already_processed:
            already_processed.add('start-note')
            self.start_note = value
            self.start_note = ' '.join(self.start_note.split())
            self.validate_start_note(self.start_note)    # validate type start-note
        value = find_attr_value_('trill-step', node)
        if value is not None and 'trill-step' not in already_processed:
            already_processed.add('trill-step')
            self.trill_step = value
            self.trill_step = ' '.join(self.trill_step.split())
            self.validate_trill_step(self.trill_step)    # validate type trill-step
        value = find_attr_value_('two-note-turn', node)
        if value is not None and 'two-note-turn' not in already_processed:
            already_processed.add('two-note-turn')
            self.two_note_turn = value
            self.two_note_turn = ' '.join(self.two_note_turn.split())
            self.validate_two_note_turn(self.two_note_turn)    # validate type two-note-turn
        value = find_attr_value_('accelerate', node)
        if value is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            self.accelerate = value
            self.accelerate = ' '.join(self.accelerate.split())
            self.validate_yes_no(self.accelerate)    # validate type yes-no
        value = find_attr_value_('beats', node)
        if value is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            value = self.gds_parse_decimal(value, node, 'beats')
            self.beats = value
            self.validate_trill_beats(self.beats)    # validate type trill-beats
        value = find_attr_value_('second-beat', node)
        if value is not None and 'second-beat' not in already_processed:
            already_processed.add('second-beat')
            value = self.gds_parse_decimal(value, node, 'second-beat')
            self.second_beat = value
            self.validate_percent(self.second_beat)    # validate type percent
        value = find_attr_value_('last-beat', node)
        if value is not None and 'last-beat' not in already_processed:
            already_processed.add('last-beat')
            value = self.gds_parse_decimal(value, node, 'last-beat')
            self.last_beat = value
            self.validate_percent(self.last_beat)    # validate type percent
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class wavy_line


class attributes(GeneratedsSuper):
    """divisions -- Musical notation duration is commonly represented as fractions. The divisions element indicates how many divisions per quarter note are used to indicate a note's duration. For example, if duration = 1 and divisions = 2, this is an eighth note duration. Duration and divisions are used directly for generating sound output, so they must be chosen to take tuplets into account. Using a divisions element lets us use just one number to represent a duration for each note in the score, while retaining the full power of a fractional representation. If maximum compatibility with Standard MIDI 1.0 files is important, do not have the divisions value exceed 16383.
    key -- The key element represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part.
    time -- Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.
    staves -- The staves element is used if there is more than one staff represented in the given part (e.g., 2 staves for typical piano parts). If absent, a value of 1 is assumed. Staves are ordered from top to bottom in a part in numerical order, with staff 1 above staff 2.
    part-symbol -- The part-symbol element indicates how a symbol for a multi-staff part is indicated in the score.
    instruments -- The instruments element is only used if more than one instrument is represented in the part (e.g., oboe I and II where they play together most of the time). If absent, a value of 1 is assumed.
    clef -- Clefs are represented by a combination of sign, line, and clef-octave-change elements.
    staff-details -- The staff-details element is used to indicate different types of staves.
    transpose -- If the part is being encoded for a transposing instrument in written vs. concert pitch, the transposition must be encoded in the transpose element using the transpose type.
    for-part -- The for-part element is used in a concert score to indicate the transposition for a transposed part created from that score. It is only used in score files that contain a concert-score element in the defaults. This allows concert scores with transposed parts to be represented in a single uncompressed MusicXML file.
    directive -- Directives are like directions, but can be grouped together with attributes for convenience. This is typically used for tempo markings at the beginning of a piece of music. This element was deprecated in Version 2.0 in favor of the direction element's directive attribute. Language names come from ISO 639, with optional country subcodes from ISO 3166.
    measure-style -- A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, footnote=None, level=None, divisions=None, key=None, time=None, staves=None, part_symbol=None, instruments=None, clef=None, staff_details=None, transpose=None, for_part=None, directive=None, measure_style=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
        self.divisions = divisions
        self.validate_positive_divisions(self.divisions)
        self.divisions_nsprefix_ = None
        if key is None:
            self.key = []
        else:
            self.key = key
        self.key_nsprefix_ = None
        if time is None:
            self.time = []
        else:
            self.time = time
        self.time_nsprefix_ = None
        self.staves = staves
        self.staves_nsprefix_ = None
        self.part_symbol = part_symbol
        self.part_symbol_nsprefix_ = None
        self.instruments = instruments
        self.instruments_nsprefix_ = None
        if clef is None:
            self.clef = []
        else:
            self.clef = clef
        self.clef_nsprefix_ = None
        if staff_details is None:
            self.staff_details = []
        else:
            self.staff_details = staff_details
        self.staff_details_nsprefix_ = None
        if transpose is None:
            self.transpose = []
        else:
            self.transpose = transpose
        self.transpose_nsprefix_ = None
        if for_part is None:
            self.for_part = []
        else:
            self.for_part = for_part
        self.for_part_nsprefix_ = None
        if directive is None:
            self.directive = []
        else:
            self.directive = directive
        self.directive_nsprefix_ = None
        if measure_style is None:
            self.measure_style = []
        else:
            self.measure_style = measure_style
        self.measure_style_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributes.subclass:
            return attributes.subclass(*args_, **kwargs_)
        else:
            return attributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_divisions(self):
        return self.divisions
    def set_divisions(self, divisions):
        self.divisions = divisions
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    def add_key(self, value):
        self.key.append(value)
    def insert_key_at(self, index, value):
        self.key.insert(index, value)
    def replace_key_at(self, index, value):
        self.key[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def add_time(self, value):
        self.time.append(value)
    def insert_time_at(self, index, value):
        self.time.insert(index, value)
    def replace_time_at(self, index, value):
        self.time[index] = value
    def get_staves(self):
        return self.staves
    def set_staves(self, staves):
        self.staves = staves
    def get_part_symbol(self):
        return self.part_symbol
    def set_part_symbol(self, part_symbol):
        self.part_symbol = part_symbol
    def get_instruments(self):
        return self.instruments
    def set_instruments(self, instruments):
        self.instruments = instruments
    def get_clef(self):
        return self.clef
    def set_clef(self, clef):
        self.clef = clef
    def add_clef(self, value):
        self.clef.append(value)
    def insert_clef_at(self, index, value):
        self.clef.insert(index, value)
    def replace_clef_at(self, index, value):
        self.clef[index] = value
    def get_staff_details(self):
        return self.staff_details
    def set_staff_details(self, staff_details):
        self.staff_details = staff_details
    def add_staff_details(self, value):
        self.staff_details.append(value)
    def insert_staff_details_at(self, index, value):
        self.staff_details.insert(index, value)
    def replace_staff_details_at(self, index, value):
        self.staff_details[index] = value
    def get_transpose(self):
        return self.transpose
    def set_transpose(self, transpose):
        self.transpose = transpose
    def add_transpose(self, value):
        self.transpose.append(value)
    def insert_transpose_at(self, index, value):
        self.transpose.insert(index, value)
    def replace_transpose_at(self, index, value):
        self.transpose[index] = value
    def get_for_part(self):
        return self.for_part
    def set_for_part(self, for_part):
        self.for_part = for_part
    def add_for_part(self, value):
        self.for_part.append(value)
    def insert_for_part_at(self, index, value):
        self.for_part.insert(index, value)
    def replace_for_part_at(self, index, value):
        self.for_part[index] = value
    def get_directive(self):
        return self.directive
    def set_directive(self, directive):
        self.directive = directive
    def add_directive(self, value):
        self.directive.append(value)
    def insert_directive_at(self, index, value):
        self.directive.insert(index, value)
    def replace_directive_at(self, index, value):
        self.directive[index] = value
    def get_measure_style(self):
        return self.measure_style
    def set_measure_style(self, measure_style):
        self.measure_style = measure_style
    def add_measure_style(self, value):
        self.measure_style.append(value)
    def insert_measure_style_at(self, index, value):
        self.measure_style.insert(index, value)
    def replace_measure_style_at(self, index, value):
        self.measure_style[index] = value
    def validate_positive_divisions(self, value):
        result = True
        # Validate type positive-divisions, a restriction on divisions.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on positive-divisions' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.footnote is not None or
            self.level is not None or
            self.divisions is not None or
            self.key or
            self.time or
            self.staves is not None or
            self.part_symbol is not None or
            self.instruments is not None or
            self.clef or
            self.staff_details or
            self.transpose or
            self.for_part or
            self.directive or
            self.measure_style
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='attributes', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributes':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributes')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attributes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributes'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='attributes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
        if self.divisions is not None:
            namespaceprefix_ = self.divisions_nsprefix_ + ':' if (UseCapturedNS_ and self.divisions_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdivisions>%s</%sdivisions>%s' % (namespaceprefix_ , self.gds_format_decimal(self.divisions, input_name='divisions'), namespaceprefix_ , eol_))
        for key_ in self.key:
            namespaceprefix_ = self.key_nsprefix_ + ':' if (UseCapturedNS_ and self.key_nsprefix_) else ''
            key_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key', pretty_print=pretty_print)
        for time_ in self.time:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            time_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.staves is not None:
            namespaceprefix_ = self.staves_nsprefix_ + ':' if (UseCapturedNS_ and self.staves_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaves>%s</%sstaves>%s' % (namespaceprefix_ , self.gds_format_integer(self.staves, input_name='staves'), namespaceprefix_ , eol_))
        if self.part_symbol is not None:
            namespaceprefix_ = self.part_symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.part_symbol_nsprefix_) else ''
            self.part_symbol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-symbol', pretty_print=pretty_print)
        if self.instruments is not None:
            namespaceprefix_ = self.instruments_nsprefix_ + ':' if (UseCapturedNS_ and self.instruments_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstruments>%s</%sinstruments>%s' % (namespaceprefix_ , self.gds_format_integer(self.instruments, input_name='instruments'), namespaceprefix_ , eol_))
        for clef_ in self.clef:
            namespaceprefix_ = self.clef_nsprefix_ + ':' if (UseCapturedNS_ and self.clef_nsprefix_) else ''
            clef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='clef', pretty_print=pretty_print)
        for staff_details_ in self.staff_details:
            namespaceprefix_ = self.staff_details_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_details_nsprefix_) else ''
            staff_details_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='staff-details', pretty_print=pretty_print)
        for transpose_ in self.transpose:
            namespaceprefix_ = self.transpose_nsprefix_ + ':' if (UseCapturedNS_ and self.transpose_nsprefix_) else ''
            transpose_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transpose', pretty_print=pretty_print)
        for for_part_ in self.for_part:
            namespaceprefix_ = self.for_part_nsprefix_ + ':' if (UseCapturedNS_ and self.for_part_nsprefix_) else ''
            for_part_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='for-part', pretty_print=pretty_print)
        for directive_ in self.directive:
            namespaceprefix_ = self.directive_nsprefix_ + ':' if (UseCapturedNS_ and self.directive_nsprefix_) else ''
            directive_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='directive', pretty_print=pretty_print)
        for measure_style_ in self.measure_style:
            namespaceprefix_ = self.measure_style_nsprefix_ + ':' if (UseCapturedNS_ and self.measure_style_nsprefix_) else ''
            measure_style_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='measure-style', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
        elif nodeName_ == 'divisions' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'divisions')
            fval_ = self.gds_validate_decimal(fval_, node, 'divisions')
            self.divisions = fval_
            self.divisions_nsprefix_ = child_.prefix
            # validate type positive-divisions
            self.validate_positive_divisions(self.divisions)
        elif nodeName_ == 'key':
            obj_ = key.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key.append(obj_)
            obj_.original_tagname_ = 'key'
        elif nodeName_ == 'time':
            obj_ = time.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time.append(obj_)
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'staves' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'staves')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'staves')
            self.staves = ival_
            self.staves_nsprefix_ = child_.prefix
        elif nodeName_ == 'part-symbol':
            obj_ = part_symbol.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_symbol = obj_
            obj_.original_tagname_ = 'part-symbol'
        elif nodeName_ == 'instruments' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'instruments')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'instruments')
            self.instruments = ival_
            self.instruments_nsprefix_ = child_.prefix
        elif nodeName_ == 'clef':
            obj_ = clef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.clef.append(obj_)
            obj_.original_tagname_ = 'clef'
        elif nodeName_ == 'staff-details':
            obj_ = staff_details.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.staff_details.append(obj_)
            obj_.original_tagname_ = 'staff-details'
        elif nodeName_ == 'transpose':
            obj_ = transpose.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transpose.append(obj_)
            obj_.original_tagname_ = 'transpose'
        elif nodeName_ == 'for-part':
            obj_ = for_part.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.for_part.append(obj_)
            obj_.original_tagname_ = 'for-part'
        elif nodeName_ == 'directive':
            obj_ = directiveType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.directive.append(obj_)
            obj_.original_tagname_ = 'directive'
        elif nodeName_ == 'measure-style':
            obj_ = measure_style.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.measure_style.append(obj_)
            obj_.original_tagname_ = 'measure-style'
# end class attributes


class beat_repeat(GeneratedsSuper):
    """slash-type -- The slash-type element indicates the graphical note type to use for the display of repetition marks.
    slash-dot -- The slash-dot element is used to specify any augmentation dots in the note type used to display repetition marks.
    except-voice -- The except-voice element is used to specify a combination of slash notation and regular notation. Any note elements that are in voices specified by the except-voice elements are displayed in normal notation, in addition to the slash notation that is always displayed.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, slashes=None, use_dots=None, slash_type=None, slash_dot=None, except_voice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.slashes = _cast(int, slashes)
        self.slashes_nsprefix_ = None
        self.use_dots = _cast(None, use_dots)
        self.use_dots_nsprefix_ = None
        self.slash_type = slash_type
        self.validate_note_type_value(self.slash_type)
        self.slash_type_nsprefix_ = None
        if slash_dot is None:
            self.slash_dot = []
        else:
            self.slash_dot = slash_dot
        self.slash_dot_nsprefix_ = None
        if except_voice is None:
            self.except_voice = []
        else:
            self.except_voice = except_voice
        self.except_voice_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, beat_repeat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if beat_repeat.subclass:
            return beat_repeat.subclass(*args_, **kwargs_)
        else:
            return beat_repeat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_slash_type(self):
        return self.slash_type
    def set_slash_type(self, slash_type):
        self.slash_type = slash_type
    def get_slash_dot(self):
        return self.slash_dot
    def set_slash_dot(self, slash_dot):
        self.slash_dot = slash_dot
    def add_slash_dot(self, value):
        self.slash_dot.append(value)
    def insert_slash_dot_at(self, index, value):
        self.slash_dot.insert(index, value)
    def replace_slash_dot_at(self, index, value):
        self.slash_dot[index] = value
    def get_except_voice(self):
        return self.except_voice
    def set_except_voice(self, except_voice):
        self.except_voice = except_voice
    def add_except_voice(self, value):
        self.except_voice.append(value)
    def insert_except_voice_at(self, index, value):
        self.except_voice.insert(index, value)
    def replace_except_voice_at(self, index, value):
        self.except_voice[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_slashes(self):
        return self.slashes
    def set_slashes(self, slashes):
        self.slashes = slashes
    def get_use_dots(self):
        return self.use_dots
    def set_use_dots(self, use_dots):
        self.use_dots = use_dots
    def validate_note_type_value(self, value):
        result = True
        # Validate type note-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.slash_type is not None or
            self.slash_dot or
            self.except_voice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='beat-repeat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('beat-repeat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'beat-repeat':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='beat-repeat')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='beat-repeat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='beat-repeat'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.slashes is not None and 'slashes' not in already_processed:
            already_processed.add('slashes')
            outfile.write(' slashes="%s"' % self.gds_format_integer(self.slashes, input_name='slashes'))
        if self.use_dots is not None and 'use_dots' not in already_processed:
            already_processed.add('use_dots')
            outfile.write(' use-dots=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.use_dots), input_name='use-dots')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='beat-repeat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.slash_type is not None:
            namespaceprefix_ = self.slash_type_nsprefix_ + ':' if (UseCapturedNS_ and self.slash_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sslash-type>%s</%sslash-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.slash_type), input_name='slash-type')), namespaceprefix_ , eol_))
        for slash_dot_ in self.slash_dot:
            namespaceprefix_ = self.slash_dot_nsprefix_ + ':' if (UseCapturedNS_ and self.slash_dot_nsprefix_) else ''
            slash_dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slash-dot', pretty_print=pretty_print)
        for except_voice_ in self.except_voice:
            namespaceprefix_ = self.except_voice_nsprefix_ + ':' if (UseCapturedNS_ and self.except_voice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexcept-voice>%s</%sexcept-voice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(except_voice_), input_name='except-voice')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('slashes', node)
        if value is not None and 'slashes' not in already_processed:
            already_processed.add('slashes')
            self.slashes = self.gds_parse_integer(value, node, 'slashes')
            if self.slashes <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('use-dots', node)
        if value is not None and 'use-dots' not in already_processed:
            already_processed.add('use-dots')
            self.use_dots = value
            self.use_dots = ' '.join(self.use_dots.split())
            self.validate_yes_no(self.use_dots)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'slash-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'slash_type')
            value_ = self.gds_validate_string(value_, node, 'slash_type')
            self.slash_type = value_
            self.slash_type_nsprefix_ = child_.prefix
            # validate type note-type-value
            self.validate_note_type_value(self.slash_type)
        elif nodeName_ == 'slash-dot':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slash_dot.append(obj_)
            obj_.original_tagname_ = 'slash-dot'
        elif nodeName_ == 'except-voice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'except_voice')
            value_ = self.gds_validate_string(value_, node, 'except_voice')
            self.except_voice.append(value_)
            self.except_voice_nsprefix_ = child_.prefix
# end class beat_repeat


class cancel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, location=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.location = _cast(None, location)
        self.location_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancel.subclass:
            return cancel.subclass(*args_, **kwargs_)
        else:
            return cancel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_fifths(self, value):
        result = True
        # Validate type fifths, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_cancel_location(self, value):
        # Validate type cancel-location, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right', 'before-barline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on cancel-location' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cancel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cancel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cancel')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cancel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cancel'):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.location), input_name='location')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cancel', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
            self.validate_cancel_location(self.location)    # validate type cancel-location
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class cancel


class clef(GeneratedsSuper):
    """sign -- The sign element represents the clef symbol.
    line -- Line numbers are counted from the bottom of the staff. They are only needed with the G, F, and C signs in order to position a pitch correctly on the staff. Standard values are 2 for the G sign (treble clef), 4 for the F sign (bass clef), and 3 for the C sign (alto clef). Line values can be used to specify positions outside the staff, such as a C clef positioned in the middle of a grand staff.
    clef-octave-change -- The clef-octave-change element is used for transposing clefs. A treble clef for tenors would have a value of -1.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, additional=None, size=None, after_barline=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, print_object=None, id=None, sign=None, line=None, clef_octave_change=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.additional = _cast(None, additional)
        self.additional_nsprefix_ = None
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.after_barline = _cast(None, after_barline)
        self.after_barline_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sign = sign
        self.validate_clef_sign(self.sign)
        self.sign_nsprefix_ = None
        self.line = line
        self.validate_staff_line_position(self.line)
        self.line_nsprefix_ = None
        self.clef_octave_change = clef_octave_change
        self.clef_octave_change_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clef.subclass:
            return clef.subclass(*args_, **kwargs_)
        else:
            return clef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sign(self):
        return self.sign
    def set_sign(self, sign):
        self.sign = sign
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_clef_octave_change(self):
        return self.clef_octave_change
    def set_clef_octave_change(self, clef_octave_change):
        self.clef_octave_change = clef_octave_change
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_additional(self):
        return self.additional
    def set_additional(self, additional):
        self.additional = additional
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_after_barline(self):
        return self.after_barline
    def set_after_barline(self, after_barline):
        self.after_barline = after_barline
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_clef_sign(self, value):
        result = True
        # Validate type clef-sign, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['G', 'F', 'C', 'percussion', 'TAB', 'jianpu', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on clef-sign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_staff_line_position(self, value):
        result = True
        # Validate type staff-line-position, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_symbol_size(self, value):
        # Validate type symbol-size, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['full', 'cue', 'grace-cue', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on symbol-size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            self.sign is not None or
            self.line is not None or
            self.clef_octave_change is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='clef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'clef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='clef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='clef'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.additional is not None and 'additional' not in already_processed:
            already_processed.add('additional')
            outfile.write(' additional=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.additional), input_name='additional')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.after_barline is not None and 'after_barline' not in already_processed:
            already_processed.add('after_barline')
            outfile.write(' after-barline=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.after_barline), input_name='after-barline')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='clef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sign is not None:
            namespaceprefix_ = self.sign_nsprefix_ + ':' if (UseCapturedNS_ and self.sign_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssign>%s</%ssign>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sign), input_name='sign')), namespaceprefix_ , eol_))
        if self.line is not None:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sline>%s</%sline>%s' % (namespaceprefix_ , self.gds_format_integer(self.line, input_name='line'), namespaceprefix_ , eol_))
        if self.clef_octave_change is not None:
            namespaceprefix_ = self.clef_octave_change_nsprefix_ + ':' if (UseCapturedNS_ and self.clef_octave_change_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclef-octave-change>%s</%sclef-octave-change>%s' % (namespaceprefix_ , self.gds_format_integer(self.clef_octave_change, input_name='clef-octave-change'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.number)    # validate type staff-number
        value = find_attr_value_('additional', node)
        if value is not None and 'additional' not in already_processed:
            already_processed.add('additional')
            self.additional = value
            self.additional = ' '.join(self.additional.split())
            self.validate_yes_no(self.additional)    # validate type yes-no
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.size = ' '.join(self.size.split())
            self.validate_symbol_size(self.size)    # validate type symbol-size
        value = find_attr_value_('after-barline', node)
        if value is not None and 'after-barline' not in already_processed:
            already_processed.add('after-barline')
            self.after_barline = value
            self.after_barline = ' '.join(self.after_barline.split())
            self.validate_yes_no(self.after_barline)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sign':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sign')
            value_ = self.gds_validate_string(value_, node, 'sign')
            self.sign = value_
            self.sign_nsprefix_ = child_.prefix
            # validate type clef-sign
            self.validate_clef_sign(self.sign)
        elif nodeName_ == 'line' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'line')
            ival_ = self.gds_validate_integer(ival_, node, 'line')
            self.line = ival_
            self.line_nsprefix_ = child_.prefix
            # validate type staff-line-position
            self.validate_staff_line_position(self.line)
        elif nodeName_ == 'clef-octave-change' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'clef_octave_change')
            ival_ = self.gds_validate_integer(ival_, node, 'clef_octave_change')
            self.clef_octave_change = ival_
            self.clef_octave_change_nsprefix_ = child_.prefix
# end class clef


class double(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, above=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.above = _cast(None, above)
        self.above_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, double)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if double.subclass:
            return double.subclass(*args_, **kwargs_)
        else:
            return double(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_above(self):
        return self.above
    def set_above(self, above):
        self.above = above
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='double', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('double')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'double':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='double')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='double', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='double'):
        if self.above is not None and 'above' not in already_processed:
            already_processed.add('above')
            outfile.write(' above=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.above), input_name='above')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='double', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('above', node)
        if value is not None and 'above' not in already_processed:
            already_processed.add('above')
            self.above = value
            self.above = ' '.join(self.above.split())
            self.validate_yes_no(self.above)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class double


class for_part(GeneratedsSuper):
    """part-clef -- The part-clef element is used for transpositions that also include a change of clef, as for instruments such as bass clarinet.
    part-transpose -- The chromatic element in a part-transpose element will usually have a non-zero value, since octave transpositions can be represented in concert scores using the transpose element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, id=None, part_clef=None, part_transpose=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.part_clef = part_clef
        self.part_clef_nsprefix_ = None
        self.part_transpose = part_transpose
        self.part_transpose_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, for_part)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if for_part.subclass:
            return for_part.subclass(*args_, **kwargs_)
        else:
            return for_part(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_part_clef(self):
        return self.part_clef
    def set_part_clef(self, part_clef):
        self.part_clef = part_clef
    def get_part_transpose(self):
        return self.part_transpose
    def set_part_transpose(self, part_transpose):
        self.part_transpose = part_transpose
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.part_clef is not None or
            self.part_transpose is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='for-part', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('for-part')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'for-part':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='for-part')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='for-part', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='for-part'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='for-part', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.part_clef is not None:
            namespaceprefix_ = self.part_clef_nsprefix_ + ':' if (UseCapturedNS_ and self.part_clef_nsprefix_) else ''
            self.part_clef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-clef', pretty_print=pretty_print)
        if self.part_transpose is not None:
            namespaceprefix_ = self.part_transpose_nsprefix_ + ':' if (UseCapturedNS_ and self.part_transpose_nsprefix_) else ''
            self.part_transpose.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-transpose', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.number)    # validate type staff-number
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'part-clef':
            obj_ = part_clef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_clef = obj_
            obj_.original_tagname_ = 'part-clef'
        elif nodeName_ == 'part-transpose':
            obj_ = part_transpose.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_transpose = obj_
            obj_.original_tagname_ = 'part-transpose'
# end class for_part


class interchangeable(GeneratedsSuper):
    """beats -- The beats element indicates the number of beats, as found in the numerator of a time signature.
    beat-type -- The beat-type element indicates the beat unit, as found in the denominator of a time signature.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, symbol=None, separator=None, time_relation=None, beats=None, beat_type=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.symbol = _cast(None, symbol)
        self.symbol_nsprefix_ = None
        self.separator = _cast(None, separator)
        self.separator_nsprefix_ = None
        self.time_relation = time_relation
        self.validate_time_relation(self.time_relation)
        self.time_relation_nsprefix_ = None
        if beats is None:
            self.beats = []
        else:
            self.beats = beats
        self.beats_nsprefix_ = None
        if beat_type is None:
            self.beat_type = []
        else:
            self.beat_type = beat_type
        self.beat_type_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interchangeable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interchangeable.subclass:
            return interchangeable.subclass(*args_, **kwargs_)
        else:
            return interchangeable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_time_relation(self):
        return self.time_relation
    def set_time_relation(self, time_relation):
        self.time_relation = time_relation
    def get_beats(self):
        return self.beats
    def set_beats(self, beats):
        self.beats = beats
    def add_beats(self, value):
        self.beats.append(value)
    def insert_beats_at(self, index, value):
        self.beats.insert(index, value)
    def replace_beats_at(self, index, value):
        self.beats[index] = value
    def get_beat_type(self):
        return self.beat_type
    def set_beat_type(self, beat_type):
        self.beat_type = beat_type
    def add_beat_type(self, value):
        self.beat_type.append(value)
    def insert_beat_type_at(self, index, value):
        self.beat_type.insert(index, value)
    def replace_beat_type_at(self, index, value):
        self.beat_type[index] = value
    def get_symbol(self):
        return self.symbol
    def set_symbol(self, symbol):
        self.symbol = symbol
    def get_separator(self):
        return self.separator
    def set_separator(self, separator):
        self.separator = separator
    def validate_time_relation(self, value):
        result = True
        # Validate type time-relation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['parentheses', 'bracket', 'equals', 'slash', 'space', 'hyphen']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on time-relation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_time_symbol(self, value):
        # Validate type time-symbol, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['common', 'cut', 'single-number', 'note', 'dotted-note', 'normal']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on time-symbol' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_time_separator(self, value):
        # Validate type time-separator, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'horizontal', 'diagonal', 'vertical', 'adjacent']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on time-separator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.time_relation is not None or
            self.beats or
            self.beat_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='interchangeable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interchangeable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'interchangeable':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='interchangeable')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='interchangeable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='interchangeable'):
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.add('symbol')
            outfile.write(' symbol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.symbol), input_name='symbol')), ))
        if self.separator is not None and 'separator' not in already_processed:
            already_processed.add('separator')
            outfile.write(' separator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.separator), input_name='separator')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='interchangeable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.time_relation is not None:
            namespaceprefix_ = self.time_relation_nsprefix_ + ':' if (UseCapturedNS_ and self.time_relation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime-relation>%s</%stime-relation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.time_relation), input_name='time-relation')), namespaceprefix_ , eol_))
        for beats_ in self.beats:
            namespaceprefix_ = self.beats_nsprefix_ + ':' if (UseCapturedNS_ and self.beats_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeats>%s</%sbeats>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(beats_), input_name='beats')), namespaceprefix_ , eol_))
        for beat_type_ in self.beat_type:
            namespaceprefix_ = self.beat_type_nsprefix_ + ':' if (UseCapturedNS_ and self.beat_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeat-type>%s</%sbeat-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(beat_type_), input_name='beat-type')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('symbol', node)
        if value is not None and 'symbol' not in already_processed:
            already_processed.add('symbol')
            self.symbol = value
            self.symbol = ' '.join(self.symbol.split())
            self.validate_time_symbol(self.symbol)    # validate type time-symbol
        value = find_attr_value_('separator', node)
        if value is not None and 'separator' not in already_processed:
            already_processed.add('separator')
            self.separator = value
            self.separator = ' '.join(self.separator.split())
            self.validate_time_separator(self.separator)    # validate type time-separator
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'time-relation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'time_relation')
            value_ = self.gds_validate_string(value_, node, 'time_relation')
            self.time_relation = value_
            self.time_relation_nsprefix_ = child_.prefix
            # validate type time-relation
            self.validate_time_relation(self.time_relation)
        elif nodeName_ == 'beats':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'beats')
            value_ = self.gds_validate_string(value_, node, 'beats')
            self.beats.append(value_)
            self.beats_nsprefix_ = child_.prefix
        elif nodeName_ == 'beat-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'beat_type')
            value_ = self.gds_validate_string(value_, node, 'beat_type')
            self.beat_type.append(value_)
            self.beat_type_nsprefix_ = child_.prefix
# end class interchangeable


class key(GeneratedsSuper):
    """key-step -- Non-traditional key signatures are represented using a list of altered tones. The key-step element indicates the pitch step to be altered, represented using the same names as in the step element.
    key-alter -- Non-traditional key signatures are represented using a list of altered tones. The key-alter element represents the alteration for a given pitch step, represented with semitones in the same manner as the alter element.
    key-accidental -- Non-traditional key signatures are represented using a list of altered tones. The key-accidental element indicates the accidental to be displayed in the key signature, represented in the same manner as the accidental element. It is used for disambiguating microtonal accidentals.
    key-octave -- The optional list of key-octave elements is used to specify in which octave each element of the key signature appears.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, print_object=None, id=None, cancel=None, fifths=None, mode=None, key_step=None, key_alter=None, key_accidental=None, key_octave=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.cancel = cancel
        self.cancel_nsprefix_ = None
        self.fifths = fifths
        self.validate_fifths(self.fifths)
        self.fifths_nsprefix_ = None
        self.mode = mode
        self.validate_mode(self.mode)
        self.mode_nsprefix_ = None
        if key_step is None:
            self.key_step = []
        else:
            self.key_step = key_step
        self.key_step_nsprefix_ = None
        if key_alter is None:
            self.key_alter = []
        else:
            self.key_alter = key_alter
        self.key_alter_nsprefix_ = None
        if key_accidental is None:
            self.key_accidental = []
        else:
            self.key_accidental = key_accidental
        self.key_accidental_nsprefix_ = None
        if key_octave is None:
            self.key_octave = []
        else:
            self.key_octave = key_octave
        self.key_octave_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, key)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if key.subclass:
            return key.subclass(*args_, **kwargs_)
        else:
            return key(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cancel(self):
        return self.cancel
    def set_cancel(self, cancel):
        self.cancel = cancel
    def get_fifths(self):
        return self.fifths
    def set_fifths(self, fifths):
        self.fifths = fifths
    def get_mode(self):
        return self.mode
    def set_mode(self, mode):
        self.mode = mode
    def get_key_step(self):
        return self.key_step
    def set_key_step(self, key_step):
        self.key_step = key_step
    def add_key_step(self, value):
        self.key_step.append(value)
    def insert_key_step_at(self, index, value):
        self.key_step.insert(index, value)
    def replace_key_step_at(self, index, value):
        self.key_step[index] = value
    def get_key_alter(self):
        return self.key_alter
    def set_key_alter(self, key_alter):
        self.key_alter = key_alter
    def add_key_alter(self, value):
        self.key_alter.append(value)
    def insert_key_alter_at(self, index, value):
        self.key_alter.insert(index, value)
    def replace_key_alter_at(self, index, value):
        self.key_alter[index] = value
    def get_key_accidental(self):
        return self.key_accidental
    def set_key_accidental(self, key_accidental):
        self.key_accidental = key_accidental
    def add_key_accidental(self, value):
        self.key_accidental.append(value)
    def insert_key_accidental_at(self, index, value):
        self.key_accidental.insert(index, value)
    def replace_key_accidental_at(self, index, value):
        self.key_accidental[index] = value
    def get_key_octave(self):
        return self.key_octave
    def set_key_octave(self, key_octave):
        self.key_octave = key_octave
    def add_key_octave(self, value):
        self.key_octave.append(value)
    def insert_key_octave_at(self, index, value):
        self.key_octave.insert(index, value)
    def replace_key_octave_at(self, index, value):
        self.key_octave[index] = value
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_fifths(self, value):
        result = True
        # Validate type fifths, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_mode(self, value):
        result = True
        # Validate type mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.cancel is not None or
            self.fifths is not None or
            self.mode is not None or
            self.key_step or
            self.key_alter or
            self.key_accidental or
            self.key_octave
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='key', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('key')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'key':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='key')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='key', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='key'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='key', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cancel is not None:
            namespaceprefix_ = self.cancel_nsprefix_ + ':' if (UseCapturedNS_ and self.cancel_nsprefix_) else ''
            self.cancel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cancel', pretty_print=pretty_print)
        if self.fifths is not None:
            namespaceprefix_ = self.fifths_nsprefix_ + ':' if (UseCapturedNS_ and self.fifths_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfifths>%s</%sfifths>%s' % (namespaceprefix_ , self.gds_format_integer(self.fifths, input_name='fifths'), namespaceprefix_ , eol_))
        if self.mode is not None:
            namespaceprefix_ = self.mode_nsprefix_ + ':' if (UseCapturedNS_ and self.mode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smode>%s</%smode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mode), input_name='mode')), namespaceprefix_ , eol_))
        for key_step_ in self.key_step:
            namespaceprefix_ = self.key_step_nsprefix_ + ':' if (UseCapturedNS_ and self.key_step_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey-step>%s</%skey-step>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(key_step_), input_name='key-step')), namespaceprefix_ , eol_))
        for key_alter_ in self.key_alter:
            namespaceprefix_ = self.key_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.key_alter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey-alter>%s</%skey-alter>%s' % (namespaceprefix_ , self.gds_format_decimal(key_alter_, input_name='key-alter'), namespaceprefix_ , eol_))
        for key_accidental_ in self.key_accidental:
            namespaceprefix_ = self.key_accidental_nsprefix_ + ':' if (UseCapturedNS_ and self.key_accidental_nsprefix_) else ''
            key_accidental_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key-accidental', pretty_print=pretty_print)
        for key_octave_ in self.key_octave:
            namespaceprefix_ = self.key_octave_nsprefix_ + ':' if (UseCapturedNS_ and self.key_octave_nsprefix_) else ''
            key_octave_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='key-octave', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.number)    # validate type staff-number
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cancel':
            obj_ = cancel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cancel = obj_
            obj_.original_tagname_ = 'cancel'
        elif nodeName_ == 'fifths' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'fifths')
            ival_ = self.gds_validate_integer(ival_, node, 'fifths')
            self.fifths = ival_
            self.fifths_nsprefix_ = child_.prefix
            # validate type fifths
            self.validate_fifths(self.fifths)
        elif nodeName_ == 'mode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mode')
            value_ = self.gds_validate_string(value_, node, 'mode')
            self.mode = value_
            self.mode_nsprefix_ = child_.prefix
            # validate type mode
            self.validate_mode(self.mode)
        elif nodeName_ == 'key-step':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'key_step')
            value_ = self.gds_validate_string(value_, node, 'key_step')
            self.key_step.append(value_)
            self.key_step_nsprefix_ = child_.prefix
            # validate type step
            self.validate_step(self.key_step[-1])
        elif nodeName_ == 'key-alter' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'key_alter')
            fval_ = self.gds_validate_decimal(fval_, node, 'key_alter')
            self.key_alter.append(fval_)
            self.key_alter_nsprefix_ = child_.prefix
            # validate type semitones
            self.validate_semitones(self.key_alter[-1])
        elif nodeName_ == 'key-accidental':
            obj_ = key_accidental.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key_accidental.append(obj_)
            obj_.original_tagname_ = 'key-accidental'
        elif nodeName_ == 'key-octave':
            obj_ = key_octave.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.key_octave.append(obj_)
            obj_.original_tagname_ = 'key-octave'
# end class key


class key_accidental(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, key_accidental)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if key_accidental.subclass:
            return key_accidental.subclass(*args_, **kwargs_)
        else:
            return key_accidental(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_accidental_value(self, value):
        result = True
        # Validate type accidental-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['sharp', 'natural', 'flat', 'double-sharp', 'sharp-sharp', 'flat-flat', 'natural-sharp', 'natural-flat', 'quarter-flat', 'quarter-sharp', 'three-quarters-flat', 'three-quarters-sharp', 'sharp-down', 'sharp-up', 'natural-down', 'natural-up', 'flat-down', 'flat-up', 'double-sharp-down', 'double-sharp-up', 'flat-flat-down', 'flat-flat-up', 'arrow-down', 'arrow-up', 'triple-sharp', 'triple-flat', 'slash-quarter-sharp', 'slash-sharp', 'slash-flat', 'double-slash-flat', 'sharp-1', 'sharp-2', 'sharp-3', 'sharp-5', 'flat-1', 'flat-2', 'flat-3', 'flat-4', 'sori', 'koron', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on accidental-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_accidental_glyph_name(self, value):
        # Validate type smufl-accidental-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_accidental_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_accidental_glyph_name_patterns_, ))
    validate_smufl_accidental_glyph_name_patterns_ = [['^((acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)(\\c+))$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='key-accidental', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('key-accidental')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'key-accidental':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='key-accidental')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='key-accidental', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='key-accidental'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='key-accidental', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_accidental_glyph_name(self.smufl)    # validate type smufl-accidental-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class key_accidental


class key_octave(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, cancel=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.cancel = _cast(None, cancel)
        self.cancel_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, key_octave)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if key_octave.subclass:
            return key_octave.subclass(*args_, **kwargs_)
        else:
            return key_octave(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_cancel(self):
        return self.cancel
    def set_cancel(self, cancel):
        self.cancel = cancel
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_octave(self, value):
        result = True
        # Validate type octave, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
            if value > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='key-octave', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('key-octave')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'key-octave':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='key-octave')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='key-octave', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='key-octave'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.cancel is not None and 'cancel' not in already_processed:
            already_processed.add('cancel')
            outfile.write(' cancel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cancel), input_name='cancel')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='key-octave', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('cancel', node)
        if value is not None and 'cancel' not in already_processed:
            already_processed.add('cancel')
            self.cancel = value
            self.cancel = ' '.join(self.cancel.split())
            self.validate_yes_no(self.cancel)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class key_octave


class line_detail(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, line=None, width=None, color=None, line_type=None, print_object=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.line = _cast(int, line)
        self.line_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.line_type = _cast(None, line_type)
        self.line_type_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, line_detail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if line_detail.subclass:
            return line_detail.subclass(*args_, **kwargs_)
        else:
            return line_detail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_line_type(self):
        return self.line_type
    def set_line_type(self, line_type):
        self.line_type = line_type
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def validate_staff_line(self, value):
        # Validate type staff-line, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_line_type(self, value):
        # Validate type line-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['solid', 'dashed', 'dotted', 'wavy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='line-detail', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('line-detail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'line-detail':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='line-detail')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='line-detail', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='line-detail'):
        if self.line is not None and 'line' not in already_processed:
            already_processed.add('line')
            outfile.write(' line="%s"' % self.gds_format_integer(self.line, input_name='line'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_decimal(self.width, input_name='width'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.line_type is not None and 'line_type' not in already_processed:
            already_processed.add('line_type')
            outfile.write(' line-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_type), input_name='line-type')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='line-detail', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('line', node)
        if value is not None and 'line' not in already_processed:
            already_processed.add('line')
            self.line = self.gds_parse_integer(value, node, 'line')
            if self.line <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_line(self.line)    # validate type staff-line
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_decimal(value, node, 'width')
            self.width = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('line-type', node)
        if value is not None and 'line-type' not in already_processed:
            already_processed.add('line-type')
            self.line_type = value
            self.line_type = ' '.join(self.line_type.split())
            self.validate_line_type(self.line_type)    # validate type line-type
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class line_detail


class measure_repeat(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, slashes=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.slashes = _cast(int, slashes)
        self.slashes_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, measure_repeat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if measure_repeat.subclass:
            return measure_repeat.subclass(*args_, **kwargs_)
        else:
            return measure_repeat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_slashes(self):
        return self.slashes
    def set_slashes(self, slashes):
        self.slashes = slashes
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_positive_integer_or_empty(self, value):
        result = True
        # Validate type positive-integer-or-empty, a restriction on xs:string.
        pass
        return result
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measure-repeat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('measure-repeat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'measure-repeat':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='measure-repeat')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='measure-repeat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='measure-repeat'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.slashes is not None and 'slashes' not in already_processed:
            already_processed.add('slashes')
            outfile.write(' slashes="%s"' % self.gds_format_integer(self.slashes, input_name='slashes'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measure-repeat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('slashes', node)
        if value is not None and 'slashes' not in already_processed:
            already_processed.add('slashes')
            self.slashes = self.gds_parse_integer(value, node, 'slashes')
            if self.slashes <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class measure_repeat


class measure_style(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, id=None, multiple_rest=None, measure_repeat=None, beat_repeat=None, slash=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.multiple_rest = multiple_rest
        self.multiple_rest_nsprefix_ = None
        self.measure_repeat = measure_repeat
        self.measure_repeat_nsprefix_ = None
        self.beat_repeat = beat_repeat
        self.beat_repeat_nsprefix_ = None
        self.slash = slash
        self.slash_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, measure_style)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if measure_style.subclass:
            return measure_style.subclass(*args_, **kwargs_)
        else:
            return measure_style(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiple_rest(self):
        return self.multiple_rest
    def set_multiple_rest(self, multiple_rest):
        self.multiple_rest = multiple_rest
    def get_measure_repeat(self):
        return self.measure_repeat
    def set_measure_repeat(self, measure_repeat):
        self.measure_repeat = measure_repeat
    def get_beat_repeat(self):
        return self.beat_repeat
    def set_beat_repeat(self, beat_repeat):
        self.beat_repeat = beat_repeat
    def get_slash(self):
        return self.slash
    def set_slash(self, slash):
        self.slash = slash
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            self.multiple_rest is not None or
            self.measure_repeat is not None or
            self.beat_repeat is not None or
            self.slash is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measure-style', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('measure-style')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'measure-style':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='measure-style')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='measure-style', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='measure-style'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measure-style', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiple_rest is not None:
            namespaceprefix_ = self.multiple_rest_nsprefix_ + ':' if (UseCapturedNS_ and self.multiple_rest_nsprefix_) else ''
            self.multiple_rest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiple-rest', pretty_print=pretty_print)
        if self.measure_repeat is not None:
            namespaceprefix_ = self.measure_repeat_nsprefix_ + ':' if (UseCapturedNS_ and self.measure_repeat_nsprefix_) else ''
            self.measure_repeat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='measure-repeat', pretty_print=pretty_print)
        if self.beat_repeat is not None:
            namespaceprefix_ = self.beat_repeat_nsprefix_ + ':' if (UseCapturedNS_ and self.beat_repeat_nsprefix_) else ''
            self.beat_repeat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='beat-repeat', pretty_print=pretty_print)
        if self.slash is not None:
            namespaceprefix_ = self.slash_nsprefix_ + ':' if (UseCapturedNS_ and self.slash_nsprefix_) else ''
            self.slash.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slash', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.number)    # validate type staff-number
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiple-rest':
            obj_ = multiple_rest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiple_rest = obj_
            obj_.original_tagname_ = 'multiple-rest'
        elif nodeName_ == 'measure-repeat':
            obj_ = measure_repeat.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.measure_repeat = obj_
            obj_.original_tagname_ = 'measure-repeat'
        elif nodeName_ == 'beat-repeat':
            obj_ = beat_repeat.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.beat_repeat = obj_
            obj_.original_tagname_ = 'beat-repeat'
        elif nodeName_ == 'slash':
            obj_ = slash.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slash = obj_
            obj_.original_tagname_ = 'slash'
# end class measure_style


class multiple_rest(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, use_symbols=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.use_symbols = _cast(None, use_symbols)
        self.use_symbols_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, multiple_rest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if multiple_rest.subclass:
            return multiple_rest.subclass(*args_, **kwargs_)
        else:
            return multiple_rest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_use_symbols(self):
        return self.use_symbols
    def set_use_symbols(self, use_symbols):
        self.use_symbols = use_symbols
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='multiple-rest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('multiple-rest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'multiple-rest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='multiple-rest')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='multiple-rest', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='multiple-rest'):
        if self.use_symbols is not None and 'use_symbols' not in already_processed:
            already_processed.add('use_symbols')
            outfile.write(' use-symbols=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.use_symbols), input_name='use-symbols')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='multiple-rest', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use-symbols', node)
        if value is not None and 'use-symbols' not in already_processed:
            already_processed.add('use-symbols')
            self.use_symbols = value
            self.use_symbols = ' '.join(self.use_symbols.split())
            self.validate_yes_no(self.use_symbols)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class multiple_rest


class part_clef(GeneratedsSuper):
    """sign -- The sign element represents the clef symbol.
    line -- Line numbers are counted from the bottom of the staff. They are only needed with the G, F, and C signs in order to position a pitch correctly on the staff. Standard values are 2 for the G sign (treble clef), 4 for the F sign (bass clef), and 3 for the C sign (alto clef). Line values can be used to specify positions outside the staff, such as a C clef positioned in the middle of a grand staff.
    clef-octave-change -- The clef-octave-change element is used for transposing clefs. A treble clef for tenors would have a value of -1.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sign=None, line=None, clef_octave_change=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sign = sign
        self.validate_clef_sign(self.sign)
        self.sign_nsprefix_ = None
        self.line = line
        self.validate_staff_line_position(self.line)
        self.line_nsprefix_ = None
        self.clef_octave_change = clef_octave_change
        self.clef_octave_change_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, part_clef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if part_clef.subclass:
            return part_clef.subclass(*args_, **kwargs_)
        else:
            return part_clef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sign(self):
        return self.sign
    def set_sign(self, sign):
        self.sign = sign
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_clef_octave_change(self):
        return self.clef_octave_change
    def set_clef_octave_change(self, clef_octave_change):
        self.clef_octave_change = clef_octave_change
    def validate_clef_sign(self, value):
        result = True
        # Validate type clef-sign, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['G', 'F', 'C', 'percussion', 'TAB', 'jianpu', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on clef-sign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_staff_line_position(self, value):
        result = True
        # Validate type staff-line-position, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.sign is not None or
            self.line is not None or
            self.clef_octave_change is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-clef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('part-clef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'part-clef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='part-clef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='part-clef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='part-clef'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-clef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sign is not None:
            namespaceprefix_ = self.sign_nsprefix_ + ':' if (UseCapturedNS_ and self.sign_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssign>%s</%ssign>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sign), input_name='sign')), namespaceprefix_ , eol_))
        if self.line is not None:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sline>%s</%sline>%s' % (namespaceprefix_ , self.gds_format_integer(self.line, input_name='line'), namespaceprefix_ , eol_))
        if self.clef_octave_change is not None:
            namespaceprefix_ = self.clef_octave_change_nsprefix_ + ':' if (UseCapturedNS_ and self.clef_octave_change_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclef-octave-change>%s</%sclef-octave-change>%s' % (namespaceprefix_ , self.gds_format_integer(self.clef_octave_change, input_name='clef-octave-change'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sign':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'sign')
            value_ = self.gds_validate_string(value_, node, 'sign')
            self.sign = value_
            self.sign_nsprefix_ = child_.prefix
            # validate type clef-sign
            self.validate_clef_sign(self.sign)
        elif nodeName_ == 'line' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'line')
            ival_ = self.gds_validate_integer(ival_, node, 'line')
            self.line = ival_
            self.line_nsprefix_ = child_.prefix
            # validate type staff-line-position
            self.validate_staff_line_position(self.line)
        elif nodeName_ == 'clef-octave-change' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'clef_octave_change')
            ival_ = self.gds_validate_integer(ival_, node, 'clef_octave_change')
            self.clef_octave_change = ival_
            self.clef_octave_change_nsprefix_ = child_.prefix
# end class part_clef


class part_symbol(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, top_staff=None, bottom_staff=None, default_x=None, default_y=None, relative_x=None, relative_y=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.top_staff = _cast(int, top_staff)
        self.top_staff_nsprefix_ = None
        self.bottom_staff = _cast(int, bottom_staff)
        self.bottom_staff_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, part_symbol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if part_symbol.subclass:
            return part_symbol.subclass(*args_, **kwargs_)
        else:
            return part_symbol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_top_staff(self):
        return self.top_staff
    def set_top_staff(self, top_staff):
        self.top_staff = top_staff
    def get_bottom_staff(self):
        return self.bottom_staff
    def set_bottom_staff(self, bottom_staff):
        self.bottom_staff = bottom_staff
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_group_symbol_value(self, value):
        result = True
        # Validate type group-symbol-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'brace', 'line', 'bracket', 'square']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on group-symbol-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-symbol', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('part-symbol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'part-symbol':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='part-symbol')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='part-symbol', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='part-symbol'):
        if self.top_staff is not None and 'top_staff' not in already_processed:
            already_processed.add('top_staff')
            outfile.write(' top-staff="%s"' % self.gds_format_integer(self.top_staff, input_name='top-staff'))
        if self.bottom_staff is not None and 'bottom_staff' not in already_processed:
            already_processed.add('bottom_staff')
            outfile.write(' bottom-staff="%s"' % self.gds_format_integer(self.bottom_staff, input_name='bottom-staff'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-symbol', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('top-staff', node)
        if value is not None and 'top-staff' not in already_processed:
            already_processed.add('top-staff')
            self.top_staff = self.gds_parse_integer(value, node, 'top-staff')
            if self.top_staff <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.top_staff)    # validate type staff-number
        value = find_attr_value_('bottom-staff', node)
        if value is not None and 'bottom-staff' not in already_processed:
            already_processed.add('bottom-staff')
            self.bottom_staff = self.gds_parse_integer(value, node, 'bottom-staff')
            if self.bottom_staff <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.bottom_staff)    # validate type staff-number
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class part_symbol


class part_transpose(GeneratedsSuper):
    """diatonic -- The diatonic element specifies the number of pitch steps needed to go from written to sounding pitch. This allows for correct spelling of enharmonic transpositions. This value does not include octave-change values; the values for both elements need to be added to the written pitch to get the correct sounding pitch.
    chromatic -- The chromatic element represents the number of semitones needed to get from written to sounding pitch. This value does not include octave-change values; the values for both elements need to be added to the written pitch to get the correct sounding pitch.
    octave-change -- The octave-change element indicates how many octaves to add to get from written pitch to sounding pitch. The octave-change element should be included when using transposition intervals of an octave or more, and should not be present for intervals of less than an octave.
    double -- If the double element is present, it indicates that the music is doubled one octave from what is currently written.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, diatonic=None, chromatic=None, octave_change=None, double=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.diatonic = diatonic
        self.diatonic_nsprefix_ = None
        self.chromatic = chromatic
        self.validate_semitones(self.chromatic)
        self.chromatic_nsprefix_ = None
        self.octave_change = octave_change
        self.octave_change_nsprefix_ = None
        self.double = double
        self.double_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, part_transpose)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if part_transpose.subclass:
            return part_transpose.subclass(*args_, **kwargs_)
        else:
            return part_transpose(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_diatonic(self):
        return self.diatonic
    def set_diatonic(self, diatonic):
        self.diatonic = diatonic
    def get_chromatic(self):
        return self.chromatic
    def set_chromatic(self, chromatic):
        self.chromatic = chromatic
    def get_octave_change(self):
        return self.octave_change
    def set_octave_change(self, octave_change):
        self.octave_change = octave_change
    def get_double(self):
        return self.double
    def set_double(self, double):
        self.double = double
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.diatonic is not None or
            self.chromatic is not None or
            self.octave_change is not None or
            self.double is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-transpose', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('part-transpose')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'part-transpose':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='part-transpose')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='part-transpose', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='part-transpose'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-transpose', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.diatonic is not None:
            namespaceprefix_ = self.diatonic_nsprefix_ + ':' if (UseCapturedNS_ and self.diatonic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiatonic>%s</%sdiatonic>%s' % (namespaceprefix_ , self.gds_format_integer(self.diatonic, input_name='diatonic'), namespaceprefix_ , eol_))
        if self.chromatic is not None:
            namespaceprefix_ = self.chromatic_nsprefix_ + ':' if (UseCapturedNS_ and self.chromatic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schromatic>%s</%schromatic>%s' % (namespaceprefix_ , self.gds_format_decimal(self.chromatic, input_name='chromatic'), namespaceprefix_ , eol_))
        if self.octave_change is not None:
            namespaceprefix_ = self.octave_change_nsprefix_ + ':' if (UseCapturedNS_ and self.octave_change_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soctave-change>%s</%soctave-change>%s' % (namespaceprefix_ , self.gds_format_integer(self.octave_change, input_name='octave-change'), namespaceprefix_ , eol_))
        if self.double is not None:
            namespaceprefix_ = self.double_nsprefix_ + ':' if (UseCapturedNS_ and self.double_nsprefix_) else ''
            self.double.export(outfile, level, namespaceprefix_, namespacedef_='', name_='double', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'diatonic' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'diatonic')
            ival_ = self.gds_validate_integer(ival_, node, 'diatonic')
            self.diatonic = ival_
            self.diatonic_nsprefix_ = child_.prefix
        elif nodeName_ == 'chromatic' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'chromatic')
            fval_ = self.gds_validate_decimal(fval_, node, 'chromatic')
            self.chromatic = fval_
            self.chromatic_nsprefix_ = child_.prefix
            # validate type semitones
            self.validate_semitones(self.chromatic)
        elif nodeName_ == 'octave-change' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'octave_change')
            ival_ = self.gds_validate_integer(ival_, node, 'octave_change')
            self.octave_change = ival_
            self.octave_change_nsprefix_ = child_.prefix
        elif nodeName_ == 'double':
            obj_ = double.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.double = obj_
            obj_.original_tagname_ = 'double'
# end class part_transpose


class slash(GeneratedsSuper):
    """slash-type -- The slash-type element indicates the graphical note type to use for the display of repetition marks.
    slash-dot -- The slash-dot element is used to specify any augmentation dots in the note type used to display repetition marks.
    except-voice -- The except-voice element is used to specify a combination of slash notation and regular notation. Any note elements that are in voices specified by the except-voice elements are displayed in normal notation, in addition to the slash notation that is always displayed.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, use_dots=None, use_stems=None, slash_type=None, slash_dot=None, except_voice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.use_dots = _cast(None, use_dots)
        self.use_dots_nsprefix_ = None
        self.use_stems = _cast(None, use_stems)
        self.use_stems_nsprefix_ = None
        self.slash_type = slash_type
        self.validate_note_type_value(self.slash_type)
        self.slash_type_nsprefix_ = None
        if slash_dot is None:
            self.slash_dot = []
        else:
            self.slash_dot = slash_dot
        self.slash_dot_nsprefix_ = None
        if except_voice is None:
            self.except_voice = []
        else:
            self.except_voice = except_voice
        self.except_voice_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, slash)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if slash.subclass:
            return slash.subclass(*args_, **kwargs_)
        else:
            return slash(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_slash_type(self):
        return self.slash_type
    def set_slash_type(self, slash_type):
        self.slash_type = slash_type
    def get_slash_dot(self):
        return self.slash_dot
    def set_slash_dot(self, slash_dot):
        self.slash_dot = slash_dot
    def add_slash_dot(self, value):
        self.slash_dot.append(value)
    def insert_slash_dot_at(self, index, value):
        self.slash_dot.insert(index, value)
    def replace_slash_dot_at(self, index, value):
        self.slash_dot[index] = value
    def get_except_voice(self):
        return self.except_voice
    def set_except_voice(self, except_voice):
        self.except_voice = except_voice
    def add_except_voice(self, value):
        self.except_voice.append(value)
    def insert_except_voice_at(self, index, value):
        self.except_voice.insert(index, value)
    def replace_except_voice_at(self, index, value):
        self.except_voice[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_use_dots(self):
        return self.use_dots
    def set_use_dots(self, use_dots):
        self.use_dots = use_dots
    def get_use_stems(self):
        return self.use_stems
    def set_use_stems(self, use_stems):
        self.use_stems = use_stems
    def validate_note_type_value(self, value):
        result = True
        # Validate type note-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.slash_type is not None or
            self.slash_dot or
            self.except_voice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='slash', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slash')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'slash':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='slash')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='slash', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='slash'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.use_dots is not None and 'use_dots' not in already_processed:
            already_processed.add('use_dots')
            outfile.write(' use-dots=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.use_dots), input_name='use-dots')), ))
        if self.use_stems is not None and 'use_stems' not in already_processed:
            already_processed.add('use_stems')
            outfile.write(' use-stems=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.use_stems), input_name='use-stems')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='slash', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.slash_type is not None:
            namespaceprefix_ = self.slash_type_nsprefix_ + ':' if (UseCapturedNS_ and self.slash_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sslash-type>%s</%sslash-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.slash_type), input_name='slash-type')), namespaceprefix_ , eol_))
        for slash_dot_ in self.slash_dot:
            namespaceprefix_ = self.slash_dot_nsprefix_ + ':' if (UseCapturedNS_ and self.slash_dot_nsprefix_) else ''
            slash_dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slash-dot', pretty_print=pretty_print)
        for except_voice_ in self.except_voice:
            namespaceprefix_ = self.except_voice_nsprefix_ + ':' if (UseCapturedNS_ and self.except_voice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexcept-voice>%s</%sexcept-voice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(except_voice_), input_name='except-voice')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('use-dots', node)
        if value is not None and 'use-dots' not in already_processed:
            already_processed.add('use-dots')
            self.use_dots = value
            self.use_dots = ' '.join(self.use_dots.split())
            self.validate_yes_no(self.use_dots)    # validate type yes-no
        value = find_attr_value_('use-stems', node)
        if value is not None and 'use-stems' not in already_processed:
            already_processed.add('use-stems')
            self.use_stems = value
            self.use_stems = ' '.join(self.use_stems.split())
            self.validate_yes_no(self.use_stems)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'slash-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'slash_type')
            value_ = self.gds_validate_string(value_, node, 'slash_type')
            self.slash_type = value_
            self.slash_type_nsprefix_ = child_.prefix
            # validate type note-type-value
            self.validate_note_type_value(self.slash_type)
        elif nodeName_ == 'slash-dot':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slash_dot.append(obj_)
            obj_.original_tagname_ = 'slash-dot'
        elif nodeName_ == 'except-voice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'except_voice')
            value_ = self.gds_validate_string(value_, node, 'except_voice')
            self.except_voice.append(value_)
            self.except_voice_nsprefix_ = child_.prefix
# end class slash


class staff_details(GeneratedsSuper):
    """staff-lines -- The staff-lines element specifies the number of lines and is usually used for a non 5-line staff. If the staff-lines element is present, the appearance of each line may be individually specified with a line-detail element.
    capo -- The capo element indicates at which fret a capo should be placed on a fretted instrument. This changes the open tuning of the strings specified by staff-tuning by the specified number of half-steps.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, show_frets=None, print_object=None, print_spacing=None, staff_type=None, staff_lines=None, line_detail=None, staff_tuning=None, capo=None, staff_size=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.show_frets = _cast(None, show_frets)
        self.show_frets_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.print_spacing = _cast(None, print_spacing)
        self.print_spacing_nsprefix_ = None
        self.staff_type = staff_type
        self.validate_staff_type(self.staff_type)
        self.staff_type_nsprefix_ = None
        self.staff_lines = staff_lines
        self.staff_lines_nsprefix_ = None
        if line_detail is None:
            self.line_detail = []
        else:
            self.line_detail = line_detail
        self.line_detail_nsprefix_ = None
        if staff_tuning is None:
            self.staff_tuning = []
        else:
            self.staff_tuning = staff_tuning
        self.staff_tuning_nsprefix_ = None
        self.capo = capo
        self.capo_nsprefix_ = None
        self.staff_size = staff_size
        self.staff_size_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, staff_details)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if staff_details.subclass:
            return staff_details.subclass(*args_, **kwargs_)
        else:
            return staff_details(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_staff_type(self):
        return self.staff_type
    def set_staff_type(self, staff_type):
        self.staff_type = staff_type
    def get_staff_lines(self):
        return self.staff_lines
    def set_staff_lines(self, staff_lines):
        self.staff_lines = staff_lines
    def get_line_detail(self):
        return self.line_detail
    def set_line_detail(self, line_detail):
        self.line_detail = line_detail
    def add_line_detail(self, value):
        self.line_detail.append(value)
    def insert_line_detail_at(self, index, value):
        self.line_detail.insert(index, value)
    def replace_line_detail_at(self, index, value):
        self.line_detail[index] = value
    def get_staff_tuning(self):
        return self.staff_tuning
    def set_staff_tuning(self, staff_tuning):
        self.staff_tuning = staff_tuning
    def add_staff_tuning(self, value):
        self.staff_tuning.append(value)
    def insert_staff_tuning_at(self, index, value):
        self.staff_tuning.insert(index, value)
    def replace_staff_tuning_at(self, index, value):
        self.staff_tuning[index] = value
    def get_capo(self):
        return self.capo
    def set_capo(self, capo):
        self.capo = capo
    def get_staff_size(self):
        return self.staff_size
    def set_staff_size(self, staff_size):
        self.staff_size = staff_size
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_show_frets(self):
        return self.show_frets
    def set_show_frets(self, show_frets):
        self.show_frets = show_frets
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_print_spacing(self):
        return self.print_spacing
    def set_print_spacing(self, print_spacing):
        self.print_spacing = print_spacing
    def validate_staff_type(self, value):
        result = True
        # Validate type staff-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ossia', 'editorial', 'cue', 'alternate', 'regular']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on staff-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_show_frets(self, value):
        # Validate type show-frets, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['numbers', 'letters']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on show-frets' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.staff_type is not None or
            self.staff_lines is not None or
            self.line_detail or
            self.staff_tuning or
            self.capo is not None or
            self.staff_size is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-details', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('staff-details')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'staff-details':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='staff-details')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='staff-details', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='staff-details'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.show_frets is not None and 'show_frets' not in already_processed:
            already_processed.add('show_frets')
            outfile.write(' show-frets=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show_frets), input_name='show-frets')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.print_spacing is not None and 'print_spacing' not in already_processed:
            already_processed.add('print_spacing')
            outfile.write(' print-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_spacing), input_name='print-spacing')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-details', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.staff_type is not None:
            namespaceprefix_ = self.staff_type_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaff-type>%s</%sstaff-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.staff_type), input_name='staff-type')), namespaceprefix_ , eol_))
        if self.staff_lines is not None:
            namespaceprefix_ = self.staff_lines_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_lines_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaff-lines>%s</%sstaff-lines>%s' % (namespaceprefix_ , self.gds_format_integer(self.staff_lines, input_name='staff-lines'), namespaceprefix_ , eol_))
        for line_detail_ in self.line_detail:
            namespaceprefix_ = self.line_detail_nsprefix_ + ':' if (UseCapturedNS_ and self.line_detail_nsprefix_) else ''
            line_detail_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line-detail', pretty_print=pretty_print)
        for staff_tuning_ in self.staff_tuning:
            namespaceprefix_ = self.staff_tuning_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_tuning_nsprefix_) else ''
            staff_tuning_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='staff-tuning', pretty_print=pretty_print)
        if self.capo is not None:
            namespaceprefix_ = self.capo_nsprefix_ + ':' if (UseCapturedNS_ and self.capo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapo>%s</%scapo>%s' % (namespaceprefix_ , self.gds_format_integer(self.capo, input_name='capo'), namespaceprefix_ , eol_))
        if self.staff_size is not None:
            namespaceprefix_ = self.staff_size_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_size_nsprefix_) else ''
            self.staff_size.export(outfile, level, namespaceprefix_, namespacedef_='', name_='staff-size', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.number)    # validate type staff-number
        value = find_attr_value_('show-frets', node)
        if value is not None and 'show-frets' not in already_processed:
            already_processed.add('show-frets')
            self.show_frets = value
            self.show_frets = ' '.join(self.show_frets.split())
            self.validate_show_frets(self.show_frets)    # validate type show-frets
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('print-spacing', node)
        if value is not None and 'print-spacing' not in already_processed:
            already_processed.add('print-spacing')
            self.print_spacing = value
            self.print_spacing = ' '.join(self.print_spacing.split())
            self.validate_yes_no(self.print_spacing)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'staff-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'staff_type')
            value_ = self.gds_validate_string(value_, node, 'staff_type')
            self.staff_type = value_
            self.staff_type_nsprefix_ = child_.prefix
            # validate type staff-type
            self.validate_staff_type(self.staff_type)
        elif nodeName_ == 'staff-lines' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'staff_lines')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'staff_lines')
            self.staff_lines = ival_
            self.staff_lines_nsprefix_ = child_.prefix
        elif nodeName_ == 'line-detail':
            obj_ = line_detail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line_detail.append(obj_)
            obj_.original_tagname_ = 'line-detail'
        elif nodeName_ == 'staff-tuning':
            obj_ = staff_tuning.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.staff_tuning.append(obj_)
            obj_.original_tagname_ = 'staff-tuning'
        elif nodeName_ == 'capo' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'capo')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'capo')
            self.capo = ival_
            self.capo_nsprefix_ = child_.prefix
        elif nodeName_ == 'staff-size':
            obj_ = staff_size.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.staff_size = obj_
            obj_.original_tagname_ = 'staff-size'
# end class staff_details


class staff_size(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, scaling=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.scaling = _cast(float, scaling)
        self.scaling_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, staff_size)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if staff_size.subclass:
            return staff_size.subclass(*args_, **kwargs_)
        else:
            return staff_size(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_scaling(self):
        return self.scaling
    def set_scaling(self, scaling):
        self.scaling = scaling
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_non_negative_decimal(self, value):
        result = True
        # Validate type non-negative-decimal, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on non-negative-decimal' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_non_negative_decimal(self, value):
        # Validate type non-negative-decimal, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on non-negative-decimal' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-size', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('staff-size')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'staff-size':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='staff-size')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='staff-size', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='staff-size'):
        if self.scaling is not None and 'scaling' not in already_processed:
            already_processed.add('scaling')
            outfile.write(' scaling="%s"' % self.gds_format_decimal(self.scaling, input_name='scaling'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-size', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scaling', node)
        if value is not None and 'scaling' not in already_processed:
            already_processed.add('scaling')
            value = self.gds_parse_decimal(value, node, 'scaling')
            self.scaling = value
            self.validate_non_negative_decimal(self.scaling)    # validate type non-negative-decimal
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class staff_size


class staff_tuning(GeneratedsSuper):
    """tuning-step -- The tuning-step element is represented like the step element, with a different name to reflect its different function in string tuning.
    tuning-alter -- The tuning-alter element is represented like the alter element, with a different name to reflect its different function in string tuning.
    tuning-octave -- The tuning-octave element is represented like the octave element, with a different name to reflect its different function in string tuning.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, line=None, tuning_step=None, tuning_alter=None, tuning_octave=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.line = _cast(int, line)
        self.line_nsprefix_ = None
        self.tuning_step = tuning_step
        self.validate_step(self.tuning_step)
        self.tuning_step_nsprefix_ = None
        self.tuning_alter = tuning_alter
        self.validate_semitones(self.tuning_alter)
        self.tuning_alter_nsprefix_ = None
        self.tuning_octave = tuning_octave
        self.validate_octave(self.tuning_octave)
        self.tuning_octave_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, staff_tuning)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if staff_tuning.subclass:
            return staff_tuning.subclass(*args_, **kwargs_)
        else:
            return staff_tuning(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tuning_step(self):
        return self.tuning_step
    def set_tuning_step(self, tuning_step):
        self.tuning_step = tuning_step
    def get_tuning_alter(self):
        return self.tuning_alter
    def set_tuning_alter(self, tuning_alter):
        self.tuning_alter = tuning_alter
    def get_tuning_octave(self):
        return self.tuning_octave
    def set_tuning_octave(self, tuning_octave):
        self.tuning_octave = tuning_octave
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_octave(self, value):
        result = True
        # Validate type octave, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
            if value > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_staff_line(self, value):
        # Validate type staff-line, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.tuning_step is not None or
            self.tuning_alter is not None or
            self.tuning_octave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-tuning', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('staff-tuning')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'staff-tuning':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='staff-tuning')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='staff-tuning', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='staff-tuning'):
        if self.line is not None and 'line' not in already_processed:
            already_processed.add('line')
            outfile.write(' line="%s"' % self.gds_format_integer(self.line, input_name='line'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-tuning', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tuning_step is not None:
            namespaceprefix_ = self.tuning_step_nsprefix_ + ':' if (UseCapturedNS_ and self.tuning_step_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stuning-step>%s</%stuning-step>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tuning_step), input_name='tuning-step')), namespaceprefix_ , eol_))
        if self.tuning_alter is not None:
            namespaceprefix_ = self.tuning_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.tuning_alter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stuning-alter>%s</%stuning-alter>%s' % (namespaceprefix_ , self.gds_format_decimal(self.tuning_alter, input_name='tuning-alter'), namespaceprefix_ , eol_))
        if self.tuning_octave is not None:
            namespaceprefix_ = self.tuning_octave_nsprefix_ + ':' if (UseCapturedNS_ and self.tuning_octave_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stuning-octave>%s</%stuning-octave>%s' % (namespaceprefix_ , self.gds_format_integer(self.tuning_octave, input_name='tuning-octave'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('line', node)
        if value is not None and 'line' not in already_processed:
            already_processed.add('line')
            self.line = self.gds_parse_integer(value, node, 'line')
            if self.line <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_line(self.line)    # validate type staff-line
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tuning-step':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tuning_step')
            value_ = self.gds_validate_string(value_, node, 'tuning_step')
            self.tuning_step = value_
            self.tuning_step_nsprefix_ = child_.prefix
            # validate type step
            self.validate_step(self.tuning_step)
        elif nodeName_ == 'tuning-alter' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'tuning_alter')
            fval_ = self.gds_validate_decimal(fval_, node, 'tuning_alter')
            self.tuning_alter = fval_
            self.tuning_alter_nsprefix_ = child_.prefix
            # validate type semitones
            self.validate_semitones(self.tuning_alter)
        elif nodeName_ == 'tuning-octave' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'tuning_octave')
            ival_ = self.gds_validate_integer(ival_, node, 'tuning_octave')
            self.tuning_octave = ival_
            self.tuning_octave_nsprefix_ = child_.prefix
            # validate type octave
            self.validate_octave(self.tuning_octave)
# end class staff_tuning


class time(GeneratedsSuper):
    """beats -- The beats element indicates the number of beats, as found in the numerator of a time signature.
    beat-type -- The beat-type element indicates the beat unit, as found in the denominator of a time signature.
    senza-misura -- A senza-misura element explicitly indicates that no time signature is present. The optional element content indicates the symbol to be used, if any, such as an X. The time element's symbol attribute is not used when a senza-misura element is present.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, symbol=None, separator=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, print_object=None, id=None, beats=None, beat_type=None, interchangeable=None, senza_misura=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.symbol = _cast(None, symbol)
        self.symbol_nsprefix_ = None
        self.separator = _cast(None, separator)
        self.separator_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if beats is None:
            self.beats = []
        else:
            self.beats = beats
        self.beats_nsprefix_ = None
        if beat_type is None:
            self.beat_type = []
        else:
            self.beat_type = beat_type
        self.beat_type_nsprefix_ = None
        self.interchangeable = interchangeable
        self.interchangeable_nsprefix_ = None
        self.senza_misura = senza_misura
        self.senza_misura_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, time)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if time.subclass:
            return time.subclass(*args_, **kwargs_)
        else:
            return time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_beats(self):
        return self.beats
    def set_beats(self, beats):
        self.beats = beats
    def add_beats(self, value):
        self.beats.append(value)
    def insert_beats_at(self, index, value):
        self.beats.insert(index, value)
    def replace_beats_at(self, index, value):
        self.beats[index] = value
    def get_beat_type(self):
        return self.beat_type
    def set_beat_type(self, beat_type):
        self.beat_type = beat_type
    def add_beat_type(self, value):
        self.beat_type.append(value)
    def insert_beat_type_at(self, index, value):
        self.beat_type.insert(index, value)
    def replace_beat_type_at(self, index, value):
        self.beat_type[index] = value
    def get_interchangeable(self):
        return self.interchangeable
    def set_interchangeable(self, interchangeable):
        self.interchangeable = interchangeable
    def get_senza_misura(self):
        return self.senza_misura
    def set_senza_misura(self, senza_misura):
        self.senza_misura = senza_misura
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_symbol(self):
        return self.symbol
    def set_symbol(self, symbol):
        self.symbol = symbol
    def get_separator(self):
        return self.separator
    def set_separator(self, separator):
        self.separator = separator
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_time_symbol(self, value):
        # Validate type time-symbol, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['common', 'cut', 'single-number', 'note', 'dotted-note', 'normal']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on time-symbol' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_time_separator(self, value):
        # Validate type time-separator, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'horizontal', 'diagonal', 'vertical', 'adjacent']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on time-separator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.beats or
            self.beat_type or
            self.interchangeable is not None or
            self.senza_misura is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='time', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('time')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'time':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='time')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='time', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='time'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.add('symbol')
            outfile.write(' symbol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.symbol), input_name='symbol')), ))
        if self.separator is not None and 'separator' not in already_processed:
            already_processed.add('separator')
            outfile.write(' separator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.separator), input_name='separator')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='time', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for beats_ in self.beats:
            namespaceprefix_ = self.beats_nsprefix_ + ':' if (UseCapturedNS_ and self.beats_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeats>%s</%sbeats>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(beats_), input_name='beats')), namespaceprefix_ , eol_))
        for beat_type_ in self.beat_type:
            namespaceprefix_ = self.beat_type_nsprefix_ + ':' if (UseCapturedNS_ and self.beat_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeat-type>%s</%sbeat-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(beat_type_), input_name='beat-type')), namespaceprefix_ , eol_))
        if self.interchangeable is not None:
            namespaceprefix_ = self.interchangeable_nsprefix_ + ':' if (UseCapturedNS_ and self.interchangeable_nsprefix_) else ''
            self.interchangeable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interchangeable', pretty_print=pretty_print)
        if self.senza_misura is not None:
            namespaceprefix_ = self.senza_misura_nsprefix_ + ':' if (UseCapturedNS_ and self.senza_misura_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssenza-misura>%s</%ssenza-misura>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.senza_misura), input_name='senza-misura')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.number)    # validate type staff-number
        value = find_attr_value_('symbol', node)
        if value is not None and 'symbol' not in already_processed:
            already_processed.add('symbol')
            self.symbol = value
            self.symbol = ' '.join(self.symbol.split())
            self.validate_time_symbol(self.symbol)    # validate type time-symbol
        value = find_attr_value_('separator', node)
        if value is not None and 'separator' not in already_processed:
            already_processed.add('separator')
            self.separator = value
            self.separator = ' '.join(self.separator.split())
            self.validate_time_separator(self.separator)    # validate type time-separator
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'beats':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'beats')
            value_ = self.gds_validate_string(value_, node, 'beats')
            self.beats.append(value_)
            self.beats_nsprefix_ = child_.prefix
        elif nodeName_ == 'beat-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'beat_type')
            value_ = self.gds_validate_string(value_, node, 'beat_type')
            self.beat_type.append(value_)
            self.beat_type_nsprefix_ = child_.prefix
        elif nodeName_ == 'interchangeable':
            obj_ = interchangeable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interchangeable = obj_
            obj_.original_tagname_ = 'interchangeable'
        elif nodeName_ == 'senza-misura':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'senza_misura')
            value_ = self.gds_validate_string(value_, node, 'senza_misura')
            self.senza_misura = value_
            self.senza_misura_nsprefix_ = child_.prefix
# end class time


class transpose(GeneratedsSuper):
    """diatonic -- The diatonic element specifies the number of pitch steps needed to go from written to sounding pitch. This allows for correct spelling of enharmonic transpositions. This value does not include octave-change values; the values for both elements need to be added to the written pitch to get the correct sounding pitch.
    chromatic -- The chromatic element represents the number of semitones needed to get from written to sounding pitch. This value does not include octave-change values; the values for both elements need to be added to the written pitch to get the correct sounding pitch.
    octave-change -- The octave-change element indicates how many octaves to add to get from written pitch to sounding pitch. The octave-change element should be included when using transposition intervals of an octave or more, and should not be present for intervals of less than an octave.
    double -- If the double element is present, it indicates that the music is doubled one octave from what is currently written.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, id=None, diatonic=None, chromatic=None, octave_change=None, double=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.diatonic = diatonic
        self.diatonic_nsprefix_ = None
        self.chromatic = chromatic
        self.validate_semitones(self.chromatic)
        self.chromatic_nsprefix_ = None
        self.octave_change = octave_change
        self.octave_change_nsprefix_ = None
        self.double = double
        self.double_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transpose)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transpose.subclass:
            return transpose.subclass(*args_, **kwargs_)
        else:
            return transpose(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_diatonic(self):
        return self.diatonic
    def set_diatonic(self, diatonic):
        self.diatonic = diatonic
    def get_chromatic(self):
        return self.chromatic
    def set_chromatic(self, chromatic):
        self.chromatic = chromatic
    def get_octave_change(self):
        return self.octave_change
    def set_octave_change(self, octave_change):
        self.octave_change = octave_change
    def get_double(self):
        return self.double
    def set_double(self, double):
        self.double = double
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.diatonic is not None or
            self.chromatic is not None or
            self.octave_change is not None or
            self.double is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='transpose', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transpose')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'transpose':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transpose')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transpose', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transpose'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='transpose', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.diatonic is not None:
            namespaceprefix_ = self.diatonic_nsprefix_ + ':' if (UseCapturedNS_ and self.diatonic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiatonic>%s</%sdiatonic>%s' % (namespaceprefix_ , self.gds_format_integer(self.diatonic, input_name='diatonic'), namespaceprefix_ , eol_))
        if self.chromatic is not None:
            namespaceprefix_ = self.chromatic_nsprefix_ + ':' if (UseCapturedNS_ and self.chromatic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schromatic>%s</%schromatic>%s' % (namespaceprefix_ , self.gds_format_decimal(self.chromatic, input_name='chromatic'), namespaceprefix_ , eol_))
        if self.octave_change is not None:
            namespaceprefix_ = self.octave_change_nsprefix_ + ':' if (UseCapturedNS_ and self.octave_change_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soctave-change>%s</%soctave-change>%s' % (namespaceprefix_ , self.gds_format_integer(self.octave_change, input_name='octave-change'), namespaceprefix_ , eol_))
        if self.double is not None:
            namespaceprefix_ = self.double_nsprefix_ + ':' if (UseCapturedNS_ and self.double_nsprefix_) else ''
            self.double.export(outfile, level, namespaceprefix_, namespacedef_='', name_='double', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.number)    # validate type staff-number
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'diatonic' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'diatonic')
            ival_ = self.gds_validate_integer(ival_, node, 'diatonic')
            self.diatonic = ival_
            self.diatonic_nsprefix_ = child_.prefix
        elif nodeName_ == 'chromatic' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'chromatic')
            fval_ = self.gds_validate_decimal(fval_, node, 'chromatic')
            self.chromatic = fval_
            self.chromatic_nsprefix_ = child_.prefix
            # validate type semitones
            self.validate_semitones(self.chromatic)
        elif nodeName_ == 'octave-change' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'octave_change')
            ival_ = self.gds_validate_integer(ival_, node, 'octave_change')
            self.octave_change = ival_
            self.octave_change_nsprefix_ = child_.prefix
        elif nodeName_ == 'double':
            obj_ = double.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.double = obj_
            obj_.original_tagname_ = 'double'
# end class transpose


class bar_style_color(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bar_style_color)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bar_style_color.subclass:
            return bar_style_color.subclass(*args_, **kwargs_)
        else:
            return bar_style_color(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bar_style(self, value):
        result = True
        # Validate type bar-style, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['regular', 'dotted', 'dashed', 'heavy', 'light-light', 'light-heavy', 'heavy-light', 'heavy-heavy', 'tick', 'short', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on bar-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bar-style-color', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bar-style-color')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bar-style-color':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bar-style-color')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bar-style-color', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bar-style-color'):
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bar-style-color', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class bar_style_color


class barline(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, location='right', segno_attr=None, coda_attr=None, divisions=None, id=None, bar_style=None, footnote=None, level=None, wavy_line=None, segno=None, coda=None, fermata=None, ending=None, repeat=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.location = _cast(None, location)
        self.location_nsprefix_ = None
        self.segno_attr = _cast(None, segno_attr)
        self.segno_attr_nsprefix_ = None
        self.coda_attr = _cast(None, coda_attr)
        self.coda_attr_nsprefix_ = None
        self.divisions = _cast(float, divisions)
        self.divisions_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.bar_style = bar_style
        self.bar_style_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
        self.wavy_line = wavy_line
        self.wavy_line_nsprefix_ = None
        self.segno = segno
        self.segno_nsprefix_ = None
        self.coda = coda
        self.coda_nsprefix_ = None
        if fermata is None:
            self.fermata = []
        else:
            self.fermata = fermata
        self.fermata_nsprefix_ = None
        self.ending = ending
        self.ending_nsprefix_ = None
        self.repeat = repeat
        self.repeat_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, barline)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if barline.subclass:
            return barline.subclass(*args_, **kwargs_)
        else:
            return barline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_bar_style(self):
        return self.bar_style
    def set_bar_style(self, bar_style):
        self.bar_style = bar_style
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_wavy_line(self):
        return self.wavy_line
    def set_wavy_line(self, wavy_line):
        self.wavy_line = wavy_line
    def get_segno(self):
        return self.segno
    def set_segno(self, segno):
        self.segno = segno
    def get_coda(self):
        return self.coda
    def set_coda(self, coda):
        self.coda = coda
    def get_fermata(self):
        return self.fermata
    def set_fermata(self, fermata):
        self.fermata = fermata
    def add_fermata(self, value):
        self.fermata.append(value)
    def insert_fermata_at(self, index, value):
        self.fermata.insert(index, value)
    def replace_fermata_at(self, index, value):
        self.fermata[index] = value
    def get_ending(self):
        return self.ending
    def set_ending(self, ending):
        self.ending = ending
    def get_repeat(self):
        return self.repeat
    def set_repeat(self, repeat):
        self.repeat = repeat
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_segno_attr(self):
        return self.segno_attr
    def set_segno_attr(self, segno_attr):
        self.segno_attr = segno_attr
    def get_coda_attr(self):
        return self.coda_attr
    def set_coda_attr(self, coda_attr):
        self.coda_attr = coda_attr
    def get_divisions(self):
        return self.divisions
    def set_divisions(self, divisions):
        self.divisions = divisions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_right_left_middle(self, value):
        # Validate type right-left-middle, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['right', 'left', 'middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on right-left-middle' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.bar_style is not None or
            self.footnote is not None or
            self.level is not None or
            self.wavy_line is not None or
            self.segno is not None or
            self.coda is not None or
            self.fermata or
            self.ending is not None or
            self.repeat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='barline', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('barline')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'barline':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='barline')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='barline', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='barline'):
        if self.location != "right" and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.location), input_name='location')), ))
        if self.segno_attr is not None and 'segno_attr' not in already_processed:
            already_processed.add('segno_attr')
            outfile.write(' segno=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segno_attr), input_name='segno_attr')), ))
        if self.coda_attr is not None and 'coda_attr' not in already_processed:
            already_processed.add('coda_attr')
            outfile.write(' coda=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coda_attr), input_name='coda_attr')), ))
        if self.divisions is not None and 'divisions' not in already_processed:
            already_processed.add('divisions')
            outfile.write(' divisions="%s"' % self.gds_format_decimal(self.divisions, input_name='divisions'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='barline', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bar_style is not None:
            namespaceprefix_ = self.bar_style_nsprefix_ + ':' if (UseCapturedNS_ and self.bar_style_nsprefix_) else ''
            self.bar_style.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bar-style', pretty_print=pretty_print)
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
        if self.wavy_line is not None:
            namespaceprefix_ = self.wavy_line_nsprefix_ + ':' if (UseCapturedNS_ and self.wavy_line_nsprefix_) else ''
            self.wavy_line.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wavy-line', pretty_print=pretty_print)
        if self.segno is not None:
            namespaceprefix_ = self.segno_nsprefix_ + ':' if (UseCapturedNS_ and self.segno_nsprefix_) else ''
            self.segno.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segno', pretty_print=pretty_print)
        if self.coda is not None:
            namespaceprefix_ = self.coda_nsprefix_ + ':' if (UseCapturedNS_ and self.coda_nsprefix_) else ''
            self.coda.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coda', pretty_print=pretty_print)
        for fermata_ in self.fermata:
            namespaceprefix_ = self.fermata_nsprefix_ + ':' if (UseCapturedNS_ and self.fermata_nsprefix_) else ''
            fermata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fermata', pretty_print=pretty_print)
        if self.ending is not None:
            namespaceprefix_ = self.ending_nsprefix_ + ':' if (UseCapturedNS_ and self.ending_nsprefix_) else ''
            self.ending.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ending', pretty_print=pretty_print)
        if self.repeat is not None:
            namespaceprefix_ = self.repeat_nsprefix_ + ':' if (UseCapturedNS_ and self.repeat_nsprefix_) else ''
            self.repeat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeat', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
            self.location = ' '.join(self.location.split())
            self.validate_right_left_middle(self.location)    # validate type right-left-middle
        value = find_attr_value_('segno', node)
        if value is not None and 'segno_attr' not in already_processed:
            already_processed.add('segno_attr')
            self.segno_attr = value
            self.segno_attr = ' '.join(self.segno_attr.split())
        value = find_attr_value_('coda', node)
        if value is not None and 'coda_attr' not in already_processed:
            already_processed.add('coda_attr')
            self.coda_attr = value
            self.coda_attr = ' '.join(self.coda_attr.split())
        value = find_attr_value_('divisions', node)
        if value is not None and 'divisions' not in already_processed:
            already_processed.add('divisions')
            value = self.gds_parse_decimal(value, node, 'divisions')
            self.divisions = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'bar-style':
            obj_ = bar_style_color.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bar_style = obj_
            obj_.original_tagname_ = 'bar-style'
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
        elif nodeName_ == 'wavy-line':
            obj_ = wavy_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wavy_line = obj_
            obj_.original_tagname_ = 'wavy-line'
        elif nodeName_ == 'segno':
            obj_ = segno.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segno = obj_
            obj_.original_tagname_ = 'segno'
        elif nodeName_ == 'coda':
            obj_ = coda.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coda = obj_
            obj_.original_tagname_ = 'coda'
        elif nodeName_ == 'fermata':
            obj_ = fermata.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fermata.append(obj_)
            obj_.original_tagname_ = 'fermata'
        elif nodeName_ == 'ending':
            obj_ = ending.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ending = obj_
            obj_.original_tagname_ = 'ending'
        elif nodeName_ == 'repeat':
            obj_ = repeat.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeat = obj_
            obj_.original_tagname_ = 'repeat'
# end class barline


class ending(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, type_=None, end_length=None, text_x=None, text_y=None, print_object=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.end_length = _cast(float, end_length)
        self.end_length_nsprefix_ = None
        self.text_x = _cast(float, text_x)
        self.text_x_nsprefix_ = None
        self.text_y = _cast(float, text_y)
        self.text_y_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ending)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ending.subclass:
            return ending.subclass(*args_, **kwargs_)
        else:
            return ending(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_end_length(self):
        return self.end_length
    def set_end_length(self, end_length):
        self.end_length = end_length
    def get_text_x(self):
        return self.text_x
    def set_text_x(self, text_x):
        self.text_x = text_x
    def get_text_y(self):
        return self.text_y
    def set_text_y(self, text_y):
        self.text_y = text_y
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_ending_number(self, value):
        # Validate type ending-number, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ending_number_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ending_number_patterns_, ))
    validate_ending_number_patterns_ = [['^(([ ]*)|([1-9][0-9]*(, ?[1-9][0-9]*)*))$']]
    def validate_start_stop_discontinue(self, value):
        # Validate type start-stop-discontinue, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'discontinue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-discontinue' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_system_relation(self, value):
        # Validate type system-relation, a restriction on system-relation-number.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['only-top', 'also-top', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on system-relation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['only-top', 'only-bottom', 'also-top', 'also-bottom', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on system-relation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ending', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ending')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ending':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ending')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ending', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ending'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.number), input_name='number')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.end_length is not None and 'end_length' not in already_processed:
            already_processed.add('end_length')
            outfile.write(' end-length="%s"' % self.gds_format_decimal(self.end_length, input_name='end-length'))
        if self.text_x is not None and 'text_x' not in already_processed:
            already_processed.add('text_x')
            outfile.write(' text-x="%s"' % self.gds_format_decimal(self.text_x, input_name='text-x'))
        if self.text_y is not None and 'text_y' not in already_processed:
            already_processed.add('text_y')
            outfile.write(' text-y="%s"' % self.gds_format_decimal(self.text_y, input_name='text-y'))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ending', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
            self.number = ' '.join(self.number.split())
            self.validate_ending_number(self.number)    # validate type ending-number
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_discontinue(self.type_)    # validate type start-stop-discontinue
        value = find_attr_value_('end-length', node)
        if value is not None and 'end-length' not in already_processed:
            already_processed.add('end-length')
            value = self.gds_parse_decimal(value, node, 'end-length')
            self.end_length = value
        value = find_attr_value_('text-x', node)
        if value is not None and 'text-x' not in already_processed:
            already_processed.add('text-x')
            value = self.gds_parse_decimal(value, node, 'text-x')
            self.text_x = value
        value = find_attr_value_('text-y', node)
        if value is not None and 'text-y' not in already_processed:
            already_processed.add('text-y')
            value = self.gds_parse_decimal(value, node, 'text-y')
            self.text_y = value
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_system_relation(self.system)    # validate type system-relation
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ending


class repeat(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, direction=None, times=None, after_jump=None, winged=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
        self.times = _cast(int, times)
        self.times_nsprefix_ = None
        self.after_jump = _cast(None, after_jump)
        self.after_jump_nsprefix_ = None
        self.winged = _cast(None, winged)
        self.winged_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, repeat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if repeat.subclass:
            return repeat.subclass(*args_, **kwargs_)
        else:
            return repeat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_times(self):
        return self.times
    def set_times(self, times):
        self.times = times
    def get_after_jump(self):
        return self.after_jump
    def set_after_jump(self, after_jump):
        self.after_jump = after_jump
    def get_winged(self):
        return self.winged
    def set_winged(self, winged):
        self.winged = winged
    def validate_backward_forward(self, value):
        # Validate type backward-forward, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['backward', 'forward']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on backward-forward' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_winged(self, value):
        # Validate type winged, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'straight', 'curved', 'double-straight', 'double-curved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on winged' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='repeat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('repeat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'repeat':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='repeat')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='repeat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='repeat'):
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
        if self.times is not None and 'times' not in already_processed:
            already_processed.add('times')
            outfile.write(' times="%s"' % self.gds_format_integer(self.times, input_name='times'))
        if self.after_jump is not None and 'after_jump' not in already_processed:
            already_processed.add('after_jump')
            outfile.write(' after-jump=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.after_jump), input_name='after-jump')), ))
        if self.winged is not None and 'winged' not in already_processed:
            already_processed.add('winged')
            outfile.write(' winged=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.winged), input_name='winged')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='repeat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
            self.direction = ' '.join(self.direction.split())
            self.validate_backward_forward(self.direction)    # validate type backward-forward
        value = find_attr_value_('times', node)
        if value is not None and 'times' not in already_processed:
            already_processed.add('times')
            self.times = self.gds_parse_integer(value, node, 'times')
            if self.times < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('after-jump', node)
        if value is not None and 'after-jump' not in already_processed:
            already_processed.add('after-jump')
            self.after_jump = value
            self.after_jump = ' '.join(self.after_jump.split())
            self.validate_yes_no(self.after_jump)    # validate type yes-no
        value = find_attr_value_('winged', node)
        if value is not None and 'winged' not in already_processed:
            already_processed.add('winged')
            self.winged = value
            self.winged = ' '.join(self.winged.split())
            self.validate_winged(self.winged)    # validate type winged
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class repeat


class accord(GeneratedsSuper):
    """tuning-step -- The tuning-step element is represented like the step element, with a different name to reflect its different function in string tuning.
    tuning-alter -- The tuning-alter element is represented like the alter element, with a different name to reflect its different function in string tuning.
    tuning-octave -- The tuning-octave element is represented like the octave element, with a different name to reflect its different function in string tuning.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, string=None, tuning_step=None, tuning_alter=None, tuning_octave=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.string = _cast(int, string)
        self.string_nsprefix_ = None
        self.tuning_step = tuning_step
        self.validate_step(self.tuning_step)
        self.tuning_step_nsprefix_ = None
        self.tuning_alter = tuning_alter
        self.validate_semitones(self.tuning_alter)
        self.tuning_alter_nsprefix_ = None
        self.tuning_octave = tuning_octave
        self.validate_octave(self.tuning_octave)
        self.tuning_octave_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accord.subclass:
            return accord.subclass(*args_, **kwargs_)
        else:
            return accord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tuning_step(self):
        return self.tuning_step
    def set_tuning_step(self, tuning_step):
        self.tuning_step = tuning_step
    def get_tuning_alter(self):
        return self.tuning_alter
    def set_tuning_alter(self, tuning_alter):
        self.tuning_alter = tuning_alter
    def get_tuning_octave(self):
        return self.tuning_octave
    def set_tuning_octave(self, tuning_octave):
        self.tuning_octave = tuning_octave
    def get_string(self):
        return self.string
    def set_string(self, string):
        self.string = string
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_octave(self, value):
        result = True
        # Validate type octave, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
            if value > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_string_number(self, value):
        # Validate type string-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.tuning_step is not None or
            self.tuning_alter is not None or
            self.tuning_octave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accord', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accord':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accord')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accord'):
        if self.string is not None and 'string' not in already_processed:
            already_processed.add('string')
            outfile.write(' string="%s"' % self.gds_format_integer(self.string, input_name='string'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tuning_step is not None:
            namespaceprefix_ = self.tuning_step_nsprefix_ + ':' if (UseCapturedNS_ and self.tuning_step_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stuning-step>%s</%stuning-step>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tuning_step), input_name='tuning-step')), namespaceprefix_ , eol_))
        if self.tuning_alter is not None:
            namespaceprefix_ = self.tuning_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.tuning_alter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stuning-alter>%s</%stuning-alter>%s' % (namespaceprefix_ , self.gds_format_decimal(self.tuning_alter, input_name='tuning-alter'), namespaceprefix_ , eol_))
        if self.tuning_octave is not None:
            namespaceprefix_ = self.tuning_octave_nsprefix_ + ':' if (UseCapturedNS_ and self.tuning_octave_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stuning-octave>%s</%stuning-octave>%s' % (namespaceprefix_ , self.gds_format_integer(self.tuning_octave, input_name='tuning-octave'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('string', node)
        if value is not None and 'string' not in already_processed:
            already_processed.add('string')
            self.string = self.gds_parse_integer(value, node, 'string')
            if self.string <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_string_number(self.string)    # validate type string-number
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tuning-step':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tuning_step')
            value_ = self.gds_validate_string(value_, node, 'tuning_step')
            self.tuning_step = value_
            self.tuning_step_nsprefix_ = child_.prefix
            # validate type step
            self.validate_step(self.tuning_step)
        elif nodeName_ == 'tuning-alter' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'tuning_alter')
            fval_ = self.gds_validate_decimal(fval_, node, 'tuning_alter')
            self.tuning_alter = fval_
            self.tuning_alter_nsprefix_ = child_.prefix
            # validate type semitones
            self.validate_semitones(self.tuning_alter)
        elif nodeName_ == 'tuning-octave' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'tuning_octave')
            ival_ = self.gds_validate_integer(ival_, node, 'tuning_octave')
            self.tuning_octave = ival_
            self.tuning_octave_nsprefix_ = child_.prefix
            # validate type octave
            self.validate_octave(self.tuning_octave)
# end class accord


class accordion_registration(GeneratedsSuper):
    """accordion-high -- The accordion-high element indicates the presence of a dot in the high (4') section of the registration symbol. This element is omitted if no dot is present.
    accordion-middle -- The accordion-middle element indicates the presence of 1 to 3 dots in the middle (8') section of the registration symbol. This element is omitted if no dots are present.
    accordion-low -- The accordion-low element indicates the presence of a dot in the low (16') section of the registration symbol. This element is omitted if no dot is present.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, accordion_high=None, accordion_middle=None, accordion_low=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.accordion_high = accordion_high
        self.accordion_high_nsprefix_ = None
        self.accordion_middle = accordion_middle
        self.validate_accordion_middle(self.accordion_middle)
        self.accordion_middle_nsprefix_ = None
        self.accordion_low = accordion_low
        self.accordion_low_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accordion_registration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accordion_registration.subclass:
            return accordion_registration.subclass(*args_, **kwargs_)
        else:
            return accordion_registration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accordion_high(self):
        return self.accordion_high
    def set_accordion_high(self, accordion_high):
        self.accordion_high = accordion_high
    def get_accordion_middle(self):
        return self.accordion_middle
    def set_accordion_middle(self, accordion_middle):
        self.accordion_middle = accordion_middle
    def get_accordion_low(self):
        return self.accordion_low
    def set_accordion_low(self, accordion_low):
        self.accordion_low = accordion_low
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_accordion_middle(self, value):
        result = True
        # Validate type accordion-middle, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on accordion-middle' % {"value": value, "lineno": lineno} )
                result = False
            if value > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on accordion-middle' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.accordion_high is not None or
            self.accordion_middle is not None or
            self.accordion_low is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accordion-registration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accordion-registration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accordion-registration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accordion-registration')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accordion-registration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accordion-registration'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accordion-registration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accordion_high is not None:
            namespaceprefix_ = self.accordion_high_nsprefix_ + ':' if (UseCapturedNS_ and self.accordion_high_nsprefix_) else ''
            self.accordion_high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accordion-high', pretty_print=pretty_print)
        if self.accordion_middle is not None:
            namespaceprefix_ = self.accordion_middle_nsprefix_ + ':' if (UseCapturedNS_ and self.accordion_middle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccordion-middle>%s</%saccordion-middle>%s' % (namespaceprefix_ , self.gds_format_integer(self.accordion_middle, input_name='accordion-middle'), namespaceprefix_ , eol_))
        if self.accordion_low is not None:
            namespaceprefix_ = self.accordion_low_nsprefix_ + ':' if (UseCapturedNS_ and self.accordion_low_nsprefix_) else ''
            self.accordion_low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accordion-low', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accordion-high':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accordion_high = obj_
            obj_.original_tagname_ = 'accordion-high'
        elif nodeName_ == 'accordion-middle' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'accordion_middle')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'accordion_middle')
            self.accordion_middle = ival_
            self.accordion_middle_nsprefix_ = child_.prefix
            # validate type accordion-middle
            self.validate_accordion_middle(self.accordion_middle)
        elif nodeName_ == 'accordion-low':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accordion_low = obj_
            obj_.original_tagname_ = 'accordion-low'
# end class accordion_registration


class barre(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, color=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, barre)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if barre.subclass:
            return barre.subclass(*args_, **kwargs_)
        else:
            return barre(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='barre', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('barre')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'barre':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='barre')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='barre', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='barre'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='barre', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class barre


class bass(GeneratedsSuper):
    """bass-separator -- The optional bass-separator element indicates that text, rather than a line or slash, separates the bass from what precedes it.
    bass-alter -- The bass-alter element represents the chromatic alteration of the bass of the current chord within the harmony element. In some chord styles, the text for the bass-step element may include bass-alter information. In that case, the print-object attribute of the bass-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the bass-step; it is right if not specified.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, arrangement=None, bass_separator=None, bass_step=None, bass_alter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.arrangement = _cast(None, arrangement)
        self.arrangement_nsprefix_ = None
        self.bass_separator = bass_separator
        self.bass_separator_nsprefix_ = None
        self.bass_step = bass_step
        self.bass_step_nsprefix_ = None
        self.bass_alter = bass_alter
        self.bass_alter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bass.subclass:
            return bass.subclass(*args_, **kwargs_)
        else:
            return bass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_bass_separator(self):
        return self.bass_separator
    def set_bass_separator(self, bass_separator):
        self.bass_separator = bass_separator
    def get_bass_step(self):
        return self.bass_step
    def set_bass_step(self, bass_step):
        self.bass_step = bass_step
    def get_bass_alter(self):
        return self.bass_alter
    def set_bass_alter(self, bass_alter):
        self.bass_alter = bass_alter
    def get_arrangement(self):
        return self.arrangement
    def set_arrangement(self, arrangement):
        self.arrangement = arrangement
    def validate_harmony_arrangement(self, value):
        # Validate type harmony-arrangement, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['vertical', 'horizontal', 'diagonal']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on harmony-arrangement' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.bass_separator is not None or
            self.bass_step is not None or
            self.bass_alter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bass', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bass')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bass':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bass')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bass', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bass'):
        if self.arrangement is not None and 'arrangement' not in already_processed:
            already_processed.add('arrangement')
            outfile.write(' arrangement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arrangement), input_name='arrangement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bass', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bass_separator is not None:
            namespaceprefix_ = self.bass_separator_nsprefix_ + ':' if (UseCapturedNS_ and self.bass_separator_nsprefix_) else ''
            self.bass_separator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bass-separator', pretty_print=pretty_print)
        if self.bass_step is not None:
            namespaceprefix_ = self.bass_step_nsprefix_ + ':' if (UseCapturedNS_ and self.bass_step_nsprefix_) else ''
            self.bass_step.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bass-step', pretty_print=pretty_print)
        if self.bass_alter is not None:
            namespaceprefix_ = self.bass_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.bass_alter_nsprefix_) else ''
            self.bass_alter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bass-alter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arrangement', node)
        if value is not None and 'arrangement' not in already_processed:
            already_processed.add('arrangement')
            self.arrangement = value
            self.arrangement = ' '.join(self.arrangement.split())
            self.validate_harmony_arrangement(self.arrangement)    # validate type harmony-arrangement
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'bass-separator':
            obj_ = style_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bass_separator = obj_
            obj_.original_tagname_ = 'bass-separator'
        elif nodeName_ == 'bass-step':
            obj_ = bass_step.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bass_step = obj_
            obj_.original_tagname_ = 'bass-step'
        elif nodeName_ == 'bass-alter':
            obj_ = harmony_alter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bass_alter = obj_
            obj_.original_tagname_ = 'bass-alter'
# end class bass


class harmony_alter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, location=None, print_object=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.location = _cast(None, location)
        self.location_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, harmony_alter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if harmony_alter.subclass:
            return harmony_alter.subclass(*args_, **kwargs_)
        else:
            return harmony_alter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_left_right(self, value):
        # Validate type left-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmony-alter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('harmony-alter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'harmony-alter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='harmony-alter')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='harmony-alter', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='harmony-alter'):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.location), input_name='location')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmony-alter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
            self.location = ' '.join(self.location.split())
            self.validate_left_right(self.location)    # validate type left-right
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class harmony_alter


class bass_step(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, text=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bass_step)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bass_step.subclass:
            return bass_step.subclass(*args_, **kwargs_)
        else:
            return bass_step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bass-step', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bass-step')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bass-step':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bass-step')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bass-step', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bass-step'):
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bass-step', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class bass_step


class beater(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tip=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tip = _cast(None, tip)
        self.tip_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, beater)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if beater.subclass:
            return beater.subclass(*args_, **kwargs_)
        else:
            return beater(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tip(self):
        return self.tip
    def set_tip(self, tip):
        self.tip = tip
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_beater_value(self, value):
        result = True
        # Validate type beater-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['bow', 'chime hammer', 'coin', 'drum stick', 'finger', 'fingernail', 'fist', 'guiro scraper', 'hammer', 'hand', 'jazz stick', 'knitting needle', 'metal hammer', 'slide brush on gong', 'snare stick', 'spoon mallet', 'superball', 'triangle beater', 'triangle beater plain', 'wire brush']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on beater-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tip_direction(self, value):
        # Validate type tip-direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['up', 'down', 'left', 'right', 'northwest', 'northeast', 'southeast', 'southwest']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tip-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='beater', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('beater')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'beater':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='beater')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='beater', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='beater'):
        if self.tip is not None and 'tip' not in already_processed:
            already_processed.add('tip')
            outfile.write(' tip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tip), input_name='tip')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='beater', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tip', node)
        if value is not None and 'tip' not in already_processed:
            already_processed.add('tip')
            self.tip = value
            self.validate_tip_direction(self.tip)    # validate type tip-direction
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class beater


class beat_unit_tied(GeneratedsSuper):
    """beat-unit -- The beat-unit element indicates the graphical note type to use in a metronome mark.
    beat-unit-dot -- The beat-unit-dot element is used to specify any augmentation dots for a metronome mark note.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, beat_unit=None, beat_unit_dot=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.beat_unit = beat_unit
        self.validate_note_type_value(self.beat_unit)
        self.beat_unit_nsprefix_ = None
        if beat_unit_dot is None:
            self.beat_unit_dot = []
        else:
            self.beat_unit_dot = beat_unit_dot
        self.beat_unit_dot_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, beat_unit_tied)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if beat_unit_tied.subclass:
            return beat_unit_tied.subclass(*args_, **kwargs_)
        else:
            return beat_unit_tied(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_beat_unit(self):
        return self.beat_unit
    def set_beat_unit(self, beat_unit):
        self.beat_unit = beat_unit
    def get_beat_unit_dot(self):
        return self.beat_unit_dot
    def set_beat_unit_dot(self, beat_unit_dot):
        self.beat_unit_dot = beat_unit_dot
    def add_beat_unit_dot(self, value):
        self.beat_unit_dot.append(value)
    def insert_beat_unit_dot_at(self, index, value):
        self.beat_unit_dot.insert(index, value)
    def replace_beat_unit_dot_at(self, index, value):
        self.beat_unit_dot[index] = value
    def validate_note_type_value(self, value):
        result = True
        # Validate type note-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.beat_unit is not None or
            self.beat_unit_dot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='beat-unit-tied', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('beat-unit-tied')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'beat-unit-tied':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='beat-unit-tied')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='beat-unit-tied', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='beat-unit-tied'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='beat-unit-tied', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.beat_unit is not None:
            namespaceprefix_ = self.beat_unit_nsprefix_ + ':' if (UseCapturedNS_ and self.beat_unit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeat-unit>%s</%sbeat-unit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.beat_unit), input_name='beat-unit')), namespaceprefix_ , eol_))
        for beat_unit_dot_ in self.beat_unit_dot:
            namespaceprefix_ = self.beat_unit_dot_nsprefix_ + ':' if (UseCapturedNS_ and self.beat_unit_dot_nsprefix_) else ''
            beat_unit_dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='beat-unit-dot', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'beat-unit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'beat_unit')
            value_ = self.gds_validate_string(value_, node, 'beat_unit')
            self.beat_unit = value_
            self.beat_unit_nsprefix_ = child_.prefix
            # validate type note-type-value
            self.validate_note_type_value(self.beat_unit)
        elif nodeName_ == 'beat-unit-dot':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.beat_unit_dot.append(obj_)
            obj_.original_tagname_ = 'beat-unit-dot'
# end class beat_unit_tied


class bracket(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, line_end=None, end_length=None, line_type=None, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, color=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.line_end = _cast(None, line_end)
        self.line_end_nsprefix_ = None
        self.end_length = _cast(float, end_length)
        self.end_length_nsprefix_ = None
        self.line_type = _cast(None, line_type)
        self.line_type_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bracket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bracket.subclass:
            return bracket.subclass(*args_, **kwargs_)
        else:
            return bracket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_line_end(self):
        return self.line_end
    def set_line_end(self, line_end):
        self.line_end = line_end
    def get_end_length(self):
        return self.end_length
    def set_end_length(self, end_length):
        self.end_length = end_length
    def get_line_type(self):
        return self.line_type
    def set_line_type(self, line_type):
        self.line_type = line_type
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_start_stop_continue(self, value):
        # Validate type start-stop-continue, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'continue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-continue' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_line_end(self, value):
        # Validate type line-end, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['up', 'down', 'both', 'arrow', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-end' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_line_type(self, value):
        # Validate type line-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['solid', 'dashed', 'dotted', 'wavy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bracket', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bracket')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bracket':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bracket')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bracket', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bracket'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.line_end is not None and 'line_end' not in already_processed:
            already_processed.add('line_end')
            outfile.write(' line-end=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_end), input_name='line-end')), ))
        if self.end_length is not None and 'end_length' not in already_processed:
            already_processed.add('end_length')
            outfile.write(' end-length="%s"' % self.gds_format_decimal(self.end_length, input_name='end-length'))
        if self.line_type is not None and 'line_type' not in already_processed:
            already_processed.add('line_type')
            outfile.write(' line-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_type), input_name='line-type')), ))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bracket', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_continue(self.type_)    # validate type start-stop-continue
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('line-end', node)
        if value is not None and 'line-end' not in already_processed:
            already_processed.add('line-end')
            self.line_end = value
            self.line_end = ' '.join(self.line_end.split())
            self.validate_line_end(self.line_end)    # validate type line-end
        value = find_attr_value_('end-length', node)
        if value is not None and 'end-length' not in already_processed:
            already_processed.add('end-length')
            value = self.gds_parse_decimal(value, node, 'end-length')
            self.end_length = value
        value = find_attr_value_('line-type', node)
        if value is not None and 'line-type' not in already_processed:
            already_processed.add('line-type')
            self.line_type = value
            self.line_type = ' '.join(self.line_type.split())
            self.validate_line_type(self.line_type)    # validate type line-type
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class bracket


class dashes(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, color=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dashes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dashes.subclass:
            return dashes.subclass(*args_, **kwargs_)
        else:
            return dashes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_start_stop_continue(self, value):
        # Validate type start-stop-continue, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'continue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-continue' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dashes', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dashes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dashes':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dashes')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dashes', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dashes'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dashes', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_continue(self.type_)    # validate type start-stop-continue
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dashes


class degree(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, print_object=None, degree_value=None, degree_alter=None, degree_type=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.degree_value = degree_value
        self.degree_value_nsprefix_ = None
        self.degree_alter = degree_alter
        self.degree_alter_nsprefix_ = None
        self.degree_type = degree_type
        self.degree_type_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, degree)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if degree.subclass:
            return degree.subclass(*args_, **kwargs_)
        else:
            return degree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_degree_value(self):
        return self.degree_value
    def set_degree_value(self, degree_value):
        self.degree_value = degree_value
    def get_degree_alter(self):
        return self.degree_alter
    def set_degree_alter(self, degree_alter):
        self.degree_alter = degree_alter
    def get_degree_type(self):
        return self.degree_type
    def set_degree_type(self, degree_type):
        self.degree_type = degree_type
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.degree_value is not None or
            self.degree_alter is not None or
            self.degree_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='degree', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('degree')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'degree':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='degree')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='degree', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='degree'):
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='degree', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.degree_value is not None:
            namespaceprefix_ = self.degree_value_nsprefix_ + ':' if (UseCapturedNS_ and self.degree_value_nsprefix_) else ''
            self.degree_value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='degree-value', pretty_print=pretty_print)
        if self.degree_alter is not None:
            namespaceprefix_ = self.degree_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.degree_alter_nsprefix_) else ''
            self.degree_alter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='degree-alter', pretty_print=pretty_print)
        if self.degree_type is not None:
            namespaceprefix_ = self.degree_type_nsprefix_ + ':' if (UseCapturedNS_ and self.degree_type_nsprefix_) else ''
            self.degree_type.export(outfile, level, namespaceprefix_, namespacedef_='', name_='degree-type', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'degree-value':
            obj_ = degree_value.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.degree_value = obj_
            obj_.original_tagname_ = 'degree-value'
        elif nodeName_ == 'degree-alter':
            obj_ = degree_alter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.degree_alter = obj_
            obj_.original_tagname_ = 'degree-alter'
        elif nodeName_ == 'degree-type':
            obj_ = degree_type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.degree_type = obj_
            obj_.original_tagname_ = 'degree-type'
# end class degree


class degree_alter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, plus_minus=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.plus_minus = _cast(None, plus_minus)
        self.plus_minus_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, degree_alter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if degree_alter.subclass:
            return degree_alter.subclass(*args_, **kwargs_)
        else:
            return degree_alter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_plus_minus(self):
        return self.plus_minus
    def set_plus_minus(self, plus_minus):
        self.plus_minus = plus_minus
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='degree-alter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('degree-alter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'degree-alter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='degree-alter')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='degree-alter', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='degree-alter'):
        if self.plus_minus is not None and 'plus_minus' not in already_processed:
            already_processed.add('plus_minus')
            outfile.write(' plus-minus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.plus_minus), input_name='plus-minus')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='degree-alter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('plus-minus', node)
        if value is not None and 'plus-minus' not in already_processed:
            already_processed.add('plus-minus')
            self.plus_minus = value
            self.plus_minus = ' '.join(self.plus_minus.split())
            self.validate_yes_no(self.plus_minus)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class degree_alter


class degree_type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, text=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, degree_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if degree_type.subclass:
            return degree_type.subclass(*args_, **kwargs_)
        else:
            return degree_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_degree_type_value(self, value):
        result = True
        # Validate type degree-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['add', 'alter', 'subtract']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on degree-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='degree-type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('degree-type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'degree-type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='degree-type')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='degree-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='degree-type'):
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='degree-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class degree_type


class degree_value(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, symbol=None, text=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.symbol = _cast(None, symbol)
        self.symbol_nsprefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, degree_value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if degree_value.subclass:
            return degree_value.subclass(*args_, **kwargs_)
        else:
            return degree_value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_symbol(self):
        return self.symbol
    def set_symbol(self, symbol):
        self.symbol = symbol
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_degree_symbol_value(self, value):
        # Validate type degree-symbol-value, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['major', 'minor', 'augmented', 'diminished', 'half-diminished']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on degree-symbol-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='degree-value', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('degree-value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'degree-value':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='degree-value')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='degree-value', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='degree-value'):
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.add('symbol')
            outfile.write(' symbol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.symbol), input_name='symbol')), ))
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='degree-value', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('symbol', node)
        if value is not None and 'symbol' not in already_processed:
            already_processed.add('symbol')
            self.symbol = value
            self.symbol = ' '.join(self.symbol.split())
            self.validate_degree_symbol_value(self.symbol)    # validate type degree-symbol-value
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class degree_value


class direction(GeneratedsSuper):
    """staff -- Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, placement=None, directive=None, system=None, id=None, direction_type=None, offset=None, footnote=None, level=None, voice=None, staff=None, sound=None, listening=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.directive = _cast(None, directive)
        self.directive_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if direction_type is None:
            self.direction_type = []
        else:
            self.direction_type = direction_type
        self.direction_type_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
        self.voice = voice
        self.voice_nsprefix_ = None
        self.staff = staff
        self.staff_nsprefix_ = None
        self.sound = sound
        self.sound_nsprefix_ = None
        self.listening = listening
        self.listening_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, direction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if direction.subclass:
            return direction.subclass(*args_, **kwargs_)
        else:
            return direction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_direction_type(self):
        return self.direction_type
    def set_direction_type(self, direction_type):
        self.direction_type = direction_type
    def add_direction_type(self, value):
        self.direction_type.append(value)
    def insert_direction_type_at(self, index, value):
        self.direction_type.insert(index, value)
    def replace_direction_type_at(self, index, value):
        self.direction_type[index] = value
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_voice(self):
        return self.voice
    def set_voice(self, voice):
        self.voice = voice
    def get_staff(self):
        return self.staff
    def set_staff(self, staff):
        self.staff = staff
    def get_sound(self):
        return self.sound
    def set_sound(self, sound):
        self.sound = sound
    def get_listening(self):
        return self.listening
    def set_listening(self, listening):
        self.listening = listening
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_directive(self):
        return self.directive
    def set_directive(self, directive):
        self.directive = directive
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_system_relation(self, value):
        # Validate type system-relation, a restriction on system-relation-number.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['only-top', 'also-top', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on system-relation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['only-top', 'only-bottom', 'also-top', 'also-bottom', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on system-relation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.direction_type or
            self.offset is not None or
            self.footnote is not None or
            self.level is not None or
            self.voice is not None or
            self.staff is not None or
            self.sound is not None or
            self.listening is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='direction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('direction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'direction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='direction')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='direction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='direction'):
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.directive is not None and 'directive' not in already_processed:
            already_processed.add('directive')
            outfile.write(' directive=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.directive), input_name='directive')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='direction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for direction_type_ in self.direction_type:
            namespaceprefix_ = self.direction_type_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_type_nsprefix_) else ''
            direction_type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='direction-type', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
        if self.voice is not None:
            namespaceprefix_ = self.voice_nsprefix_ + ':' if (UseCapturedNS_ and self.voice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svoice>%s</%svoice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.voice), input_name='voice')), namespaceprefix_ , eol_))
        if self.staff is not None:
            namespaceprefix_ = self.staff_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaff>%s</%sstaff>%s' % (namespaceprefix_ , self.gds_format_integer(self.staff, input_name='staff'), namespaceprefix_ , eol_))
        if self.sound is not None:
            namespaceprefix_ = self.sound_nsprefix_ + ':' if (UseCapturedNS_ and self.sound_nsprefix_) else ''
            self.sound.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sound', pretty_print=pretty_print)
        if self.listening is not None:
            namespaceprefix_ = self.listening_nsprefix_ + ':' if (UseCapturedNS_ and self.listening_nsprefix_) else ''
            self.listening.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listening', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('directive', node)
        if value is not None and 'directive' not in already_processed:
            already_processed.add('directive')
            self.directive = value
            self.directive = ' '.join(self.directive.split())
            self.validate_yes_no(self.directive)    # validate type yes-no
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_system_relation(self.system)    # validate type system-relation
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'direction-type':
            obj_ = direction_type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.direction_type.append(obj_)
            obj_.original_tagname_ = 'direction-type'
        elif nodeName_ == 'offset':
            obj_ = offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
        elif nodeName_ == 'voice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'voice')
            value_ = self.gds_validate_string(value_, node, 'voice')
            self.voice = value_
            self.voice_nsprefix_ = child_.prefix
        elif nodeName_ == 'staff' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'staff')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'staff')
            self.staff = ival_
            self.staff_nsprefix_ = child_.prefix
        elif nodeName_ == 'sound':
            obj_ = sound.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sound = obj_
            obj_.original_tagname_ = 'sound'
        elif nodeName_ == 'listening':
            obj_ = listening.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listening = obj_
            obj_.original_tagname_ = 'listening'
# end class direction


class direction_type(GeneratedsSuper):
    """rehearsal -- The rehearsal element specifies letters, numbers, and section names that are notated in the score for reference during rehearsal. The enclosure is square if not specified. The language is Italian ("it") if not specified. Left justification is used if not specified.
    words -- The words element specifies a standard text direction. The enclosure is none if not specified. The language is Italian ("it") if not specified. Left justification is used if not specified.
    symbol -- The symbol element specifies a musical symbol using a canonical SMuFL glyph name. It is used when an occasional musical symbol is interspersed into text. It should not be used in place of semantic markup, such as metronome marks that mix text and symbols. Left justification is used if not specified. Enclosure is none if not specified.
    damp -- The damp element specifies a harp damping mark.
    damp-all -- The damp-all element specifies a harp damping mark for all strings.
    eyeglasses -- The eyeglasses element represents the eyeglasses symbol, common in commercial music.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, rehearsal=None, segno=None, coda=None, words=None, symbol=None, wedge=None, dynamics=None, dashes=None, bracket=None, pedal=None, metronome=None, octave_shift=None, harp_pedals=None, damp=None, damp_all=None, eyeglasses=None, string_mute=None, scordatura=None, image=None, principal_voice=None, percussion=None, accordion_registration=None, staff_divide=None, other_direction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if rehearsal is None:
            self.rehearsal = []
        else:
            self.rehearsal = rehearsal
        self.rehearsal_nsprefix_ = None
        if segno is None:
            self.segno = []
        else:
            self.segno = segno
        self.segno_nsprefix_ = None
        if coda is None:
            self.coda = []
        else:
            self.coda = coda
        self.coda_nsprefix_ = None
        if words is None:
            self.words = []
        else:
            self.words = words
        self.words_nsprefix_ = None
        if symbol is None:
            self.symbol = []
        else:
            self.symbol = symbol
        self.symbol_nsprefix_ = None
        self.wedge = wedge
        self.wedge_nsprefix_ = None
        if dynamics is None:
            self.dynamics = []
        else:
            self.dynamics = dynamics
        self.dynamics_nsprefix_ = None
        self.dashes = dashes
        self.dashes_nsprefix_ = None
        self.bracket = bracket
        self.bracket_nsprefix_ = None
        self.pedal = pedal
        self.pedal_nsprefix_ = None
        self.metronome = metronome
        self.metronome_nsprefix_ = None
        self.octave_shift = octave_shift
        self.octave_shift_nsprefix_ = None
        self.harp_pedals = harp_pedals
        self.harp_pedals_nsprefix_ = None
        self.damp = damp
        self.damp_nsprefix_ = None
        self.damp_all = damp_all
        self.damp_all_nsprefix_ = None
        self.eyeglasses = eyeglasses
        self.eyeglasses_nsprefix_ = None
        self.string_mute = string_mute
        self.string_mute_nsprefix_ = None
        self.scordatura = scordatura
        self.scordatura_nsprefix_ = None
        self.image = image
        self.image_nsprefix_ = None
        self.principal_voice = principal_voice
        self.principal_voice_nsprefix_ = None
        if percussion is None:
            self.percussion = []
        else:
            self.percussion = percussion
        self.percussion_nsprefix_ = None
        self.accordion_registration = accordion_registration
        self.accordion_registration_nsprefix_ = None
        self.staff_divide = staff_divide
        self.staff_divide_nsprefix_ = None
        self.other_direction = other_direction
        self.other_direction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, direction_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if direction_type.subclass:
            return direction_type.subclass(*args_, **kwargs_)
        else:
            return direction_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rehearsal(self):
        return self.rehearsal
    def set_rehearsal(self, rehearsal):
        self.rehearsal = rehearsal
    def add_rehearsal(self, value):
        self.rehearsal.append(value)
    def insert_rehearsal_at(self, index, value):
        self.rehearsal.insert(index, value)
    def replace_rehearsal_at(self, index, value):
        self.rehearsal[index] = value
    def get_segno(self):
        return self.segno
    def set_segno(self, segno):
        self.segno = segno
    def add_segno(self, value):
        self.segno.append(value)
    def insert_segno_at(self, index, value):
        self.segno.insert(index, value)
    def replace_segno_at(self, index, value):
        self.segno[index] = value
    def get_coda(self):
        return self.coda
    def set_coda(self, coda):
        self.coda = coda
    def add_coda(self, value):
        self.coda.append(value)
    def insert_coda_at(self, index, value):
        self.coda.insert(index, value)
    def replace_coda_at(self, index, value):
        self.coda[index] = value
    def get_words(self):
        return self.words
    def set_words(self, words):
        self.words = words
    def add_words(self, value):
        self.words.append(value)
    def insert_words_at(self, index, value):
        self.words.insert(index, value)
    def replace_words_at(self, index, value):
        self.words[index] = value
    def get_symbol(self):
        return self.symbol
    def set_symbol(self, symbol):
        self.symbol = symbol
    def add_symbol(self, value):
        self.symbol.append(value)
    def insert_symbol_at(self, index, value):
        self.symbol.insert(index, value)
    def replace_symbol_at(self, index, value):
        self.symbol[index] = value
    def get_wedge(self):
        return self.wedge
    def set_wedge(self, wedge):
        self.wedge = wedge
    def get_dynamics(self):
        return self.dynamics
    def set_dynamics(self, dynamics):
        self.dynamics = dynamics
    def add_dynamics(self, value):
        self.dynamics.append(value)
    def insert_dynamics_at(self, index, value):
        self.dynamics.insert(index, value)
    def replace_dynamics_at(self, index, value):
        self.dynamics[index] = value
    def get_dashes(self):
        return self.dashes
    def set_dashes(self, dashes):
        self.dashes = dashes
    def get_bracket(self):
        return self.bracket
    def set_bracket(self, bracket):
        self.bracket = bracket
    def get_pedal(self):
        return self.pedal
    def set_pedal(self, pedal):
        self.pedal = pedal
    def get_metronome(self):
        return self.metronome
    def set_metronome(self, metronome):
        self.metronome = metronome
    def get_octave_shift(self):
        return self.octave_shift
    def set_octave_shift(self, octave_shift):
        self.octave_shift = octave_shift
    def get_harp_pedals(self):
        return self.harp_pedals
    def set_harp_pedals(self, harp_pedals):
        self.harp_pedals = harp_pedals
    def get_damp(self):
        return self.damp
    def set_damp(self, damp):
        self.damp = damp
    def get_damp_all(self):
        return self.damp_all
    def set_damp_all(self, damp_all):
        self.damp_all = damp_all
    def get_eyeglasses(self):
        return self.eyeglasses
    def set_eyeglasses(self, eyeglasses):
        self.eyeglasses = eyeglasses
    def get_string_mute(self):
        return self.string_mute
    def set_string_mute(self, string_mute):
        self.string_mute = string_mute
    def get_scordatura(self):
        return self.scordatura
    def set_scordatura(self, scordatura):
        self.scordatura = scordatura
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_principal_voice(self):
        return self.principal_voice
    def set_principal_voice(self, principal_voice):
        self.principal_voice = principal_voice
    def get_percussion(self):
        return self.percussion
    def set_percussion(self, percussion):
        self.percussion = percussion
    def add_percussion(self, value):
        self.percussion.append(value)
    def insert_percussion_at(self, index, value):
        self.percussion.insert(index, value)
    def replace_percussion_at(self, index, value):
        self.percussion[index] = value
    def get_accordion_registration(self):
        return self.accordion_registration
    def set_accordion_registration(self, accordion_registration):
        self.accordion_registration = accordion_registration
    def get_staff_divide(self):
        return self.staff_divide
    def set_staff_divide(self, staff_divide):
        self.staff_divide = staff_divide
    def get_other_direction(self):
        return self.other_direction
    def set_other_direction(self, other_direction):
        self.other_direction = other_direction
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.rehearsal or
            self.segno or
            self.coda or
            self.words or
            self.symbol or
            self.wedge is not None or
            self.dynamics or
            self.dashes is not None or
            self.bracket is not None or
            self.pedal is not None or
            self.metronome is not None or
            self.octave_shift is not None or
            self.harp_pedals is not None or
            self.damp is not None or
            self.damp_all is not None or
            self.eyeglasses is not None or
            self.string_mute is not None or
            self.scordatura is not None or
            self.image is not None or
            self.principal_voice is not None or
            self.percussion or
            self.accordion_registration is not None or
            self.staff_divide is not None or
            self.other_direction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='direction-type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('direction-type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'direction-type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='direction-type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='direction-type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='direction-type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='direction-type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rehearsal_ in self.rehearsal:
            namespaceprefix_ = self.rehearsal_nsprefix_ + ':' if (UseCapturedNS_ and self.rehearsal_nsprefix_) else ''
            rehearsal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rehearsal', pretty_print=pretty_print)
        for segno_ in self.segno:
            namespaceprefix_ = self.segno_nsprefix_ + ':' if (UseCapturedNS_ and self.segno_nsprefix_) else ''
            segno_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segno', pretty_print=pretty_print)
        for coda_ in self.coda:
            namespaceprefix_ = self.coda_nsprefix_ + ':' if (UseCapturedNS_ and self.coda_nsprefix_) else ''
            coda_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coda', pretty_print=pretty_print)
        for words_ in self.words:
            namespaceprefix_ = self.words_nsprefix_ + ':' if (UseCapturedNS_ and self.words_nsprefix_) else ''
            words_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='words', pretty_print=pretty_print)
        for symbol_ in self.symbol:
            namespaceprefix_ = self.symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.symbol_nsprefix_) else ''
            symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='symbol', pretty_print=pretty_print)
        if self.wedge is not None:
            namespaceprefix_ = self.wedge_nsprefix_ + ':' if (UseCapturedNS_ and self.wedge_nsprefix_) else ''
            self.wedge.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wedge', pretty_print=pretty_print)
        for dynamics_ in self.dynamics:
            namespaceprefix_ = self.dynamics_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamics_nsprefix_) else ''
            dynamics_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamics', pretty_print=pretty_print)
        if self.dashes is not None:
            namespaceprefix_ = self.dashes_nsprefix_ + ':' if (UseCapturedNS_ and self.dashes_nsprefix_) else ''
            self.dashes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dashes', pretty_print=pretty_print)
        if self.bracket is not None:
            namespaceprefix_ = self.bracket_nsprefix_ + ':' if (UseCapturedNS_ and self.bracket_nsprefix_) else ''
            self.bracket.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bracket', pretty_print=pretty_print)
        if self.pedal is not None:
            namespaceprefix_ = self.pedal_nsprefix_ + ':' if (UseCapturedNS_ and self.pedal_nsprefix_) else ''
            self.pedal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pedal', pretty_print=pretty_print)
        if self.metronome is not None:
            namespaceprefix_ = self.metronome_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_nsprefix_) else ''
            self.metronome.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metronome', pretty_print=pretty_print)
        if self.octave_shift is not None:
            namespaceprefix_ = self.octave_shift_nsprefix_ + ':' if (UseCapturedNS_ and self.octave_shift_nsprefix_) else ''
            self.octave_shift.export(outfile, level, namespaceprefix_, namespacedef_='', name_='octave-shift', pretty_print=pretty_print)
        if self.harp_pedals is not None:
            namespaceprefix_ = self.harp_pedals_nsprefix_ + ':' if (UseCapturedNS_ and self.harp_pedals_nsprefix_) else ''
            self.harp_pedals.export(outfile, level, namespaceprefix_, namespacedef_='', name_='harp-pedals', pretty_print=pretty_print)
        if self.damp is not None:
            namespaceprefix_ = self.damp_nsprefix_ + ':' if (UseCapturedNS_ and self.damp_nsprefix_) else ''
            self.damp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='damp', pretty_print=pretty_print)
        if self.damp_all is not None:
            namespaceprefix_ = self.damp_all_nsprefix_ + ':' if (UseCapturedNS_ and self.damp_all_nsprefix_) else ''
            self.damp_all.export(outfile, level, namespaceprefix_, namespacedef_='', name_='damp-all', pretty_print=pretty_print)
        if self.eyeglasses is not None:
            namespaceprefix_ = self.eyeglasses_nsprefix_ + ':' if (UseCapturedNS_ and self.eyeglasses_nsprefix_) else ''
            self.eyeglasses.export(outfile, level, namespaceprefix_, namespacedef_='', name_='eyeglasses', pretty_print=pretty_print)
        if self.string_mute is not None:
            namespaceprefix_ = self.string_mute_nsprefix_ + ':' if (UseCapturedNS_ and self.string_mute_nsprefix_) else ''
            self.string_mute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='string-mute', pretty_print=pretty_print)
        if self.scordatura is not None:
            namespaceprefix_ = self.scordatura_nsprefix_ + ':' if (UseCapturedNS_ and self.scordatura_nsprefix_) else ''
            self.scordatura.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scordatura', pretty_print=pretty_print)
        if self.image is not None:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            self.image.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        if self.principal_voice is not None:
            namespaceprefix_ = self.principal_voice_nsprefix_ + ':' if (UseCapturedNS_ and self.principal_voice_nsprefix_) else ''
            self.principal_voice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='principal-voice', pretty_print=pretty_print)
        for percussion_ in self.percussion:
            namespaceprefix_ = self.percussion_nsprefix_ + ':' if (UseCapturedNS_ and self.percussion_nsprefix_) else ''
            percussion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='percussion', pretty_print=pretty_print)
        if self.accordion_registration is not None:
            namespaceprefix_ = self.accordion_registration_nsprefix_ + ':' if (UseCapturedNS_ and self.accordion_registration_nsprefix_) else ''
            self.accordion_registration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accordion-registration', pretty_print=pretty_print)
        if self.staff_divide is not None:
            namespaceprefix_ = self.staff_divide_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_divide_nsprefix_) else ''
            self.staff_divide.export(outfile, level, namespaceprefix_, namespacedef_='', name_='staff-divide', pretty_print=pretty_print)
        if self.other_direction is not None:
            namespaceprefix_ = self.other_direction_nsprefix_ + ':' if (UseCapturedNS_ and self.other_direction_nsprefix_) else ''
            self.other_direction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-direction', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rehearsal':
            obj_ = formatted_text_id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rehearsal.append(obj_)
            obj_.original_tagname_ = 'rehearsal'
        elif nodeName_ == 'segno':
            obj_ = segno.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segno.append(obj_)
            obj_.original_tagname_ = 'segno'
        elif nodeName_ == 'coda':
            obj_ = coda.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coda.append(obj_)
            obj_.original_tagname_ = 'coda'
        elif nodeName_ == 'words':
            obj_ = formatted_text_id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.words.append(obj_)
            obj_.original_tagname_ = 'words'
        elif nodeName_ == 'symbol':
            obj_ = formatted_symbol_id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.symbol.append(obj_)
            obj_.original_tagname_ = 'symbol'
        elif nodeName_ == 'wedge':
            obj_ = wedge.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wedge = obj_
            obj_.original_tagname_ = 'wedge'
        elif nodeName_ == 'dynamics':
            obj_ = dynamics.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamics.append(obj_)
            obj_.original_tagname_ = 'dynamics'
        elif nodeName_ == 'dashes':
            obj_ = dashes.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dashes = obj_
            obj_.original_tagname_ = 'dashes'
        elif nodeName_ == 'bracket':
            obj_ = bracket.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bracket = obj_
            obj_.original_tagname_ = 'bracket'
        elif nodeName_ == 'pedal':
            obj_ = pedal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pedal = obj_
            obj_.original_tagname_ = 'pedal'
        elif nodeName_ == 'metronome':
            obj_ = metronome.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metronome = obj_
            obj_.original_tagname_ = 'metronome'
        elif nodeName_ == 'octave-shift':
            obj_ = octave_shift.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.octave_shift = obj_
            obj_.original_tagname_ = 'octave-shift'
        elif nodeName_ == 'harp-pedals':
            obj_ = harp_pedals.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.harp_pedals = obj_
            obj_.original_tagname_ = 'harp-pedals'
        elif nodeName_ == 'damp':
            obj_ = empty_print_style_align_id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.damp = obj_
            obj_.original_tagname_ = 'damp'
        elif nodeName_ == 'damp-all':
            obj_ = empty_print_style_align_id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.damp_all = obj_
            obj_.original_tagname_ = 'damp-all'
        elif nodeName_ == 'eyeglasses':
            obj_ = empty_print_style_align_id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.eyeglasses = obj_
            obj_.original_tagname_ = 'eyeglasses'
        elif nodeName_ == 'string-mute':
            obj_ = string_mute.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.string_mute = obj_
            obj_.original_tagname_ = 'string-mute'
        elif nodeName_ == 'scordatura':
            obj_ = scordatura.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scordatura = obj_
            obj_.original_tagname_ = 'scordatura'
        elif nodeName_ == 'image':
            obj_ = image.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.image = obj_
            obj_.original_tagname_ = 'image'
        elif nodeName_ == 'principal-voice':
            obj_ = principal_voice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.principal_voice = obj_
            obj_.original_tagname_ = 'principal-voice'
        elif nodeName_ == 'percussion':
            obj_ = percussion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.percussion.append(obj_)
            obj_.original_tagname_ = 'percussion'
        elif nodeName_ == 'accordion-registration':
            obj_ = accordion_registration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accordion_registration = obj_
            obj_.original_tagname_ = 'accordion-registration'
        elif nodeName_ == 'staff-divide':
            obj_ = staff_divide.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.staff_divide = obj_
            obj_.original_tagname_ = 'staff-divide'
        elif nodeName_ == 'other-direction':
            obj_ = other_direction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_direction = obj_
            obj_.original_tagname_ = 'other-direction'
# end class direction_type


class effect(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, effect)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if effect.subclass:
            return effect.subclass(*args_, **kwargs_)
        else:
            return effect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_effect_value(self, value):
        result = True
        # Validate type effect-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['anvil', 'auto horn', 'bird whistle', 'cannon', 'duck call', 'gun shot', 'klaxon horn', 'lions roar', 'lotus flute', 'megaphone', 'police whistle', 'siren', 'slide whistle', 'thunder sheet', 'wind machine', 'wind whistle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on effect-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_pictogram_glyph_name(self, value):
        # Validate type smufl-pictogram-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_pictogram_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_pictogram_glyph_name_patterns_, ))
    validate_smufl_pictogram_glyph_name_patterns_ = [['^(pict\\c+)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='effect', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('effect')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'effect':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='effect')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='effect', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='effect'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='effect', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_pictogram_glyph_name(self.smufl)    # validate type smufl-pictogram-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class effect


class feature(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, feature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if feature.subclass:
            return feature.subclass(*args_, **kwargs_)
        else:
            return feature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='feature', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('feature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'feature':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='feature')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='feature', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='feature'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='feature', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class feature


class first_fret(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, text=None, location=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.location = _cast(None, location)
        self.location_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, first_fret)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if first_fret.subclass:
            return first_fret.subclass(*args_, **kwargs_)
        else:
            return first_fret(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_left_right(self, value):
        # Validate type left-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='first-fret', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('first-fret')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'first-fret':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='first-fret')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='first-fret', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='first-fret'):
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.location), input_name='location')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='first-fret', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
            self.location = ' '.join(self.location.split())
            self.validate_left_right(self.location)    # validate type left-right
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class first_fret


class frame(GeneratedsSuper):
    """frame-strings -- The frame-strings element gives the overall size of the frame in vertical lines (strings).
    frame-frets -- The frame-frets element gives the overall size of the frame in horizontal spaces (frets).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, height=None, width=None, unplayed=None, default_x=None, default_y=None, relative_x=None, relative_y=None, color=None, halign=None, valign=None, id=None, frame_strings=None, frame_frets=None, first_fret=None, frame_note=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.unplayed = _cast(None, unplayed)
        self.unplayed_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.frame_strings = frame_strings
        self.frame_strings_nsprefix_ = None
        self.frame_frets = frame_frets
        self.frame_frets_nsprefix_ = None
        self.first_fret = first_fret
        self.first_fret_nsprefix_ = None
        if frame_note is None:
            self.frame_note = []
        else:
            self.frame_note = frame_note
        self.frame_note_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, frame)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if frame.subclass:
            return frame.subclass(*args_, **kwargs_)
        else:
            return frame(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_frame_strings(self):
        return self.frame_strings
    def set_frame_strings(self, frame_strings):
        self.frame_strings = frame_strings
    def get_frame_frets(self):
        return self.frame_frets
    def set_frame_frets(self, frame_frets):
        self.frame_frets = frame_frets
    def get_first_fret(self):
        return self.first_fret
    def set_first_fret(self, first_fret):
        self.first_fret = first_fret
    def get_frame_note(self):
        return self.frame_note
    def set_frame_note(self, frame_note):
        self.frame_note = frame_note
    def add_frame_note(self, value):
        self.frame_note.append(value)
    def insert_frame_note_at(self, index, value):
        self.frame_note.insert(index, value)
    def replace_frame_note_at(self, index, value):
        self.frame_note[index] = value
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_unplayed(self):
        return self.unplayed
    def set_unplayed(self, unplayed):
        self.unplayed = unplayed
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign_image(self, value):
        # Validate type valign-image, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign-image' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.frame_strings is not None or
            self.frame_frets is not None or
            self.first_fret is not None or
            self.frame_note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='frame', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('frame')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'frame':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='frame')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='frame', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='frame'):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_decimal(self.height, input_name='height'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_decimal(self.width, input_name='width'))
        if self.unplayed is not None and 'unplayed' not in already_processed:
            already_processed.add('unplayed')
            outfile.write(' unplayed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unplayed), input_name='unplayed')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='frame', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.frame_strings is not None:
            namespaceprefix_ = self.frame_strings_nsprefix_ + ':' if (UseCapturedNS_ and self.frame_strings_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sframe-strings>%s</%sframe-strings>%s' % (namespaceprefix_ , self.gds_format_integer(self.frame_strings, input_name='frame-strings'), namespaceprefix_ , eol_))
        if self.frame_frets is not None:
            namespaceprefix_ = self.frame_frets_nsprefix_ + ':' if (UseCapturedNS_ and self.frame_frets_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sframe-frets>%s</%sframe-frets>%s' % (namespaceprefix_ , self.gds_format_integer(self.frame_frets, input_name='frame-frets'), namespaceprefix_ , eol_))
        if self.first_fret is not None:
            namespaceprefix_ = self.first_fret_nsprefix_ + ':' if (UseCapturedNS_ and self.first_fret_nsprefix_) else ''
            self.first_fret.export(outfile, level, namespaceprefix_, namespacedef_='', name_='first-fret', pretty_print=pretty_print)
        for frame_note_ in self.frame_note:
            namespaceprefix_ = self.frame_note_nsprefix_ + ':' if (UseCapturedNS_ and self.frame_note_nsprefix_) else ''
            frame_note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='frame-note', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_decimal(value, node, 'height')
            self.height = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_decimal(value, node, 'width')
            self.width = value
        value = find_attr_value_('unplayed', node)
        if value is not None and 'unplayed' not in already_processed:
            already_processed.add('unplayed')
            self.unplayed = value
            self.unplayed = ' '.join(self.unplayed.split())
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign_image(self.valign)    # validate type valign-image
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'frame-strings' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'frame_strings')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'frame_strings')
            self.frame_strings = ival_
            self.frame_strings_nsprefix_ = child_.prefix
        elif nodeName_ == 'frame-frets' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'frame_frets')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'frame_frets')
            self.frame_frets = ival_
            self.frame_frets_nsprefix_ = child_.prefix
        elif nodeName_ == 'first-fret':
            obj_ = first_fret.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.first_fret = obj_
            obj_.original_tagname_ = 'first-fret'
        elif nodeName_ == 'frame-note':
            obj_ = frame_note.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.frame_note.append(obj_)
            obj_.original_tagname_ = 'frame-note'
# end class frame


class frame_note(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, string=None, fret=None, fingering=None, barre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.string = string
        self.string_nsprefix_ = None
        self.fret = fret
        self.fret_nsprefix_ = None
        self.fingering = fingering
        self.fingering_nsprefix_ = None
        self.barre = barre
        self.barre_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, frame_note)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if frame_note.subclass:
            return frame_note.subclass(*args_, **kwargs_)
        else:
            return frame_note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_string(self):
        return self.string
    def set_string(self, string):
        self.string = string
    def get_fret(self):
        return self.fret
    def set_fret(self, fret):
        self.fret = fret
    def get_fingering(self):
        return self.fingering
    def set_fingering(self, fingering):
        self.fingering = fingering
    def get_barre(self):
        return self.barre
    def set_barre(self, barre):
        self.barre = barre
    def _hasContent(self):
        if (
            self.string is not None or
            self.fret is not None or
            self.fingering is not None or
            self.barre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='frame-note', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('frame-note')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'frame-note':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='frame-note')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='frame-note', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='frame-note'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='frame-note', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.string is not None:
            namespaceprefix_ = self.string_nsprefix_ + ':' if (UseCapturedNS_ and self.string_nsprefix_) else ''
            self.string.export(outfile, level, namespaceprefix_, namespacedef_='', name_='string', pretty_print=pretty_print)
        if self.fret is not None:
            namespaceprefix_ = self.fret_nsprefix_ + ':' if (UseCapturedNS_ and self.fret_nsprefix_) else ''
            self.fret.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fret', pretty_print=pretty_print)
        if self.fingering is not None:
            namespaceprefix_ = self.fingering_nsprefix_ + ':' if (UseCapturedNS_ and self.fingering_nsprefix_) else ''
            self.fingering.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fingering', pretty_print=pretty_print)
        if self.barre is not None:
            namespaceprefix_ = self.barre_nsprefix_ + ':' if (UseCapturedNS_ and self.barre_nsprefix_) else ''
            self.barre.export(outfile, level, namespaceprefix_, namespacedef_='', name_='barre', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'string':
            obj_ = string.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.string = obj_
            obj_.original_tagname_ = 'string'
        elif nodeName_ == 'fret':
            obj_ = fret.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fret = obj_
            obj_.original_tagname_ = 'fret'
        elif nodeName_ == 'fingering':
            obj_ = fingering.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fingering = obj_
            obj_.original_tagname_ = 'fingering'
        elif nodeName_ == 'barre':
            obj_ = barre.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.barre = obj_
            obj_.original_tagname_ = 'barre'
# end class frame_note


class glass(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, glass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if glass.subclass:
            return glass.subclass(*args_, **kwargs_)
        else:
            return glass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_glass_value(self, value):
        result = True
        # Validate type glass-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['glass harmonica', 'glass harp', 'wind chimes']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on glass-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_pictogram_glyph_name(self, value):
        # Validate type smufl-pictogram-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_pictogram_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_pictogram_glyph_name_patterns_, ))
    validate_smufl_pictogram_glyph_name_patterns_ = [['^(pict\\c+)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='glass', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('glass')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'glass':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='glass')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='glass', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='glass'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='glass', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_pictogram_glyph_name(self.smufl)    # validate type smufl-pictogram-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class glass


class grouping(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number='1', member_of=None, id=None, feature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.member_of = _cast(None, member_of)
        self.member_of_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if feature is None:
            self.feature = []
        else:
            self.feature = feature
        self.feature_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, grouping)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if grouping.subclass:
            return grouping.subclass(*args_, **kwargs_)
        else:
            return grouping(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_feature(self):
        return self.feature
    def set_feature(self, feature):
        self.feature = feature
    def add_feature(self, value):
        self.feature.append(value)
    def insert_feature_at(self, index, value):
        self.feature.insert(index, value)
    def replace_feature_at(self, index, value):
        self.feature[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_member_of(self):
        return self.member_of
    def set_member_of(self, member_of):
        self.member_of = member_of
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_start_stop_single(self, value):
        # Validate type start-stop-single, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'single']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-single' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.feature
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='grouping', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('grouping')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'grouping':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='grouping')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='grouping', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='grouping'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number != "1" and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.number), input_name='number')), ))
        if self.member_of is not None and 'member_of' not in already_processed:
            already_processed.add('member_of')
            outfile.write(' member-of=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.member_of), input_name='member-of')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='grouping', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for feature_ in self.feature:
            namespaceprefix_ = self.feature_nsprefix_ + ':' if (UseCapturedNS_ and self.feature_nsprefix_) else ''
            feature_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='feature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_single(self.type_)    # validate type start-stop-single
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
            self.number = ' '.join(self.number.split())
        value = find_attr_value_('member-of', node)
        if value is not None and 'member-of' not in already_processed:
            already_processed.add('member-of')
            self.member_of = value
            self.member_of = ' '.join(self.member_of.split())
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'feature':
            obj_ = feature.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.feature.append(obj_)
            obj_.original_tagname_ = 'feature'
# end class grouping


class harmony(GeneratedsSuper):
    """function -- The function element represents classical functional harmony with an indication like I, II, III rather than C, D, E. It represents the Roman numeral part of a functional harmony rather than the complete function itself. It has been deprecated as of MusicXML 4.0 in favor of the numeral element.
    staff -- Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, print_frame=None, arrangement=None, print_object=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, system=None, id=None, root=None, numeral=None, function=None, kind=None, inversion=None, bass=None, degree=None, frame=None, offset=None, footnote=None, level=None, staff=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.print_frame = _cast(None, print_frame)
        self.print_frame_nsprefix_ = None
        self.arrangement = _cast(None, arrangement)
        self.arrangement_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if root is None:
            self.root = []
        else:
            self.root = root
        self.root_nsprefix_ = None
        if numeral is None:
            self.numeral = []
        else:
            self.numeral = numeral
        self.numeral_nsprefix_ = None
        if function is None:
            self.function = []
        else:
            self.function = function
        self.function_nsprefix_ = None
        if kind is None:
            self.kind = []
        else:
            self.kind = kind
        self.kind_nsprefix_ = None
        if inversion is None:
            self.inversion = []
        else:
            self.inversion = inversion
        self.inversion_nsprefix_ = None
        if bass is None:
            self.bass = []
        else:
            self.bass = bass
        self.bass_nsprefix_ = None
        if degree is None:
            self.degree = []
        else:
            self.degree = degree
        self.degree_nsprefix_ = None
        self.frame = frame
        self.frame_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
        self.staff = staff
        self.staff_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, harmony)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if harmony.subclass:
            return harmony.subclass(*args_, **kwargs_)
        else:
            return harmony(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root(self):
        return self.root
    def set_root(self, root):
        self.root = root
    def add_root(self, value):
        self.root.append(value)
    def insert_root_at(self, index, value):
        self.root.insert(index, value)
    def replace_root_at(self, index, value):
        self.root[index] = value
    def get_numeral(self):
        return self.numeral
    def set_numeral(self, numeral):
        self.numeral = numeral
    def add_numeral(self, value):
        self.numeral.append(value)
    def insert_numeral_at(self, index, value):
        self.numeral.insert(index, value)
    def replace_numeral_at(self, index, value):
        self.numeral[index] = value
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def add_function(self, value):
        self.function.append(value)
    def insert_function_at(self, index, value):
        self.function.insert(index, value)
    def replace_function_at(self, index, value):
        self.function[index] = value
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def add_kind(self, value):
        self.kind.append(value)
    def insert_kind_at(self, index, value):
        self.kind.insert(index, value)
    def replace_kind_at(self, index, value):
        self.kind[index] = value
    def get_inversion(self):
        return self.inversion
    def set_inversion(self, inversion):
        self.inversion = inversion
    def add_inversion(self, value):
        self.inversion.append(value)
    def insert_inversion_at(self, index, value):
        self.inversion.insert(index, value)
    def replace_inversion_at(self, index, value):
        self.inversion[index] = value
    def get_bass(self):
        return self.bass
    def set_bass(self, bass):
        self.bass = bass
    def add_bass(self, value):
        self.bass.append(value)
    def insert_bass_at(self, index, value):
        self.bass.insert(index, value)
    def replace_bass_at(self, index, value):
        self.bass[index] = value
    def get_degree(self):
        return self.degree
    def set_degree(self, degree):
        self.degree = degree
    def add_degree(self, value):
        self.degree.append(value)
    def insert_degree_at(self, index, value):
        self.degree.insert(index, value)
    def replace_degree_at(self, index, value):
        self.degree[index] = value
    def get_frame(self):
        return self.frame
    def set_frame(self, frame):
        self.frame = frame
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_staff(self):
        return self.staff
    def set_staff(self, staff):
        self.staff = staff
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_print_frame(self):
        return self.print_frame
    def set_print_frame(self, print_frame):
        self.print_frame = print_frame
    def get_arrangement(self):
        return self.arrangement
    def set_arrangement(self, arrangement):
        self.arrangement = arrangement
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_harmony_type(self, value):
        # Validate type harmony-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['explicit', 'implied', 'alternate']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on harmony-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_harmony_arrangement(self, value):
        # Validate type harmony-arrangement, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['vertical', 'horizontal', 'diagonal']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on harmony-arrangement' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_system_relation(self, value):
        # Validate type system-relation, a restriction on system-relation-number.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['only-top', 'also-top', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on system-relation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['only-top', 'only-bottom', 'also-top', 'also-bottom', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on system-relation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.root or
            self.numeral or
            self.function or
            self.kind or
            self.inversion or
            self.bass or
            self.degree or
            self.frame is not None or
            self.offset is not None or
            self.footnote is not None or
            self.level is not None or
            self.staff is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmony', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('harmony')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'harmony':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='harmony')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='harmony', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='harmony'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.print_frame is not None and 'print_frame' not in already_processed:
            already_processed.add('print_frame')
            outfile.write(' print-frame=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_frame), input_name='print-frame')), ))
        if self.arrangement is not None and 'arrangement' not in already_processed:
            already_processed.add('arrangement')
            outfile.write(' arrangement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arrangement), input_name='arrangement')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmony', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for root_ in self.root:
            namespaceprefix_ = self.root_nsprefix_ + ':' if (UseCapturedNS_ and self.root_nsprefix_) else ''
            root_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='root', pretty_print=pretty_print)
        for numeral_ in self.numeral:
            namespaceprefix_ = self.numeral_nsprefix_ + ':' if (UseCapturedNS_ and self.numeral_nsprefix_) else ''
            numeral_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numeral', pretty_print=pretty_print)
        for function_ in self.function:
            namespaceprefix_ = self.function_nsprefix_ + ':' if (UseCapturedNS_ and self.function_nsprefix_) else ''
            function_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='function', pretty_print=pretty_print)
        for kind_ in self.kind:
            namespaceprefix_ = self.kind_nsprefix_ + ':' if (UseCapturedNS_ and self.kind_nsprefix_) else ''
            kind_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='kind', pretty_print=pretty_print)
        for inversion_ in self.inversion:
            namespaceprefix_ = self.inversion_nsprefix_ + ':' if (UseCapturedNS_ and self.inversion_nsprefix_) else ''
            inversion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inversion', pretty_print=pretty_print)
        for bass_ in self.bass:
            namespaceprefix_ = self.bass_nsprefix_ + ':' if (UseCapturedNS_ and self.bass_nsprefix_) else ''
            bass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bass', pretty_print=pretty_print)
        for degree_ in self.degree:
            namespaceprefix_ = self.degree_nsprefix_ + ':' if (UseCapturedNS_ and self.degree_nsprefix_) else ''
            degree_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='degree', pretty_print=pretty_print)
        if self.frame is not None:
            namespaceprefix_ = self.frame_nsprefix_ + ':' if (UseCapturedNS_ and self.frame_nsprefix_) else ''
            self.frame.export(outfile, level, namespaceprefix_, namespacedef_='', name_='frame', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
        if self.staff is not None:
            namespaceprefix_ = self.staff_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaff>%s</%sstaff>%s' % (namespaceprefix_ , self.gds_format_integer(self.staff, input_name='staff'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_harmony_type(self.type_)    # validate type harmony-type
        value = find_attr_value_('print-frame', node)
        if value is not None and 'print-frame' not in already_processed:
            already_processed.add('print-frame')
            self.print_frame = value
            self.print_frame = ' '.join(self.print_frame.split())
            self.validate_yes_no(self.print_frame)    # validate type yes-no
        value = find_attr_value_('arrangement', node)
        if value is not None and 'arrangement' not in already_processed:
            already_processed.add('arrangement')
            self.arrangement = value
            self.arrangement = ' '.join(self.arrangement.split())
            self.validate_harmony_arrangement(self.arrangement)    # validate type harmony-arrangement
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_system_relation(self.system)    # validate type system-relation
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'root':
            obj_ = root.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.root.append(obj_)
            obj_.original_tagname_ = 'root'
        elif nodeName_ == 'numeral':
            obj_ = numeral.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numeral.append(obj_)
            obj_.original_tagname_ = 'numeral'
        elif nodeName_ == 'function':
            obj_ = style_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.function.append(obj_)
            obj_.original_tagname_ = 'function'
        elif nodeName_ == 'kind':
            obj_ = kind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kind.append(obj_)
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'inversion':
            obj_ = inversion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inversion.append(obj_)
            obj_.original_tagname_ = 'inversion'
        elif nodeName_ == 'bass':
            obj_ = bass.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bass.append(obj_)
            obj_.original_tagname_ = 'bass'
        elif nodeName_ == 'degree':
            obj_ = degree.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.degree.append(obj_)
            obj_.original_tagname_ = 'degree'
        elif nodeName_ == 'frame':
            obj_ = frame.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.frame = obj_
            obj_.original_tagname_ = 'frame'
        elif nodeName_ == 'offset':
            obj_ = offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
        elif nodeName_ == 'staff' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'staff')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'staff')
            self.staff = ival_
            self.staff_nsprefix_ = child_.prefix
# end class harmony


class harp_pedals(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, pedal_tuning=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if pedal_tuning is None:
            self.pedal_tuning = []
        else:
            self.pedal_tuning = pedal_tuning
        self.pedal_tuning_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, harp_pedals)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if harp_pedals.subclass:
            return harp_pedals.subclass(*args_, **kwargs_)
        else:
            return harp_pedals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pedal_tuning(self):
        return self.pedal_tuning
    def set_pedal_tuning(self, pedal_tuning):
        self.pedal_tuning = pedal_tuning
    def add_pedal_tuning(self, value):
        self.pedal_tuning.append(value)
    def insert_pedal_tuning_at(self, index, value):
        self.pedal_tuning.insert(index, value)
    def replace_pedal_tuning_at(self, index, value):
        self.pedal_tuning[index] = value
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.pedal_tuning
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harp-pedals', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('harp-pedals')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'harp-pedals':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='harp-pedals')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='harp-pedals', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='harp-pedals'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harp-pedals', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pedal_tuning_ in self.pedal_tuning:
            namespaceprefix_ = self.pedal_tuning_nsprefix_ + ':' if (UseCapturedNS_ and self.pedal_tuning_nsprefix_) else ''
            pedal_tuning_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pedal-tuning', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pedal-tuning':
            obj_ = pedal_tuning.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pedal_tuning.append(obj_)
            obj_.original_tagname_ = 'pedal-tuning'
# end class harp_pedals


class image(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, source=None, type_=None, height=None, width=None, default_x=None, default_y=None, relative_x=None, relative_y=None, halign=None, valign=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, image)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if image.subclass:
            return image.subclass(*args_, **kwargs_)
        else:
            return image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign_image(self, value):
        # Validate type valign-image, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign-image' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='image', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('image')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'image':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='image')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='image', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='image'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_decimal(self.height, input_name='height'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_decimal(self.width, input_name='width'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='image', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_decimal(value, node, 'height')
            self.height = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_decimal(value, node, 'width')
            self.width = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign_image(self.valign)    # validate type valign-image
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class image


class instrument_change(GeneratedsSuper):
    """instrument-sound -- The instrument-sound element describes the default timbre of the score-instrument. This description is independent of a particular virtual or MIDI instrument specification and allows playback to be shared more easily between applications and libraries.
    solo -- The solo element is present if performance is intended by a solo instrument.
    ensemble -- The ensemble element is present if performance is intended by an ensemble such as an orchestral section. The text of the ensemble element contains the size of the section, or is empty if the ensemble size is not specified.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, instrument_sound=None, solo=None, ensemble=None, virtual_instrument=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.instrument_sound = instrument_sound
        self.instrument_sound_nsprefix_ = None
        self.solo = solo
        self.solo_nsprefix_ = None
        self.ensemble = ensemble
        self.validate_positive_integer_or_empty(self.ensemble)
        self.ensemble_nsprefix_ = None
        self.virtual_instrument = virtual_instrument
        self.virtual_instrument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instrument_change)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instrument_change.subclass:
            return instrument_change.subclass(*args_, **kwargs_)
        else:
            return instrument_change(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_instrument_sound(self):
        return self.instrument_sound
    def set_instrument_sound(self, instrument_sound):
        self.instrument_sound = instrument_sound
    def get_solo(self):
        return self.solo
    def set_solo(self, solo):
        self.solo = solo
    def get_ensemble(self):
        return self.ensemble
    def set_ensemble(self, ensemble):
        self.ensemble = ensemble
    def get_virtual_instrument(self):
        return self.virtual_instrument
    def set_virtual_instrument(self, virtual_instrument):
        self.virtual_instrument = virtual_instrument
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_positive_integer_or_empty(self, value):
        result = True
        # Validate type positive-integer-or-empty, a restriction on xs:string.
        pass
        return result
    def _hasContent(self):
        if (
            self.instrument_sound is not None or
            self.solo is not None or
            self.ensemble is not None or
            self.virtual_instrument is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='instrument-change', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instrument-change')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instrument-change':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instrument-change')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instrument-change', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='instrument-change'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='instrument-change', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.instrument_sound is not None:
            namespaceprefix_ = self.instrument_sound_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_sound_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstrument-sound>%s</%sinstrument-sound>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.instrument_sound), input_name='instrument-sound')), namespaceprefix_ , eol_))
        if self.solo is not None:
            namespaceprefix_ = self.solo_nsprefix_ + ':' if (UseCapturedNS_ and self.solo_nsprefix_) else ''
            self.solo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='solo', pretty_print=pretty_print)
        if self.ensemble is not None:
            namespaceprefix_ = self.ensemble_nsprefix_ + ':' if (UseCapturedNS_ and self.ensemble_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sensemble>%s</%sensemble>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ensemble), input_name='ensemble')), namespaceprefix_ , eol_))
        if self.virtual_instrument is not None:
            namespaceprefix_ = self.virtual_instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.virtual_instrument_nsprefix_) else ''
            self.virtual_instrument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='virtual-instrument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'instrument-sound':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'instrument_sound')
            value_ = self.gds_validate_string(value_, node, 'instrument_sound')
            self.instrument_sound = value_
            self.instrument_sound_nsprefix_ = child_.prefix
        elif nodeName_ == 'solo':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.solo = obj_
            obj_.original_tagname_ = 'solo'
        elif nodeName_ == 'ensemble':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ensemble')
            value_ = self.gds_validate_string(value_, node, 'ensemble')
            self.ensemble = value_
            self.ensemble_nsprefix_ = child_.prefix
            # validate type positive-integer-or-empty
            self.validate_positive_integer_or_empty(self.ensemble)
        elif nodeName_ == 'virtual-instrument':
            obj_ = virtual_instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.virtual_instrument = obj_
            obj_.original_tagname_ = 'virtual-instrument'
# end class instrument_change


class inversion(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, text=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, inversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if inversion.subclass:
            return inversion.subclass(*args_, **kwargs_)
        else:
            return inversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='inversion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('inversion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'inversion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='inversion')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='inversion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='inversion'):
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='inversion', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class inversion


class kind(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, use_symbols=None, text=None, stack_degrees=None, parentheses_degrees=None, bracket_degrees=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.use_symbols = _cast(None, use_symbols)
        self.use_symbols_nsprefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.stack_degrees = _cast(None, stack_degrees)
        self.stack_degrees_nsprefix_ = None
        self.parentheses_degrees = _cast(None, parentheses_degrees)
        self.parentheses_degrees_nsprefix_ = None
        self.bracket_degrees = _cast(None, bracket_degrees)
        self.bracket_degrees_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, kind)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if kind.subclass:
            return kind.subclass(*args_, **kwargs_)
        else:
            return kind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_use_symbols(self):
        return self.use_symbols
    def set_use_symbols(self, use_symbols):
        self.use_symbols = use_symbols
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_stack_degrees(self):
        return self.stack_degrees
    def set_stack_degrees(self, stack_degrees):
        self.stack_degrees = stack_degrees
    def get_parentheses_degrees(self):
        return self.parentheses_degrees
    def set_parentheses_degrees(self, parentheses_degrees):
        self.parentheses_degrees = parentheses_degrees
    def get_bracket_degrees(self):
        return self.bracket_degrees
    def set_bracket_degrees(self, bracket_degrees):
        self.bracket_degrees = bracket_degrees
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_kind_value(self, value):
        result = True
        # Validate type kind-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['major', 'minor', 'augmented', 'diminished', 'dominant', 'major-seventh', 'minor-seventh', 'diminished-seventh', 'augmented-seventh', 'half-diminished', 'major-minor', 'major-sixth', 'minor-sixth', 'dominant-ninth', 'major-ninth', 'minor-ninth', 'dominant-11th', 'major-11th', 'minor-11th', 'dominant-13th', 'major-13th', 'minor-13th', 'suspended-second', 'suspended-fourth', 'Neapolitan', 'Italian', 'French', 'German', 'pedal', 'power', 'Tristan', 'other', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on kind-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='kind', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('kind')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'kind':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='kind')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='kind', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='kind'):
        if self.use_symbols is not None and 'use_symbols' not in already_processed:
            already_processed.add('use_symbols')
            outfile.write(' use-symbols=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.use_symbols), input_name='use-symbols')), ))
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.stack_degrees is not None and 'stack_degrees' not in already_processed:
            already_processed.add('stack_degrees')
            outfile.write(' stack-degrees=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.stack_degrees), input_name='stack-degrees')), ))
        if self.parentheses_degrees is not None and 'parentheses_degrees' not in already_processed:
            already_processed.add('parentheses_degrees')
            outfile.write(' parentheses-degrees=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentheses_degrees), input_name='parentheses-degrees')), ))
        if self.bracket_degrees is not None and 'bracket_degrees' not in already_processed:
            already_processed.add('bracket_degrees')
            outfile.write(' bracket-degrees=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bracket_degrees), input_name='bracket-degrees')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='kind', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use-symbols', node)
        if value is not None and 'use-symbols' not in already_processed:
            already_processed.add('use-symbols')
            self.use_symbols = value
            self.use_symbols = ' '.join(self.use_symbols.split())
            self.validate_yes_no(self.use_symbols)    # validate type yes-no
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
        value = find_attr_value_('stack-degrees', node)
        if value is not None and 'stack-degrees' not in already_processed:
            already_processed.add('stack-degrees')
            self.stack_degrees = value
            self.stack_degrees = ' '.join(self.stack_degrees.split())
            self.validate_yes_no(self.stack_degrees)    # validate type yes-no
        value = find_attr_value_('parentheses-degrees', node)
        if value is not None and 'parentheses-degrees' not in already_processed:
            already_processed.add('parentheses-degrees')
            self.parentheses_degrees = value
            self.parentheses_degrees = ' '.join(self.parentheses_degrees.split())
            self.validate_yes_no(self.parentheses_degrees)    # validate type yes-no
        value = find_attr_value_('bracket-degrees', node)
        if value is not None and 'bracket-degrees' not in already_processed:
            already_processed.add('bracket-degrees')
            self.bracket_degrees = value
            self.bracket_degrees = ' '.join(self.bracket_degrees.split())
            self.validate_yes_no(self.bracket_degrees)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class kind


class listening(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sync=None, other_listening=None, offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if sync is None:
            self.sync = []
        else:
            self.sync = sync
        self.sync_nsprefix_ = None
        if other_listening is None:
            self.other_listening = []
        else:
            self.other_listening = other_listening
        self.other_listening_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listening)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listening.subclass:
            return listening.subclass(*args_, **kwargs_)
        else:
            return listening(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sync(self):
        return self.sync
    def set_sync(self, sync):
        self.sync = sync
    def add_sync(self, value):
        self.sync.append(value)
    def insert_sync_at(self, index, value):
        self.sync.insert(index, value)
    def replace_sync_at(self, index, value):
        self.sync[index] = value
    def get_other_listening(self):
        return self.other_listening
    def set_other_listening(self, other_listening):
        self.other_listening = other_listening
    def add_other_listening(self, value):
        self.other_listening.append(value)
    def insert_other_listening_at(self, index, value):
        self.other_listening.insert(index, value)
    def replace_other_listening_at(self, index, value):
        self.other_listening[index] = value
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def _hasContent(self):
        if (
            self.sync or
            self.other_listening or
            self.offset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listening', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listening')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'listening':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listening')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listening', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listening'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listening', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sync_ in self.sync:
            namespaceprefix_ = self.sync_nsprefix_ + ':' if (UseCapturedNS_ and self.sync_nsprefix_) else ''
            sync_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sync', pretty_print=pretty_print)
        for other_listening_ in self.other_listening:
            namespaceprefix_ = self.other_listening_nsprefix_ + ':' if (UseCapturedNS_ and self.other_listening_nsprefix_) else ''
            other_listening_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-listening', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sync':
            obj_ = sync.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sync.append(obj_)
            obj_.original_tagname_ = 'sync'
        elif nodeName_ == 'other-listening':
            obj_ = other_listening.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_listening.append(obj_)
            obj_.original_tagname_ = 'other-listening'
        elif nodeName_ == 'offset':
            obj_ = offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
# end class listening


class measure_numbering(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, system=None, staff=None, multiple_rest_always=None, multiple_rest_range=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.staff = _cast(int, staff)
        self.staff_nsprefix_ = None
        self.multiple_rest_always = _cast(None, multiple_rest_always)
        self.multiple_rest_always_nsprefix_ = None
        self.multiple_rest_range = _cast(None, multiple_rest_range)
        self.multiple_rest_range_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, measure_numbering)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if measure_numbering.subclass:
            return measure_numbering.subclass(*args_, **kwargs_)
        else:
            return measure_numbering(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_staff(self):
        return self.staff
    def set_staff(self, staff):
        self.staff = staff
    def get_multiple_rest_always(self):
        return self.multiple_rest_always
    def set_multiple_rest_always(self, multiple_rest_always):
        self.multiple_rest_always = multiple_rest_always
    def get_multiple_rest_range(self):
        return self.multiple_rest_range
    def set_multiple_rest_range(self, multiple_rest_range):
        self.multiple_rest_range = multiple_rest_range
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_measure_numbering_value(self, value):
        result = True
        # Validate type measure-numbering-value, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'measure', 'system']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on measure-numbering-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_system_relation_number(self, value):
        # Validate type system-relation-number, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['only-top', 'only-bottom', 'also-top', 'also-bottom', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on system-relation-number' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measure-numbering', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('measure-numbering')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'measure-numbering':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='measure-numbering')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='measure-numbering', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='measure-numbering'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.system), input_name='system')), ))
        if self.staff is not None and 'staff' not in already_processed:
            already_processed.add('staff')
            outfile.write(' staff="%s"' % self.gds_format_integer(self.staff, input_name='staff'))
        if self.multiple_rest_always is not None and 'multiple_rest_always' not in already_processed:
            already_processed.add('multiple_rest_always')
            outfile.write(' multiple-rest-always=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.multiple_rest_always), input_name='multiple-rest-always')), ))
        if self.multiple_rest_range is not None and 'multiple_rest_range' not in already_processed:
            already_processed.add('multiple_rest_range')
            outfile.write(' multiple-rest-range=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.multiple_rest_range), input_name='multiple-rest-range')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measure-numbering', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
            self.validate_system_relation_number(self.system)    # validate type system-relation-number
        value = find_attr_value_('staff', node)
        if value is not None and 'staff' not in already_processed:
            already_processed.add('staff')
            self.staff = self.gds_parse_integer(value, node, 'staff')
            if self.staff <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.staff)    # validate type staff-number
        value = find_attr_value_('multiple-rest-always', node)
        if value is not None and 'multiple-rest-always' not in already_processed:
            already_processed.add('multiple-rest-always')
            self.multiple_rest_always = value
            self.multiple_rest_always = ' '.join(self.multiple_rest_always.split())
            self.validate_yes_no(self.multiple_rest_always)    # validate type yes-no
        value = find_attr_value_('multiple-rest-range', node)
        if value is not None and 'multiple-rest-range' not in already_processed:
            already_processed.add('multiple-rest-range')
            self.multiple_rest_range = value
            self.multiple_rest_range = ' '.join(self.multiple_rest_range.split())
            self.validate_yes_no(self.multiple_rest_range)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class measure_numbering


class membrane(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, membrane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if membrane.subclass:
            return membrane.subclass(*args_, **kwargs_)
        else:
            return membrane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_membrane_value(self, value):
        result = True
        # Validate type membrane-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['bass drum', 'bass drum on side', 'bongos', 'Chinese tomtom', 'conga drum', 'cuica', 'goblet drum', 'Indo-American tomtom', 'Japanese tomtom', 'military drum', 'snare drum', 'snare drum snares off', 'tabla', 'tambourine', 'tenor drum', 'timbales', 'tomtom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on membrane-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_pictogram_glyph_name(self, value):
        # Validate type smufl-pictogram-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_pictogram_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_pictogram_glyph_name_patterns_, ))
    validate_smufl_pictogram_glyph_name_patterns_ = [['^(pict\\c+)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='membrane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('membrane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'membrane':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='membrane')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='membrane', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='membrane'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='membrane', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_pictogram_glyph_name(self.smufl)    # validate type smufl-pictogram-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class membrane


class metal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metal.subclass:
            return metal.subclass(*args_, **kwargs_)
        else:
            return metal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_metal_value(self, value):
        result = True
        # Validate type metal-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['agogo', 'almglocken', 'bell', 'bell plate', 'bell tree', 'brake drum', 'cencerro', 'chain rattle', 'Chinese cymbal', 'cowbell', 'crash cymbals', 'crotale', 'cymbal tongs', 'domed gong', 'finger cymbals', 'flexatone', 'gong', 'hi-hat', 'high-hat cymbals', 'handbell', 'jaw harp', 'jingle bells', 'musical saw', 'shell bells', 'sistrum', 'sizzle cymbal', 'sleigh bells', 'suspended cymbal', 'tam tam', 'tam tam with beater', 'triangle', 'Vietnamese hat']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on metal-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_pictogram_glyph_name(self, value):
        # Validate type smufl-pictogram-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_pictogram_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_pictogram_glyph_name_patterns_, ))
    validate_smufl_pictogram_glyph_name_patterns_ = [['^(pict\\c+)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metal':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metal')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metal'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metal', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_pictogram_glyph_name(self.smufl)    # validate type smufl-pictogram-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class metal


class metronome(GeneratedsSuper):
    """beat-unit -- The beat-unit element indicates the graphical note type to use in a metronome mark.
    beat-unit-dot -- The beat-unit-dot element is used to specify any augmentation dots for a metronome mark note.
    metronome-arrows -- If the metronome-arrows element is present, it indicates that metric modulation arrows are displayed on both sides of the metronome mark.
    metronome-relation -- The metronome-relation element describes the relationship symbol that goes between the two sets of metronome-note elements. The currently allowed value is equals, but this may expand in future versions. If the element is empty, the equals value is used.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, parentheses=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, print_object=None, justify=None, id=None, per_minute=None, beat_unit=None, beat_unit_dot=None, beat_unit_tied=None, metronome_arrows=None, metronome_relation=None, metronome_note=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.parentheses = _cast(None, parentheses)
        self.parentheses_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.per_minute = per_minute
        self.per_minute_nsprefix_ = None
        self.beat_unit = beat_unit
        self.validate_note_type_value(self.beat_unit)
        self.beat_unit_nsprefix_ = None
        if beat_unit_dot is None:
            self.beat_unit_dot = []
        else:
            self.beat_unit_dot = beat_unit_dot
        self.beat_unit_dot_nsprefix_ = None
        if beat_unit_tied is None:
            self.beat_unit_tied = []
        else:
            self.beat_unit_tied = beat_unit_tied
        self.beat_unit_tied_nsprefix_ = None
        self.metronome_arrows = metronome_arrows
        self.metronome_arrows_nsprefix_ = None
        self.metronome_relation = metronome_relation
        self.metronome_relation_nsprefix_ = None
        if metronome_note is None:
            self.metronome_note = []
        else:
            self.metronome_note = metronome_note
        self.metronome_note_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metronome)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metronome.subclass:
            return metronome.subclass(*args_, **kwargs_)
        else:
            return metronome(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_per_minute(self):
        return self.per_minute
    def set_per_minute(self, per_minute):
        self.per_minute = per_minute
    def get_beat_unit(self):
        return self.beat_unit
    def set_beat_unit(self, beat_unit):
        self.beat_unit = beat_unit
    def get_beat_unit_dot(self):
        return self.beat_unit_dot
    def set_beat_unit_dot(self, beat_unit_dot):
        self.beat_unit_dot = beat_unit_dot
    def add_beat_unit_dot(self, value):
        self.beat_unit_dot.append(value)
    def insert_beat_unit_dot_at(self, index, value):
        self.beat_unit_dot.insert(index, value)
    def replace_beat_unit_dot_at(self, index, value):
        self.beat_unit_dot[index] = value
    def get_beat_unit_tied(self):
        return self.beat_unit_tied
    def set_beat_unit_tied(self, beat_unit_tied):
        self.beat_unit_tied = beat_unit_tied
    def add_beat_unit_tied(self, value):
        self.beat_unit_tied.append(value)
    def insert_beat_unit_tied_at(self, index, value):
        self.beat_unit_tied.insert(index, value)
    def replace_beat_unit_tied_at(self, index, value):
        self.beat_unit_tied[index] = value
    def get_metronome_arrows(self):
        return self.metronome_arrows
    def set_metronome_arrows(self, metronome_arrows):
        self.metronome_arrows = metronome_arrows
    def get_metronome_relation(self):
        return self.metronome_relation
    def set_metronome_relation(self, metronome_relation):
        self.metronome_relation = metronome_relation
    def get_metronome_note(self):
        return self.metronome_note
    def set_metronome_note(self, metronome_note):
        self.metronome_note = metronome_note
    def add_metronome_note(self, value):
        self.metronome_note.append(value)
    def insert_metronome_note_at(self, index, value):
        self.metronome_note.insert(index, value)
    def replace_metronome_note_at(self, index, value):
        self.metronome_note[index] = value
    def get_parentheses(self):
        return self.parentheses
    def set_parentheses(self, parentheses):
        self.parentheses = parentheses
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_note_type_value(self, value):
        result = True
        # Validate type note-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.per_minute is not None or
            self.beat_unit is not None or
            self.beat_unit_dot or
            self.beat_unit_tied or
            self.metronome_arrows is not None or
            self.metronome_relation is not None or
            self.metronome_note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metronome')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metronome':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metronome')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metronome', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metronome'):
        if self.parentheses is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            outfile.write(' parentheses=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentheses), input_name='parentheses')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.per_minute is not None:
            namespaceprefix_ = self.per_minute_nsprefix_ + ':' if (UseCapturedNS_ and self.per_minute_nsprefix_) else ''
            self.per_minute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='per-minute', pretty_print=pretty_print)
        if self.beat_unit is not None:
            namespaceprefix_ = self.beat_unit_nsprefix_ + ':' if (UseCapturedNS_ and self.beat_unit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeat-unit>%s</%sbeat-unit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.beat_unit), input_name='beat-unit')), namespaceprefix_ , eol_))
        for beat_unit_dot_ in self.beat_unit_dot:
            namespaceprefix_ = self.beat_unit_dot_nsprefix_ + ':' if (UseCapturedNS_ and self.beat_unit_dot_nsprefix_) else ''
            beat_unit_dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='beat-unit-dot', pretty_print=pretty_print)
        for beat_unit_tied_ in self.beat_unit_tied:
            namespaceprefix_ = self.beat_unit_tied_nsprefix_ + ':' if (UseCapturedNS_ and self.beat_unit_tied_nsprefix_) else ''
            beat_unit_tied_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='beat-unit-tied', pretty_print=pretty_print)
        if self.metronome_arrows is not None:
            namespaceprefix_ = self.metronome_arrows_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_arrows_nsprefix_) else ''
            self.metronome_arrows.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metronome-arrows', pretty_print=pretty_print)
        if self.metronome_relation is not None:
            namespaceprefix_ = self.metronome_relation_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_relation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smetronome-relation>%s</%smetronome-relation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.metronome_relation), input_name='metronome-relation')), namespaceprefix_ , eol_))
        for metronome_note_ in self.metronome_note:
            namespaceprefix_ = self.metronome_note_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_note_nsprefix_) else ''
            metronome_note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metronome-note', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parentheses', node)
        if value is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            self.parentheses = value
            self.parentheses = ' '.join(self.parentheses.split())
            self.validate_yes_no(self.parentheses)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'per-minute':
            obj_ = per_minute.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.per_minute = obj_
            obj_.original_tagname_ = 'per-minute'
        elif nodeName_ == 'beat-unit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'beat_unit')
            value_ = self.gds_validate_string(value_, node, 'beat_unit')
            self.beat_unit = value_
            self.beat_unit_nsprefix_ = child_.prefix
            # validate type note-type-value
            self.validate_note_type_value(self.beat_unit)
        elif nodeName_ == 'beat-unit-dot':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.beat_unit_dot.append(obj_)
            obj_.original_tagname_ = 'beat-unit-dot'
        elif nodeName_ == 'beat-unit-tied':
            obj_ = beat_unit_tied.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.beat_unit_tied.append(obj_)
            obj_.original_tagname_ = 'beat-unit-tied'
        elif nodeName_ == 'metronome-arrows':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metronome_arrows = obj_
            obj_.original_tagname_ = 'metronome-arrows'
        elif nodeName_ == 'metronome-relation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'metronome_relation')
            value_ = self.gds_validate_string(value_, node, 'metronome_relation')
            self.metronome_relation = value_
            self.metronome_relation_nsprefix_ = child_.prefix
        elif nodeName_ == 'metronome-note':
            obj_ = metronome_note.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metronome_note.append(obj_)
            obj_.original_tagname_ = 'metronome-note'
# end class metronome


class metronome_beam(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number='1', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metronome_beam)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metronome_beam.subclass:
            return metronome_beam.subclass(*args_, **kwargs_)
        else:
            return metronome_beam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_beam_value(self, value):
        result = True
        # Validate type beam-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['begin', 'continue', 'end', 'forward hook', 'backward hook']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on beam-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_beam_level(self, value):
        # Validate type beam-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on beam-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on beam-level' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome-beam', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metronome-beam')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metronome-beam':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metronome-beam')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metronome-beam', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metronome-beam'):
        if self.number != 1 and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome-beam', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_beam_level(self.number)    # validate type beam-level
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class metronome_beam


class metronome_note(GeneratedsSuper):
    """metronome-type -- The metronome-type element works like the type element in defining metric relationships.
    metronome-dot -- The metronome-dot element works like the dot element in defining metric relationships.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, metronome_type=None, metronome_dot=None, metronome_beam=None, metronome_tied=None, metronome_tuplet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.metronome_type = metronome_type
        self.validate_note_type_value(self.metronome_type)
        self.metronome_type_nsprefix_ = None
        if metronome_dot is None:
            self.metronome_dot = []
        else:
            self.metronome_dot = metronome_dot
        self.metronome_dot_nsprefix_ = None
        if metronome_beam is None:
            self.metronome_beam = []
        else:
            self.metronome_beam = metronome_beam
        self.metronome_beam_nsprefix_ = None
        self.metronome_tied = metronome_tied
        self.metronome_tied_nsprefix_ = None
        self.metronome_tuplet = metronome_tuplet
        self.metronome_tuplet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metronome_note)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metronome_note.subclass:
            return metronome_note.subclass(*args_, **kwargs_)
        else:
            return metronome_note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_metronome_type(self):
        return self.metronome_type
    def set_metronome_type(self, metronome_type):
        self.metronome_type = metronome_type
    def get_metronome_dot(self):
        return self.metronome_dot
    def set_metronome_dot(self, metronome_dot):
        self.metronome_dot = metronome_dot
    def add_metronome_dot(self, value):
        self.metronome_dot.append(value)
    def insert_metronome_dot_at(self, index, value):
        self.metronome_dot.insert(index, value)
    def replace_metronome_dot_at(self, index, value):
        self.metronome_dot[index] = value
    def get_metronome_beam(self):
        return self.metronome_beam
    def set_metronome_beam(self, metronome_beam):
        self.metronome_beam = metronome_beam
    def add_metronome_beam(self, value):
        self.metronome_beam.append(value)
    def insert_metronome_beam_at(self, index, value):
        self.metronome_beam.insert(index, value)
    def replace_metronome_beam_at(self, index, value):
        self.metronome_beam[index] = value
    def get_metronome_tied(self):
        return self.metronome_tied
    def set_metronome_tied(self, metronome_tied):
        self.metronome_tied = metronome_tied
    def get_metronome_tuplet(self):
        return self.metronome_tuplet
    def set_metronome_tuplet(self, metronome_tuplet):
        self.metronome_tuplet = metronome_tuplet
    def validate_note_type_value(self, value):
        result = True
        # Validate type note-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.metronome_type is not None or
            self.metronome_dot or
            self.metronome_beam or
            self.metronome_tied is not None or
            self.metronome_tuplet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome-note', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metronome-note')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metronome-note':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metronome-note')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metronome-note', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metronome-note'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome-note', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.metronome_type is not None:
            namespaceprefix_ = self.metronome_type_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smetronome-type>%s</%smetronome-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.metronome_type), input_name='metronome-type')), namespaceprefix_ , eol_))
        for metronome_dot_ in self.metronome_dot:
            namespaceprefix_ = self.metronome_dot_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_dot_nsprefix_) else ''
            metronome_dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metronome-dot', pretty_print=pretty_print)
        for metronome_beam_ in self.metronome_beam:
            namespaceprefix_ = self.metronome_beam_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_beam_nsprefix_) else ''
            metronome_beam_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metronome-beam', pretty_print=pretty_print)
        if self.metronome_tied is not None:
            namespaceprefix_ = self.metronome_tied_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_tied_nsprefix_) else ''
            self.metronome_tied.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metronome-tied', pretty_print=pretty_print)
        if self.metronome_tuplet is not None:
            namespaceprefix_ = self.metronome_tuplet_nsprefix_ + ':' if (UseCapturedNS_ and self.metronome_tuplet_nsprefix_) else ''
            self.metronome_tuplet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metronome-tuplet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'metronome-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'metronome_type')
            value_ = self.gds_validate_string(value_, node, 'metronome_type')
            self.metronome_type = value_
            self.metronome_type_nsprefix_ = child_.prefix
            # validate type note-type-value
            self.validate_note_type_value(self.metronome_type)
        elif nodeName_ == 'metronome-dot':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metronome_dot.append(obj_)
            obj_.original_tagname_ = 'metronome-dot'
        elif nodeName_ == 'metronome-beam':
            obj_ = metronome_beam.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metronome_beam.append(obj_)
            obj_.original_tagname_ = 'metronome-beam'
        elif nodeName_ == 'metronome-tied':
            obj_ = metronome_tied.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metronome_tied = obj_
            obj_.original_tagname_ = 'metronome-tied'
        elif nodeName_ == 'metronome-tuplet':
            obj_ = metronome_tuplet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metronome_tuplet = obj_
            obj_.original_tagname_ = 'metronome-tuplet'
# end class metronome_note


class metronome_tied(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metronome_tied)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metronome_tied.subclass:
            return metronome_tied.subclass(*args_, **kwargs_)
        else:
            return metronome_tied(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome-tied', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metronome-tied')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metronome-tied':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metronome-tied')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metronome-tied', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metronome-tied'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome-tied', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class metronome_tied


class numeral(GeneratedsSuper):
    """numeral-alter -- The numeral-alter element represents an alteration to the numeral-root, similar to the alter element for a pitch. The print-object attribute can be used to hide an alteration in cases such as when the MusicXML encoding of a 6 or 7 numeral-root in a minor key requires an alteration that is not displayed. The location attribute indicates whether the alteration should appear to the left or the right of the numeral-root. It is left by default.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numeral_root=None, numeral_alter=None, numeral_key=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numeral_root = numeral_root
        self.numeral_root_nsprefix_ = None
        self.numeral_alter = numeral_alter
        self.numeral_alter_nsprefix_ = None
        self.numeral_key = numeral_key
        self.numeral_key_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, numeral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if numeral.subclass:
            return numeral.subclass(*args_, **kwargs_)
        else:
            return numeral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numeral_root(self):
        return self.numeral_root
    def set_numeral_root(self, numeral_root):
        self.numeral_root = numeral_root
    def get_numeral_alter(self):
        return self.numeral_alter
    def set_numeral_alter(self, numeral_alter):
        self.numeral_alter = numeral_alter
    def get_numeral_key(self):
        return self.numeral_key
    def set_numeral_key(self, numeral_key):
        self.numeral_key = numeral_key
    def _hasContent(self):
        if (
            self.numeral_root is not None or
            self.numeral_alter is not None or
            self.numeral_key is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='numeral', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('numeral')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'numeral':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='numeral')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='numeral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='numeral'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='numeral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numeral_root is not None:
            namespaceprefix_ = self.numeral_root_nsprefix_ + ':' if (UseCapturedNS_ and self.numeral_root_nsprefix_) else ''
            self.numeral_root.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numeral-root', pretty_print=pretty_print)
        if self.numeral_alter is not None:
            namespaceprefix_ = self.numeral_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.numeral_alter_nsprefix_) else ''
            self.numeral_alter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numeral-alter', pretty_print=pretty_print)
        if self.numeral_key is not None:
            namespaceprefix_ = self.numeral_key_nsprefix_ + ':' if (UseCapturedNS_ and self.numeral_key_nsprefix_) else ''
            self.numeral_key.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numeral-key', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numeral-root':
            obj_ = numeral_root.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numeral_root = obj_
            obj_.original_tagname_ = 'numeral-root'
        elif nodeName_ == 'numeral-alter':
            obj_ = harmony_alter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numeral_alter = obj_
            obj_.original_tagname_ = 'numeral-alter'
        elif nodeName_ == 'numeral-key':
            obj_ = numeral_key.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numeral_key = obj_
            obj_.original_tagname_ = 'numeral-key'
# end class numeral


class numeral_key(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, print_object=None, numeral_fifths=None, numeral_mode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.numeral_fifths = numeral_fifths
        self.validate_fifths(self.numeral_fifths)
        self.numeral_fifths_nsprefix_ = None
        self.numeral_mode = numeral_mode
        self.validate_numeral_mode(self.numeral_mode)
        self.numeral_mode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, numeral_key)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if numeral_key.subclass:
            return numeral_key.subclass(*args_, **kwargs_)
        else:
            return numeral_key(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numeral_fifths(self):
        return self.numeral_fifths
    def set_numeral_fifths(self, numeral_fifths):
        self.numeral_fifths = numeral_fifths
    def get_numeral_mode(self):
        return self.numeral_mode
    def set_numeral_mode(self, numeral_mode):
        self.numeral_mode = numeral_mode
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def validate_fifths(self, value):
        result = True
        # Validate type fifths, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_numeral_mode(self, value):
        result = True
        # Validate type numeral-mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['major', 'minor', 'natural minor', 'melodic minor', 'harmonic minor']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on numeral-mode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.numeral_fifths is not None or
            self.numeral_mode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='numeral-key', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('numeral-key')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'numeral-key':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='numeral-key')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='numeral-key', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='numeral-key'):
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='numeral-key', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numeral_fifths is not None:
            namespaceprefix_ = self.numeral_fifths_nsprefix_ + ':' if (UseCapturedNS_ and self.numeral_fifths_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumeral-fifths>%s</%snumeral-fifths>%s' % (namespaceprefix_ , self.gds_format_integer(self.numeral_fifths, input_name='numeral-fifths'), namespaceprefix_ , eol_))
        if self.numeral_mode is not None:
            namespaceprefix_ = self.numeral_mode_nsprefix_ + ':' if (UseCapturedNS_ and self.numeral_mode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumeral-mode>%s</%snumeral-mode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.numeral_mode), input_name='numeral-mode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numeral-fifths' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'numeral_fifths')
            ival_ = self.gds_validate_integer(ival_, node, 'numeral_fifths')
            self.numeral_fifths = ival_
            self.numeral_fifths_nsprefix_ = child_.prefix
            # validate type fifths
            self.validate_fifths(self.numeral_fifths)
        elif nodeName_ == 'numeral-mode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'numeral_mode')
            value_ = self.gds_validate_string(value_, node, 'numeral_mode')
            self.numeral_mode = value_
            self.numeral_mode_nsprefix_ = child_.prefix
            # validate type numeral-mode
            self.validate_numeral_mode(self.numeral_mode)
# end class numeral_key


class numeral_root(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, text=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, numeral_root)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if numeral_root.subclass:
            return numeral_root.subclass(*args_, **kwargs_)
        else:
            return numeral_root(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_numeral_value(self, value):
        result = True
        # Validate type numeral-value, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on numeral-value' % {"value": value, "lineno": lineno} )
                result = False
            if value > 7:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on numeral-value' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='numeral-root', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('numeral-root')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'numeral-root':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='numeral-root')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='numeral-root', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='numeral-root'):
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='numeral-root', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class numeral_root


class octave_shift(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, size=8, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.size = _cast(int, size)
        self.size_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, octave_shift)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if octave_shift.subclass:
            return octave_shift.subclass(*args_, **kwargs_)
        else:
            return octave_shift(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_up_down_stop_continue(self, value):
        # Validate type up-down-stop-continue, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['up', 'down', 'stop', 'continue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on up-down-stop-continue' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='octave-shift', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('octave-shift')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'octave-shift':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='octave-shift')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='octave-shift', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='octave-shift'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.size != 8 and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='octave-shift', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_up_down_stop_continue(self.type_)    # validate type up-down-stop-continue
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = self.gds_parse_integer(value, node, 'size')
            if self.size <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class octave_shift


class offset(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sound=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sound = _cast(None, sound)
        self.sound_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if offset.subclass:
            return offset.subclass(*args_, **kwargs_)
        else:
            return offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sound(self):
        return self.sound
    def set_sound(self, sound):
        self.sound = sound
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_divisions(self, value):
        result = True
        # Validate type divisions, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='offset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('offset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'offset':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='offset')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='offset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='offset'):
        if self.sound is not None and 'sound' not in already_processed:
            already_processed.add('sound')
            outfile.write(' sound=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sound), input_name='sound')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='offset', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sound', node)
        if value is not None and 'sound' not in already_processed:
            already_processed.add('sound')
            self.sound = value
            self.sound = ' '.join(self.sound.split())
            self.validate_yes_no(self.sound)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class offset


class other_direction(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, print_object=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, smufl=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, other_direction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if other_direction.subclass:
            return other_direction.subclass(*args_, **kwargs_)
        else:
            return other_direction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_smufl_glyph_name(self, value):
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-direction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('other-direction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'other-direction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='other-direction')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='other-direction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='other-direction'):
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smufl), input_name='smufl')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-direction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_glyph_name(self.smufl)    # validate type smufl-glyph-name
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class other_direction


class other_listening(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, player=None, time_only=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.player = _cast(None, player)
        self.player_nsprefix_ = None
        self.time_only = _cast(None, time_only)
        self.time_only_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, other_listening)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if other_listening.subclass:
            return other_listening.subclass(*args_, **kwargs_)
        else:
            return other_listening(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_player(self):
        return self.player
    def set_player(self, player):
        self.player = player
    def get_time_only(self):
        return self.time_only
    def set_time_only(self, time_only):
        self.time_only = time_only
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_time_only(self, value):
        # Validate type time-only, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_time_only_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_time_only_patterns_, ))
    validate_time_only_patterns_ = [['^([1-9][0-9]*(, ?[1-9][0-9]*)*)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-listening', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('other-listening')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'other-listening':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='other-listening')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='other-listening', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='other-listening'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.player is not None and 'player' not in already_processed:
            already_processed.add('player')
            outfile.write(' player=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.player), input_name='player')), ))
        if self.time_only is not None and 'time_only' not in already_processed:
            already_processed.add('time_only')
            outfile.write(' time-only=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time_only), input_name='time-only')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-listening', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
        value = find_attr_value_('player', node)
        if value is not None and 'player' not in already_processed:
            already_processed.add('player')
            self.player = value
        value = find_attr_value_('time-only', node)
        if value is not None and 'time-only' not in already_processed:
            already_processed.add('time-only')
            self.time_only = value
            self.time_only = ' '.join(self.time_only.split())
            self.validate_time_only(self.time_only)    # validate type time-only
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class other_listening


class pedal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, line=None, sign=None, abbreviated=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.line = _cast(None, line)
        self.line_nsprefix_ = None
        self.sign = _cast(None, sign)
        self.sign_nsprefix_ = None
        self.abbreviated = _cast(None, abbreviated)
        self.abbreviated_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pedal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pedal.subclass:
            return pedal.subclass(*args_, **kwargs_)
        else:
            return pedal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_sign(self):
        return self.sign
    def set_sign(self, sign):
        self.sign = sign
    def get_abbreviated(self):
        return self.abbreviated
    def set_abbreviated(self, abbreviated):
        self.abbreviated = abbreviated
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_pedal_type(self, value):
        # Validate type pedal-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'sostenuto', 'change', 'continue', 'discontinue', 'resume']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on pedal-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pedal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pedal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pedal':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pedal')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pedal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pedal'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.line is not None and 'line' not in already_processed:
            already_processed.add('line')
            outfile.write(' line=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line), input_name='line')), ))
        if self.sign is not None and 'sign' not in already_processed:
            already_processed.add('sign')
            outfile.write(' sign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sign), input_name='sign')), ))
        if self.abbreviated is not None and 'abbreviated' not in already_processed:
            already_processed.add('abbreviated')
            outfile.write(' abbreviated=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbreviated), input_name='abbreviated')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pedal', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_pedal_type(self.type_)    # validate type pedal-type
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('line', node)
        if value is not None and 'line' not in already_processed:
            already_processed.add('line')
            self.line = value
            self.line = ' '.join(self.line.split())
            self.validate_yes_no(self.line)    # validate type yes-no
        value = find_attr_value_('sign', node)
        if value is not None and 'sign' not in already_processed:
            already_processed.add('sign')
            self.sign = value
            self.sign = ' '.join(self.sign.split())
            self.validate_yes_no(self.sign)    # validate type yes-no
        value = find_attr_value_('abbreviated', node)
        if value is not None and 'abbreviated' not in already_processed:
            already_processed.add('abbreviated')
            self.abbreviated = value
            self.abbreviated = ' '.join(self.abbreviated.split())
            self.validate_yes_no(self.abbreviated)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class pedal


class pedal_tuning(GeneratedsSuper):
    """pedal-step -- The pedal-step element defines the pitch step for a single harp pedal.
    pedal-alter -- The pedal-alter element defines the chromatic alteration for a single harp pedal.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, pedal_step=None, pedal_alter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.pedal_step = pedal_step
        self.validate_step(self.pedal_step)
        self.pedal_step_nsprefix_ = None
        self.pedal_alter = pedal_alter
        self.validate_semitones(self.pedal_alter)
        self.pedal_alter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pedal_tuning)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pedal_tuning.subclass:
            return pedal_tuning.subclass(*args_, **kwargs_)
        else:
            return pedal_tuning(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pedal_step(self):
        return self.pedal_step
    def set_pedal_step(self, pedal_step):
        self.pedal_step = pedal_step
    def get_pedal_alter(self):
        return self.pedal_alter
    def set_pedal_alter(self, pedal_alter):
        self.pedal_alter = pedal_alter
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.pedal_step is not None or
            self.pedal_alter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pedal-tuning', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pedal-tuning')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pedal-tuning':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pedal-tuning')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pedal-tuning', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pedal-tuning'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pedal-tuning', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pedal_step is not None:
            namespaceprefix_ = self.pedal_step_nsprefix_ + ':' if (UseCapturedNS_ and self.pedal_step_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spedal-step>%s</%spedal-step>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pedal_step), input_name='pedal-step')), namespaceprefix_ , eol_))
        if self.pedal_alter is not None:
            namespaceprefix_ = self.pedal_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.pedal_alter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spedal-alter>%s</%spedal-alter>%s' % (namespaceprefix_ , self.gds_format_decimal(self.pedal_alter, input_name='pedal-alter'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pedal-step':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pedal_step')
            value_ = self.gds_validate_string(value_, node, 'pedal_step')
            self.pedal_step = value_
            self.pedal_step_nsprefix_ = child_.prefix
            # validate type step
            self.validate_step(self.pedal_step)
        elif nodeName_ == 'pedal-alter' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'pedal_alter')
            fval_ = self.gds_validate_decimal(fval_, node, 'pedal_alter')
            self.pedal_alter = fval_
            self.pedal_alter_nsprefix_ = child_.prefix
            # validate type semitones
            self.validate_semitones(self.pedal_alter)
# end class pedal_tuning


class per_minute(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, font_family=None, font_style=None, font_size=None, font_weight=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, per_minute)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if per_minute.subclass:
            return per_minute.subclass(*args_, **kwargs_)
        else:
            return per_minute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='per-minute', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('per-minute')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'per-minute':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='per-minute')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='per-minute', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='per-minute'):
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='per-minute', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class per_minute


class percussion(GeneratedsSuper):
    """other-percussion -- The other-percussion element represents percussion pictograms not defined elsewhere.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, enclosure=None, id=None, glass=None, metal=None, wood=None, pitched=None, membrane=None, effect=None, timpani=None, beater=None, stick=None, stick_location=None, other_percussion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.enclosure = _cast(None, enclosure)
        self.enclosure_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.glass = glass
        self.glass_nsprefix_ = None
        self.metal = metal
        self.metal_nsprefix_ = None
        self.wood = wood
        self.wood_nsprefix_ = None
        self.pitched = pitched
        self.pitched_nsprefix_ = None
        self.membrane = membrane
        self.membrane_nsprefix_ = None
        self.effect = effect
        self.effect_nsprefix_ = None
        self.timpani = timpani
        self.timpani_nsprefix_ = None
        self.beater = beater
        self.beater_nsprefix_ = None
        self.stick = stick
        self.stick_nsprefix_ = None
        self.stick_location = stick_location
        self.validate_stick_location(self.stick_location)
        self.stick_location_nsprefix_ = None
        self.other_percussion = other_percussion
        self.other_percussion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, percussion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if percussion.subclass:
            return percussion.subclass(*args_, **kwargs_)
        else:
            return percussion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_glass(self):
        return self.glass
    def set_glass(self, glass):
        self.glass = glass
    def get_metal(self):
        return self.metal
    def set_metal(self, metal):
        self.metal = metal
    def get_wood(self):
        return self.wood
    def set_wood(self, wood):
        self.wood = wood
    def get_pitched(self):
        return self.pitched
    def set_pitched(self, pitched):
        self.pitched = pitched
    def get_membrane(self):
        return self.membrane
    def set_membrane(self, membrane):
        self.membrane = membrane
    def get_effect(self):
        return self.effect
    def set_effect(self, effect):
        self.effect = effect
    def get_timpani(self):
        return self.timpani
    def set_timpani(self, timpani):
        self.timpani = timpani
    def get_beater(self):
        return self.beater
    def set_beater(self, beater):
        self.beater = beater
    def get_stick(self):
        return self.stick
    def set_stick(self, stick):
        self.stick = stick
    def get_stick_location(self):
        return self.stick_location
    def set_stick_location(self, stick_location):
        self.stick_location = stick_location
    def get_other_percussion(self):
        return self.other_percussion
    def set_other_percussion(self, other_percussion):
        self.other_percussion = other_percussion
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_enclosure(self):
        return self.enclosure
    def set_enclosure(self, enclosure):
        self.enclosure = enclosure
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_stick_location(self, value):
        result = True
        # Validate type stick-location, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['center', 'rim', 'cymbal bell', 'cymbal edge']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on stick-location' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_enclosure_shape(self, value):
        # Validate type enclosure-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rectangle', 'square', 'oval', 'circle', 'bracket', 'inverted-bracket', 'triangle', 'diamond', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on enclosure-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.glass is not None or
            self.metal is not None or
            self.wood is not None or
            self.pitched is not None or
            self.membrane is not None or
            self.effect is not None or
            self.timpani is not None or
            self.beater is not None or
            self.stick is not None or
            self.stick_location is not None or
            self.other_percussion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='percussion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('percussion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'percussion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='percussion')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='percussion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='percussion'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.enclosure is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            outfile.write(' enclosure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.enclosure), input_name='enclosure')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='percussion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.glass is not None:
            namespaceprefix_ = self.glass_nsprefix_ + ':' if (UseCapturedNS_ and self.glass_nsprefix_) else ''
            self.glass.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glass', pretty_print=pretty_print)
        if self.metal is not None:
            namespaceprefix_ = self.metal_nsprefix_ + ':' if (UseCapturedNS_ and self.metal_nsprefix_) else ''
            self.metal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metal', pretty_print=pretty_print)
        if self.wood is not None:
            namespaceprefix_ = self.wood_nsprefix_ + ':' if (UseCapturedNS_ and self.wood_nsprefix_) else ''
            self.wood.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wood', pretty_print=pretty_print)
        if self.pitched is not None:
            namespaceprefix_ = self.pitched_nsprefix_ + ':' if (UseCapturedNS_ and self.pitched_nsprefix_) else ''
            self.pitched.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pitched', pretty_print=pretty_print)
        if self.membrane is not None:
            namespaceprefix_ = self.membrane_nsprefix_ + ':' if (UseCapturedNS_ and self.membrane_nsprefix_) else ''
            self.membrane.export(outfile, level, namespaceprefix_, namespacedef_='', name_='membrane', pretty_print=pretty_print)
        if self.effect is not None:
            namespaceprefix_ = self.effect_nsprefix_ + ':' if (UseCapturedNS_ and self.effect_nsprefix_) else ''
            self.effect.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effect', pretty_print=pretty_print)
        if self.timpani is not None:
            namespaceprefix_ = self.timpani_nsprefix_ + ':' if (UseCapturedNS_ and self.timpani_nsprefix_) else ''
            self.timpani.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timpani', pretty_print=pretty_print)
        if self.beater is not None:
            namespaceprefix_ = self.beater_nsprefix_ + ':' if (UseCapturedNS_ and self.beater_nsprefix_) else ''
            self.beater.export(outfile, level, namespaceprefix_, namespacedef_='', name_='beater', pretty_print=pretty_print)
        if self.stick is not None:
            namespaceprefix_ = self.stick_nsprefix_ + ':' if (UseCapturedNS_ and self.stick_nsprefix_) else ''
            self.stick.export(outfile, level, namespaceprefix_, namespacedef_='', name_='stick', pretty_print=pretty_print)
        if self.stick_location is not None:
            namespaceprefix_ = self.stick_location_nsprefix_ + ':' if (UseCapturedNS_ and self.stick_location_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstick-location>%s</%sstick-location>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.stick_location), input_name='stick-location')), namespaceprefix_ , eol_))
        if self.other_percussion is not None:
            namespaceprefix_ = self.other_percussion_nsprefix_ + ':' if (UseCapturedNS_ and self.other_percussion_nsprefix_) else ''
            self.other_percussion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-percussion', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('enclosure', node)
        if value is not None and 'enclosure' not in already_processed:
            already_processed.add('enclosure')
            self.enclosure = value
            self.enclosure = ' '.join(self.enclosure.split())
            self.validate_enclosure_shape(self.enclosure)    # validate type enclosure-shape
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'glass':
            obj_ = glass.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glass = obj_
            obj_.original_tagname_ = 'glass'
        elif nodeName_ == 'metal':
            obj_ = metal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metal = obj_
            obj_.original_tagname_ = 'metal'
        elif nodeName_ == 'wood':
            obj_ = wood.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wood = obj_
            obj_.original_tagname_ = 'wood'
        elif nodeName_ == 'pitched':
            obj_ = pitched.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pitched = obj_
            obj_.original_tagname_ = 'pitched'
        elif nodeName_ == 'membrane':
            obj_ = membrane.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.membrane = obj_
            obj_.original_tagname_ = 'membrane'
        elif nodeName_ == 'effect':
            obj_ = effect.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effect = obj_
            obj_.original_tagname_ = 'effect'
        elif nodeName_ == 'timpani':
            obj_ = timpani.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timpani = obj_
            obj_.original_tagname_ = 'timpani'
        elif nodeName_ == 'beater':
            obj_ = beater.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.beater = obj_
            obj_.original_tagname_ = 'beater'
        elif nodeName_ == 'stick':
            obj_ = stick.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stick = obj_
            obj_.original_tagname_ = 'stick'
        elif nodeName_ == 'stick-location':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'stick_location')
            value_ = self.gds_validate_string(value_, node, 'stick_location')
            self.stick_location = value_
            self.stick_location_nsprefix_ = child_.prefix
            # validate type stick-location
            self.validate_stick_location(self.stick_location)
        elif nodeName_ == 'other-percussion':
            obj_ = other_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_percussion = obj_
            obj_.original_tagname_ = 'other-percussion'
# end class percussion


class pitched(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pitched)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pitched.subclass:
            return pitched.subclass(*args_, **kwargs_)
        else:
            return pitched(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_pitched_value(self, value):
        result = True
        # Validate type pitched-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['celesta', 'chimes', 'glockenspiel', 'lithophone', 'mallet', 'marimba', 'steel drums', 'tubaphone', 'tubular chimes', 'vibraphone', 'xylophone']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on pitched-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_pictogram_glyph_name(self, value):
        # Validate type smufl-pictogram-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_pictogram_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_pictogram_glyph_name_patterns_, ))
    validate_smufl_pictogram_glyph_name_patterns_ = [['^(pict\\c+)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pitched', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pitched')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pitched':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pitched')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pitched', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pitched'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pitched', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_pictogram_glyph_name(self.smufl)    # validate type smufl-pictogram-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class pitched


class principal_voice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, symbol=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.symbol = _cast(None, symbol)
        self.symbol_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principal_voice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principal_voice.subclass:
            return principal_voice.subclass(*args_, **kwargs_)
        else:
            return principal_voice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_symbol(self):
        return self.symbol
    def set_symbol(self, symbol):
        self.symbol = symbol
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_principal_voice_symbol(self, value):
        # Validate type principal-voice-symbol, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Hauptstimme', 'Nebenstimme', 'plain', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on principal-voice-symbol' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='principal-voice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principal-voice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'principal-voice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principal-voice')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='principal-voice', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='principal-voice'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.add('symbol')
            outfile.write(' symbol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.symbol), input_name='symbol')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='principal-voice', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('symbol', node)
        if value is not None and 'symbol' not in already_processed:
            already_processed.add('symbol')
            self.symbol = value
            self.validate_principal_voice_symbol(self.symbol)    # validate type principal-voice-symbol
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class principal_voice


class print(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, staff_spacing=None, new_system=None, new_page=None, blank_page=None, page_number=None, id=None, page_layout=None, system_layout=None, staff_layout=None, measure_layout=None, measure_numbering=None, part_name_display=None, part_abbreviation_display=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.staff_spacing = _cast(float, staff_spacing)
        self.staff_spacing_nsprefix_ = None
        self.new_system = _cast(None, new_system)
        self.new_system_nsprefix_ = None
        self.new_page = _cast(None, new_page)
        self.new_page_nsprefix_ = None
        self.blank_page = _cast(int, blank_page)
        self.blank_page_nsprefix_ = None
        self.page_number = _cast(None, page_number)
        self.page_number_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.page_layout = page_layout
        self.page_layout_nsprefix_ = None
        self.system_layout = system_layout
        self.system_layout_nsprefix_ = None
        if staff_layout is None:
            self.staff_layout = []
        else:
            self.staff_layout = staff_layout
        self.staff_layout_nsprefix_ = None
        self.measure_layout = measure_layout
        self.measure_layout_nsprefix_ = None
        self.measure_numbering = measure_numbering
        self.measure_numbering_nsprefix_ = None
        self.part_name_display = part_name_display
        self.part_name_display_nsprefix_ = None
        self.part_abbreviation_display = part_abbreviation_display
        self.part_abbreviation_display_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, print)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if print.subclass:
            return print.subclass(*args_, **kwargs_)
        else:
            return print(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_page_layout(self):
        return self.page_layout
    def set_page_layout(self, page_layout):
        self.page_layout = page_layout
    def get_system_layout(self):
        return self.system_layout
    def set_system_layout(self, system_layout):
        self.system_layout = system_layout
    def get_staff_layout(self):
        return self.staff_layout
    def set_staff_layout(self, staff_layout):
        self.staff_layout = staff_layout
    def add_staff_layout(self, value):
        self.staff_layout.append(value)
    def insert_staff_layout_at(self, index, value):
        self.staff_layout.insert(index, value)
    def replace_staff_layout_at(self, index, value):
        self.staff_layout[index] = value
    def get_measure_layout(self):
        return self.measure_layout
    def set_measure_layout(self, measure_layout):
        self.measure_layout = measure_layout
    def get_measure_numbering(self):
        return self.measure_numbering
    def set_measure_numbering(self, measure_numbering):
        self.measure_numbering = measure_numbering
    def get_part_name_display(self):
        return self.part_name_display
    def set_part_name_display(self, part_name_display):
        self.part_name_display = part_name_display
    def get_part_abbreviation_display(self):
        return self.part_abbreviation_display
    def set_part_abbreviation_display(self, part_abbreviation_display):
        self.part_abbreviation_display = part_abbreviation_display
    def get_staff_spacing(self):
        return self.staff_spacing
    def set_staff_spacing(self, staff_spacing):
        self.staff_spacing = staff_spacing
    def get_new_system(self):
        return self.new_system
    def set_new_system(self, new_system):
        self.new_system = new_system
    def get_new_page(self):
        return self.new_page
    def set_new_page(self, new_page):
        self.new_page = new_page
    def get_blank_page(self):
        return self.blank_page
    def set_blank_page(self, blank_page):
        self.blank_page = blank_page
    def get_page_number(self):
        return self.page_number
    def set_page_number(self, page_number):
        self.page_number = page_number
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.page_layout is not None or
            self.system_layout is not None or
            self.staff_layout or
            self.measure_layout is not None or
            self.measure_numbering is not None or
            self.part_name_display is not None or
            self.part_abbreviation_display is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='print', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('print')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'print':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='print')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='print', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='print'):
        if self.staff_spacing is not None and 'staff_spacing' not in already_processed:
            already_processed.add('staff_spacing')
            outfile.write(' staff-spacing="%s"' % self.gds_format_decimal(self.staff_spacing, input_name='staff-spacing'))
        if self.new_system is not None and 'new_system' not in already_processed:
            already_processed.add('new_system')
            outfile.write(' new-system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.new_system), input_name='new-system')), ))
        if self.new_page is not None and 'new_page' not in already_processed:
            already_processed.add('new_page')
            outfile.write(' new-page=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.new_page), input_name='new-page')), ))
        if self.blank_page is not None and 'blank_page' not in already_processed:
            already_processed.add('blank_page')
            outfile.write(' blank-page="%s"' % self.gds_format_integer(self.blank_page, input_name='blank-page'))
        if self.page_number is not None and 'page_number' not in already_processed:
            already_processed.add('page_number')
            outfile.write(' page-number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.page_number), input_name='page-number')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='print', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.page_layout is not None:
            namespaceprefix_ = self.page_layout_nsprefix_ + ':' if (UseCapturedNS_ and self.page_layout_nsprefix_) else ''
            self.page_layout.export(outfile, level, namespaceprefix_, namespacedef_='', name_='page-layout', pretty_print=pretty_print)
        if self.system_layout is not None:
            namespaceprefix_ = self.system_layout_nsprefix_ + ':' if (UseCapturedNS_ and self.system_layout_nsprefix_) else ''
            self.system_layout.export(outfile, level, namespaceprefix_, namespacedef_='', name_='system-layout', pretty_print=pretty_print)
        for staff_layout_ in self.staff_layout:
            namespaceprefix_ = self.staff_layout_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_layout_nsprefix_) else ''
            staff_layout_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='staff-layout', pretty_print=pretty_print)
        if self.measure_layout is not None:
            namespaceprefix_ = self.measure_layout_nsprefix_ + ':' if (UseCapturedNS_ and self.measure_layout_nsprefix_) else ''
            self.measure_layout.export(outfile, level, namespaceprefix_, namespacedef_='', name_='measure-layout', pretty_print=pretty_print)
        if self.measure_numbering is not None:
            namespaceprefix_ = self.measure_numbering_nsprefix_ + ':' if (UseCapturedNS_ and self.measure_numbering_nsprefix_) else ''
            self.measure_numbering.export(outfile, level, namespaceprefix_, namespacedef_='', name_='measure-numbering', pretty_print=pretty_print)
        if self.part_name_display is not None:
            namespaceprefix_ = self.part_name_display_nsprefix_ + ':' if (UseCapturedNS_ and self.part_name_display_nsprefix_) else ''
            self.part_name_display.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-name-display', pretty_print=pretty_print)
        if self.part_abbreviation_display is not None:
            namespaceprefix_ = self.part_abbreviation_display_nsprefix_ + ':' if (UseCapturedNS_ and self.part_abbreviation_display_nsprefix_) else ''
            self.part_abbreviation_display.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-abbreviation-display', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('staff-spacing', node)
        if value is not None and 'staff-spacing' not in already_processed:
            already_processed.add('staff-spacing')
            value = self.gds_parse_decimal(value, node, 'staff-spacing')
            self.staff_spacing = value
        value = find_attr_value_('new-system', node)
        if value is not None and 'new-system' not in already_processed:
            already_processed.add('new-system')
            self.new_system = value
            self.new_system = ' '.join(self.new_system.split())
            self.validate_yes_no(self.new_system)    # validate type yes-no
        value = find_attr_value_('new-page', node)
        if value is not None and 'new-page' not in already_processed:
            already_processed.add('new-page')
            self.new_page = value
            self.new_page = ' '.join(self.new_page.split())
            self.validate_yes_no(self.new_page)    # validate type yes-no
        value = find_attr_value_('blank-page', node)
        if value is not None and 'blank-page' not in already_processed:
            already_processed.add('blank-page')
            self.blank_page = self.gds_parse_integer(value, node, 'blank-page')
            if self.blank_page <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('page-number', node)
        if value is not None and 'page-number' not in already_processed:
            already_processed.add('page-number')
            self.page_number = value
            self.page_number = ' '.join(self.page_number.split())
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'page-layout':
            obj_ = page_layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.page_layout = obj_
            obj_.original_tagname_ = 'page-layout'
        elif nodeName_ == 'system-layout':
            obj_ = system_layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.system_layout = obj_
            obj_.original_tagname_ = 'system-layout'
        elif nodeName_ == 'staff-layout':
            obj_ = staff_layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.staff_layout.append(obj_)
            obj_.original_tagname_ = 'staff-layout'
        elif nodeName_ == 'measure-layout':
            obj_ = measure_layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.measure_layout = obj_
            obj_.original_tagname_ = 'measure-layout'
        elif nodeName_ == 'measure-numbering':
            obj_ = measure_numbering.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.measure_numbering = obj_
            obj_.original_tagname_ = 'measure-numbering'
        elif nodeName_ == 'part-name-display':
            obj_ = name_display.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_name_display = obj_
            obj_.original_tagname_ = 'part-name-display'
        elif nodeName_ == 'part-abbreviation-display':
            obj_ = name_display.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_abbreviation_display = obj_
            obj_.original_tagname_ = 'part-abbreviation-display'
# end class print


class root(GeneratedsSuper):
    """root-alter -- The root-alter element represents the chromatic alteration of the root of the current chord within the harmony element. In some chord styles, the text for the root-step element may include root-alter information. In that case, the print-object attribute of the root-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the root-step; it is right by default.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, root_step=None, root_alter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.root_step = root_step
        self.root_step_nsprefix_ = None
        self.root_alter = root_alter
        self.root_alter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, root)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if root.subclass:
            return root.subclass(*args_, **kwargs_)
        else:
            return root(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root_step(self):
        return self.root_step
    def set_root_step(self, root_step):
        self.root_step = root_step
    def get_root_alter(self):
        return self.root_alter
    def set_root_alter(self, root_alter):
        self.root_alter = root_alter
    def _hasContent(self):
        if (
            self.root_step is not None or
            self.root_alter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='root', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('root')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'root':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='root')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='root', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='root'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='root', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.root_step is not None:
            namespaceprefix_ = self.root_step_nsprefix_ + ':' if (UseCapturedNS_ and self.root_step_nsprefix_) else ''
            self.root_step.export(outfile, level, namespaceprefix_, namespacedef_='', name_='root-step', pretty_print=pretty_print)
        if self.root_alter is not None:
            namespaceprefix_ = self.root_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.root_alter_nsprefix_) else ''
            self.root_alter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='root-alter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'root-step':
            obj_ = root_step.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.root_step = obj_
            obj_.original_tagname_ = 'root-step'
        elif nodeName_ == 'root-alter':
            obj_ = harmony_alter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.root_alter = obj_
            obj_.original_tagname_ = 'root-alter'
# end class root


class root_step(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, text=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, root_step)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if root_step.subclass:
            return root_step.subclass(*args_, **kwargs_)
        else:
            return root_step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='root-step', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('root-step')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'root-step':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='root-step')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='root-step', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='root-step'):
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='root-step', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class root_step


class scordatura(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, accord=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if accord is None:
            self.accord = []
        else:
            self.accord = accord
        self.accord_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scordatura)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scordatura.subclass:
            return scordatura.subclass(*args_, **kwargs_)
        else:
            return scordatura(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accord(self):
        return self.accord
    def set_accord(self, accord):
        self.accord = accord
    def add_accord(self, value):
        self.accord.append(value)
    def insert_accord_at(self, index, value):
        self.accord.insert(index, value)
    def replace_accord_at(self, index, value):
        self.accord[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.accord
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scordatura', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scordatura')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scordatura':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scordatura')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scordatura', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scordatura'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scordatura', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accord_ in self.accord:
            namespaceprefix_ = self.accord_nsprefix_ + ':' if (UseCapturedNS_ and self.accord_nsprefix_) else ''
            accord_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accord', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accord':
            obj_ = accord.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accord.append(obj_)
            obj_.original_tagname_ = 'accord'
# end class scordatura


class sound(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tempo=None, dynamics=None, dacapo=None, segno=None, dalsegno=None, coda=None, tocoda=None, divisions=None, forward_repeat=None, fine=None, time_only=None, pizzicato=None, pan=None, elevation=None, damper_pedal=None, soft_pedal=None, sostenuto_pedal=None, id=None, instrument_change=None, midi_device=None, midi_instrument=None, play=None, swing=None, offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tempo = _cast(float, tempo)
        self.tempo_nsprefix_ = None
        self.dynamics = _cast(float, dynamics)
        self.dynamics_nsprefix_ = None
        self.dacapo = _cast(None, dacapo)
        self.dacapo_nsprefix_ = None
        self.segno = _cast(None, segno)
        self.segno_nsprefix_ = None
        self.dalsegno = _cast(None, dalsegno)
        self.dalsegno_nsprefix_ = None
        self.coda = _cast(None, coda)
        self.coda_nsprefix_ = None
        self.tocoda = _cast(None, tocoda)
        self.tocoda_nsprefix_ = None
        self.divisions = _cast(float, divisions)
        self.divisions_nsprefix_ = None
        self.forward_repeat = _cast(None, forward_repeat)
        self.forward_repeat_nsprefix_ = None
        self.fine = _cast(None, fine)
        self.fine_nsprefix_ = None
        self.time_only = _cast(None, time_only)
        self.time_only_nsprefix_ = None
        self.pizzicato = _cast(None, pizzicato)
        self.pizzicato_nsprefix_ = None
        self.pan = _cast(float, pan)
        self.pan_nsprefix_ = None
        self.elevation = _cast(float, elevation)
        self.elevation_nsprefix_ = None
        self.damper_pedal = _cast(None, damper_pedal)
        self.damper_pedal_nsprefix_ = None
        self.soft_pedal = _cast(None, soft_pedal)
        self.soft_pedal_nsprefix_ = None
        self.sostenuto_pedal = _cast(None, sostenuto_pedal)
        self.sostenuto_pedal_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if instrument_change is None:
            self.instrument_change = []
        else:
            self.instrument_change = instrument_change
        self.instrument_change_nsprefix_ = None
        if midi_device is None:
            self.midi_device = []
        else:
            self.midi_device = midi_device
        self.midi_device_nsprefix_ = None
        if midi_instrument is None:
            self.midi_instrument = []
        else:
            self.midi_instrument = midi_instrument
        self.midi_instrument_nsprefix_ = None
        if play is None:
            self.play = []
        else:
            self.play = play
        self.play_nsprefix_ = None
        self.swing = swing
        self.swing_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sound)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sound.subclass:
            return sound.subclass(*args_, **kwargs_)
        else:
            return sound(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_instrument_change(self):
        return self.instrument_change
    def set_instrument_change(self, instrument_change):
        self.instrument_change = instrument_change
    def add_instrument_change(self, value):
        self.instrument_change.append(value)
    def insert_instrument_change_at(self, index, value):
        self.instrument_change.insert(index, value)
    def replace_instrument_change_at(self, index, value):
        self.instrument_change[index] = value
    def get_midi_device(self):
        return self.midi_device
    def set_midi_device(self, midi_device):
        self.midi_device = midi_device
    def add_midi_device(self, value):
        self.midi_device.append(value)
    def insert_midi_device_at(self, index, value):
        self.midi_device.insert(index, value)
    def replace_midi_device_at(self, index, value):
        self.midi_device[index] = value
    def get_midi_instrument(self):
        return self.midi_instrument
    def set_midi_instrument(self, midi_instrument):
        self.midi_instrument = midi_instrument
    def add_midi_instrument(self, value):
        self.midi_instrument.append(value)
    def insert_midi_instrument_at(self, index, value):
        self.midi_instrument.insert(index, value)
    def replace_midi_instrument_at(self, index, value):
        self.midi_instrument[index] = value
    def get_play(self):
        return self.play
    def set_play(self, play):
        self.play = play
    def add_play(self, value):
        self.play.append(value)
    def insert_play_at(self, index, value):
        self.play.insert(index, value)
    def replace_play_at(self, index, value):
        self.play[index] = value
    def get_swing(self):
        return self.swing
    def set_swing(self, swing):
        self.swing = swing
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_tempo(self):
        return self.tempo
    def set_tempo(self, tempo):
        self.tempo = tempo
    def get_dynamics(self):
        return self.dynamics
    def set_dynamics(self, dynamics):
        self.dynamics = dynamics
    def get_dacapo(self):
        return self.dacapo
    def set_dacapo(self, dacapo):
        self.dacapo = dacapo
    def get_segno(self):
        return self.segno
    def set_segno(self, segno):
        self.segno = segno
    def get_dalsegno(self):
        return self.dalsegno
    def set_dalsegno(self, dalsegno):
        self.dalsegno = dalsegno
    def get_coda(self):
        return self.coda
    def set_coda(self, coda):
        self.coda = coda
    def get_tocoda(self):
        return self.tocoda
    def set_tocoda(self, tocoda):
        self.tocoda = tocoda
    def get_divisions(self):
        return self.divisions
    def set_divisions(self, divisions):
        self.divisions = divisions
    def get_forward_repeat(self):
        return self.forward_repeat
    def set_forward_repeat(self, forward_repeat):
        self.forward_repeat = forward_repeat
    def get_fine(self):
        return self.fine
    def set_fine(self, fine):
        self.fine = fine
    def get_time_only(self):
        return self.time_only
    def set_time_only(self, time_only):
        self.time_only = time_only
    def get_pizzicato(self):
        return self.pizzicato
    def set_pizzicato(self, pizzicato):
        self.pizzicato = pizzicato
    def get_pan(self):
        return self.pan
    def set_pan(self, pan):
        self.pan = pan
    def get_elevation(self):
        return self.elevation
    def set_elevation(self, elevation):
        self.elevation = elevation
    def get_damper_pedal(self):
        return self.damper_pedal
    def set_damper_pedal(self, damper_pedal):
        self.damper_pedal = damper_pedal
    def get_soft_pedal(self):
        return self.soft_pedal
    def set_soft_pedal(self, soft_pedal):
        self.soft_pedal = soft_pedal
    def get_sostenuto_pedal(self):
        return self.sostenuto_pedal
    def set_sostenuto_pedal(self, sostenuto_pedal):
        self.sostenuto_pedal = sostenuto_pedal
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_non_negative_decimal(self, value):
        # Validate type non-negative-decimal, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on non-negative-decimal' % {"value": value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_time_only(self, value):
        # Validate type time-only, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_time_only_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_time_only_patterns_, ))
    validate_time_only_patterns_ = [['^([1-9][0-9]*(, ?[1-9][0-9]*)*)$']]
    def validate_rotation_degrees(self, value):
        # Validate type rotation-degrees, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
    def validate_yes_no_number(self, value):
        # Validate type yes-no-number, a restriction on None.
        pass
    def _hasContent(self):
        if (
            self.instrument_change or
            self.midi_device or
            self.midi_instrument or
            self.play or
            self.swing is not None or
            self.offset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sound', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sound')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sound':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sound')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sound', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sound'):
        if self.tempo is not None and 'tempo' not in already_processed:
            already_processed.add('tempo')
            outfile.write(' tempo="%s"' % self.gds_format_decimal(self.tempo, input_name='tempo'))
        if self.dynamics is not None and 'dynamics' not in already_processed:
            already_processed.add('dynamics')
            outfile.write(' dynamics="%s"' % self.gds_format_decimal(self.dynamics, input_name='dynamics'))
        if self.dacapo is not None and 'dacapo' not in already_processed:
            already_processed.add('dacapo')
            outfile.write(' dacapo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dacapo), input_name='dacapo')), ))
        if self.segno is not None and 'segno' not in already_processed:
            already_processed.add('segno')
            outfile.write(' segno=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segno), input_name='segno')), ))
        if self.dalsegno is not None and 'dalsegno' not in already_processed:
            already_processed.add('dalsegno')
            outfile.write(' dalsegno=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dalsegno), input_name='dalsegno')), ))
        if self.coda is not None and 'coda' not in already_processed:
            already_processed.add('coda')
            outfile.write(' coda=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coda), input_name='coda')), ))
        if self.tocoda is not None and 'tocoda' not in already_processed:
            already_processed.add('tocoda')
            outfile.write(' tocoda=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tocoda), input_name='tocoda')), ))
        if self.divisions is not None and 'divisions' not in already_processed:
            already_processed.add('divisions')
            outfile.write(' divisions="%s"' % self.gds_format_decimal(self.divisions, input_name='divisions'))
        if self.forward_repeat is not None and 'forward_repeat' not in already_processed:
            already_processed.add('forward_repeat')
            outfile.write(' forward-repeat=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.forward_repeat), input_name='forward-repeat')), ))
        if self.fine is not None and 'fine' not in already_processed:
            already_processed.add('fine')
            outfile.write(' fine=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fine), input_name='fine')), ))
        if self.time_only is not None and 'time_only' not in already_processed:
            already_processed.add('time_only')
            outfile.write(' time-only=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time_only), input_name='time-only')), ))
        if self.pizzicato is not None and 'pizzicato' not in already_processed:
            already_processed.add('pizzicato')
            outfile.write(' pizzicato=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pizzicato), input_name='pizzicato')), ))
        if self.pan is not None and 'pan' not in already_processed:
            already_processed.add('pan')
            outfile.write(' pan="%s"' % self.gds_format_decimal(self.pan, input_name='pan'))
        if self.elevation is not None and 'elevation' not in already_processed:
            already_processed.add('elevation')
            outfile.write(' elevation="%s"' % self.gds_format_decimal(self.elevation, input_name='elevation'))
        if self.damper_pedal is not None and 'damper_pedal' not in already_processed:
            already_processed.add('damper_pedal')
            outfile.write(' damper-pedal=%s' % (quote_attrib(self.damper_pedal), ))
        if self.soft_pedal is not None and 'soft_pedal' not in already_processed:
            already_processed.add('soft_pedal')
            outfile.write(' soft-pedal=%s' % (quote_attrib(self.soft_pedal), ))
        if self.sostenuto_pedal is not None and 'sostenuto_pedal' not in already_processed:
            already_processed.add('sostenuto_pedal')
            outfile.write(' sostenuto-pedal=%s' % (quote_attrib(self.sostenuto_pedal), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sound', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrument_change_ in self.instrument_change:
            namespaceprefix_ = self.instrument_change_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_change_nsprefix_) else ''
            instrument_change_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instrument-change', pretty_print=pretty_print)
        for midi_device_ in self.midi_device:
            namespaceprefix_ = self.midi_device_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_device_nsprefix_) else ''
            midi_device_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='midi-device', pretty_print=pretty_print)
        for midi_instrument_ in self.midi_instrument:
            namespaceprefix_ = self.midi_instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_instrument_nsprefix_) else ''
            midi_instrument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='midi-instrument', pretty_print=pretty_print)
        for play_ in self.play:
            namespaceprefix_ = self.play_nsprefix_ + ':' if (UseCapturedNS_ and self.play_nsprefix_) else ''
            play_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='play', pretty_print=pretty_print)
        if self.swing is not None:
            namespaceprefix_ = self.swing_nsprefix_ + ':' if (UseCapturedNS_ and self.swing_nsprefix_) else ''
            self.swing.export(outfile, level, namespaceprefix_, namespacedef_='', name_='swing', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tempo', node)
        if value is not None and 'tempo' not in already_processed:
            already_processed.add('tempo')
            value = self.gds_parse_decimal(value, node, 'tempo')
            self.tempo = value
            self.validate_non_negative_decimal(self.tempo)    # validate type non-negative-decimal
        value = find_attr_value_('dynamics', node)
        if value is not None and 'dynamics' not in already_processed:
            already_processed.add('dynamics')
            value = self.gds_parse_decimal(value, node, 'dynamics')
            self.dynamics = value
            self.validate_non_negative_decimal(self.dynamics)    # validate type non-negative-decimal
        value = find_attr_value_('dacapo', node)
        if value is not None and 'dacapo' not in already_processed:
            already_processed.add('dacapo')
            self.dacapo = value
            self.dacapo = ' '.join(self.dacapo.split())
            self.validate_yes_no(self.dacapo)    # validate type yes-no
        value = find_attr_value_('segno', node)
        if value is not None and 'segno' not in already_processed:
            already_processed.add('segno')
            self.segno = value
            self.segno = ' '.join(self.segno.split())
        value = find_attr_value_('dalsegno', node)
        if value is not None and 'dalsegno' not in already_processed:
            already_processed.add('dalsegno')
            self.dalsegno = value
            self.dalsegno = ' '.join(self.dalsegno.split())
        value = find_attr_value_('coda', node)
        if value is not None and 'coda' not in already_processed:
            already_processed.add('coda')
            self.coda = value
            self.coda = ' '.join(self.coda.split())
        value = find_attr_value_('tocoda', node)
        if value is not None and 'tocoda' not in already_processed:
            already_processed.add('tocoda')
            self.tocoda = value
            self.tocoda = ' '.join(self.tocoda.split())
        value = find_attr_value_('divisions', node)
        if value is not None and 'divisions' not in already_processed:
            already_processed.add('divisions')
            value = self.gds_parse_decimal(value, node, 'divisions')
            self.divisions = value
        value = find_attr_value_('forward-repeat', node)
        if value is not None and 'forward-repeat' not in already_processed:
            already_processed.add('forward-repeat')
            self.forward_repeat = value
            self.forward_repeat = ' '.join(self.forward_repeat.split())
            self.validate_yes_no(self.forward_repeat)    # validate type yes-no
        value = find_attr_value_('fine', node)
        if value is not None and 'fine' not in already_processed:
            already_processed.add('fine')
            self.fine = value
            self.fine = ' '.join(self.fine.split())
        value = find_attr_value_('time-only', node)
        if value is not None and 'time-only' not in already_processed:
            already_processed.add('time-only')
            self.time_only = value
            self.time_only = ' '.join(self.time_only.split())
            self.validate_time_only(self.time_only)    # validate type time-only
        value = find_attr_value_('pizzicato', node)
        if value is not None and 'pizzicato' not in already_processed:
            already_processed.add('pizzicato')
            self.pizzicato = value
            self.pizzicato = ' '.join(self.pizzicato.split())
            self.validate_yes_no(self.pizzicato)    # validate type yes-no
        value = find_attr_value_('pan', node)
        if value is not None and 'pan' not in already_processed:
            already_processed.add('pan')
            value = self.gds_parse_decimal(value, node, 'pan')
            self.pan = value
            self.validate_rotation_degrees(self.pan)    # validate type rotation-degrees
        value = find_attr_value_('elevation', node)
        if value is not None and 'elevation' not in already_processed:
            already_processed.add('elevation')
            value = self.gds_parse_decimal(value, node, 'elevation')
            self.elevation = value
            self.validate_rotation_degrees(self.elevation)    # validate type rotation-degrees
        value = find_attr_value_('damper-pedal', node)
        if value is not None and 'damper-pedal' not in already_processed:
            already_processed.add('damper-pedal')
            self.damper_pedal = value
            self.validate_yes_no_number(self.damper_pedal)    # validate type yes-no-number
        value = find_attr_value_('soft-pedal', node)
        if value is not None and 'soft-pedal' not in already_processed:
            already_processed.add('soft-pedal')
            self.soft_pedal = value
            self.validate_yes_no_number(self.soft_pedal)    # validate type yes-no-number
        value = find_attr_value_('sostenuto-pedal', node)
        if value is not None and 'sostenuto-pedal' not in already_processed:
            already_processed.add('sostenuto-pedal')
            self.sostenuto_pedal = value
            self.validate_yes_no_number(self.sostenuto_pedal)    # validate type yes-no-number
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'instrument-change':
            obj_ = instrument_change.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument_change.append(obj_)
            obj_.original_tagname_ = 'instrument-change'
        elif nodeName_ == 'midi-device':
            obj_ = midi_device.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.midi_device.append(obj_)
            obj_.original_tagname_ = 'midi-device'
        elif nodeName_ == 'midi-instrument':
            obj_ = midi_instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.midi_instrument.append(obj_)
            obj_.original_tagname_ = 'midi-instrument'
        elif nodeName_ == 'play':
            obj_ = play.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.play.append(obj_)
            obj_.original_tagname_ = 'play'
        elif nodeName_ == 'swing':
            obj_ = swing.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.swing = obj_
            obj_.original_tagname_ = 'swing'
        elif nodeName_ == 'offset':
            obj_ = offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
# end class sound


class staff_divide(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, staff_divide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if staff_divide.subclass:
            return staff_divide.subclass(*args_, **kwargs_)
        else:
            return staff_divide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_staff_divide_symbol(self, value):
        # Validate type staff-divide-symbol, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['down', 'up', 'up-down']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on staff-divide-symbol' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-divide', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('staff-divide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'staff-divide':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='staff-divide')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='staff-divide', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='staff-divide'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-divide', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_staff_divide_symbol(self.type_)    # validate type staff-divide-symbol
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class staff_divide


class stick(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tip=None, parentheses=None, dashed_circle=None, stick_type=None, stick_material=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tip = _cast(None, tip)
        self.tip_nsprefix_ = None
        self.parentheses = _cast(None, parentheses)
        self.parentheses_nsprefix_ = None
        self.dashed_circle = _cast(None, dashed_circle)
        self.dashed_circle_nsprefix_ = None
        self.stick_type = stick_type
        self.validate_stick_type(self.stick_type)
        self.stick_type_nsprefix_ = None
        self.stick_material = stick_material
        self.validate_stick_material(self.stick_material)
        self.stick_material_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stick)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stick.subclass:
            return stick.subclass(*args_, **kwargs_)
        else:
            return stick(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_stick_type(self):
        return self.stick_type
    def set_stick_type(self, stick_type):
        self.stick_type = stick_type
    def get_stick_material(self):
        return self.stick_material
    def set_stick_material(self, stick_material):
        self.stick_material = stick_material
    def get_tip(self):
        return self.tip
    def set_tip(self, tip):
        self.tip = tip
    def get_parentheses(self):
        return self.parentheses
    def set_parentheses(self, parentheses):
        self.parentheses = parentheses
    def get_dashed_circle(self):
        return self.dashed_circle
    def set_dashed_circle(self, dashed_circle):
        self.dashed_circle = dashed_circle
    def validate_stick_type(self, value):
        result = True
        # Validate type stick-type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['bass drum', 'double bass drum', 'glockenspiel', 'gum', 'hammer', 'superball', 'timpani', 'wound', 'xylophone', 'yarn']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on stick-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_stick_material(self, value):
        result = True
        # Validate type stick-material, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['soft', 'medium', 'hard', 'shaded', 'x']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on stick-material' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tip_direction(self, value):
        # Validate type tip-direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['up', 'down', 'left', 'right', 'northwest', 'northeast', 'southeast', 'southwest']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tip-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.stick_type is not None or
            self.stick_material is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stick', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stick')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'stick':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stick')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='stick', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='stick'):
        if self.tip is not None and 'tip' not in already_processed:
            already_processed.add('tip')
            outfile.write(' tip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tip), input_name='tip')), ))
        if self.parentheses is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            outfile.write(' parentheses=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentheses), input_name='parentheses')), ))
        if self.dashed_circle is not None and 'dashed_circle' not in already_processed:
            already_processed.add('dashed_circle')
            outfile.write(' dashed-circle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dashed_circle), input_name='dashed-circle')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stick', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stick_type is not None:
            namespaceprefix_ = self.stick_type_nsprefix_ + ':' if (UseCapturedNS_ and self.stick_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstick-type>%s</%sstick-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.stick_type), input_name='stick-type')), namespaceprefix_ , eol_))
        if self.stick_material is not None:
            namespaceprefix_ = self.stick_material_nsprefix_ + ':' if (UseCapturedNS_ and self.stick_material_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstick-material>%s</%sstick-material>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.stick_material), input_name='stick-material')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tip', node)
        if value is not None and 'tip' not in already_processed:
            already_processed.add('tip')
            self.tip = value
            self.validate_tip_direction(self.tip)    # validate type tip-direction
        value = find_attr_value_('parentheses', node)
        if value is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            self.parentheses = value
            self.parentheses = ' '.join(self.parentheses.split())
            self.validate_yes_no(self.parentheses)    # validate type yes-no
        value = find_attr_value_('dashed-circle', node)
        if value is not None and 'dashed-circle' not in already_processed:
            already_processed.add('dashed-circle')
            self.dashed_circle = value
            self.dashed_circle = ' '.join(self.dashed_circle.split())
            self.validate_yes_no(self.dashed_circle)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'stick-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'stick_type')
            value_ = self.gds_validate_string(value_, node, 'stick_type')
            self.stick_type = value_
            self.stick_type_nsprefix_ = child_.prefix
            # validate type stick-type
            self.validate_stick_type(self.stick_type)
        elif nodeName_ == 'stick-material':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'stick_material')
            value_ = self.gds_validate_string(value_, node, 'stick_material')
            self.stick_material = value_
            self.stick_material_nsprefix_ = child_.prefix
            # validate type stick-material
            self.validate_stick_material(self.stick_material)
# end class stick


class string_mute(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, string_mute)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if string_mute.subclass:
            return string_mute.subclass(*args_, **kwargs_)
        else:
            return string_mute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_on_off(self, value):
        # Validate type on-off, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['on', 'off']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on on-off' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='string-mute', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('string-mute')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'string-mute':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='string-mute')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='string-mute', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='string-mute'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='string-mute', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_on_off(self.type_)    # validate type on-off
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class string_mute


class swing(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, straight=None, first=None, second=None, swing_type=None, swing_style=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.straight = straight
        self.straight_nsprefix_ = None
        self.first = first
        self.first_nsprefix_ = None
        self.second = second
        self.second_nsprefix_ = None
        self.swing_type = swing_type
        self.validate_swing_type_value(self.swing_type)
        self.swing_type_nsprefix_ = None
        self.swing_style = swing_style
        self.swing_style_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, swing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if swing.subclass:
            return swing.subclass(*args_, **kwargs_)
        else:
            return swing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_straight(self):
        return self.straight
    def set_straight(self, straight):
        self.straight = straight
    def get_first(self):
        return self.first
    def set_first(self, first):
        self.first = first
    def get_second(self):
        return self.second
    def set_second(self, second):
        self.second = second
    def get_swing_type(self):
        return self.swing_type
    def set_swing_type(self, swing_type):
        self.swing_type = swing_type
    def get_swing_style(self):
        return self.swing_style
    def set_swing_style(self, swing_style):
        self.swing_style = swing_style
    def validate_swing_type_value(self, value):
        result = True
        # Validate type swing-type-value, a restriction on note-type-value.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['16th', 'eighth']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on swing-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on swing-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.straight is not None or
            self.first is not None or
            self.second is not None or
            self.swing_type is not None or
            self.swing_style is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='swing', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('swing')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'swing':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='swing')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='swing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='swing'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='swing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.straight is not None:
            namespaceprefix_ = self.straight_nsprefix_ + ':' if (UseCapturedNS_ and self.straight_nsprefix_) else ''
            self.straight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='straight', pretty_print=pretty_print)
        if self.first is not None:
            namespaceprefix_ = self.first_nsprefix_ + ':' if (UseCapturedNS_ and self.first_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirst>%s</%sfirst>%s' % (namespaceprefix_ , self.gds_format_integer(self.first, input_name='first'), namespaceprefix_ , eol_))
        if self.second is not None:
            namespaceprefix_ = self.second_nsprefix_ + ':' if (UseCapturedNS_ and self.second_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecond>%s</%ssecond>%s' % (namespaceprefix_ , self.gds_format_integer(self.second, input_name='second'), namespaceprefix_ , eol_))
        if self.swing_type is not None:
            namespaceprefix_ = self.swing_type_nsprefix_ + ':' if (UseCapturedNS_ and self.swing_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sswing-type>%s</%sswing-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.swing_type), input_name='swing-type')), namespaceprefix_ , eol_))
        if self.swing_style is not None:
            namespaceprefix_ = self.swing_style_nsprefix_ + ':' if (UseCapturedNS_ and self.swing_style_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sswing-style>%s</%sswing-style>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.swing_style), input_name='swing-style')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'straight':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.straight = obj_
            obj_.original_tagname_ = 'straight'
        elif nodeName_ == 'first' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'first')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'first')
            self.first = ival_
            self.first_nsprefix_ = child_.prefix
        elif nodeName_ == 'second' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'second')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'second')
            self.second = ival_
            self.second_nsprefix_ = child_.prefix
        elif nodeName_ == 'swing-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'swing_type')
            value_ = self.gds_validate_string(value_, node, 'swing_type')
            self.swing_type = value_
            self.swing_type_nsprefix_ = child_.prefix
            # validate type swing-type-value
            self.validate_swing_type_value(self.swing_type)
        elif nodeName_ == 'swing-style':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'swing_style')
            value_ = self.gds_validate_string(value_, node, 'swing_style')
            self.swing_style = value_
            self.swing_style_nsprefix_ = child_.prefix
# end class swing


class sync(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, latency=None, player=None, time_only=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.latency = _cast(int, latency)
        self.latency_nsprefix_ = None
        self.player = _cast(None, player)
        self.player_nsprefix_ = None
        self.time_only = _cast(None, time_only)
        self.time_only_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sync)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sync.subclass:
            return sync.subclass(*args_, **kwargs_)
        else:
            return sync(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_latency(self):
        return self.latency
    def set_latency(self, latency):
        self.latency = latency
    def get_player(self):
        return self.player
    def set_player(self, player):
        self.player = player
    def get_time_only(self):
        return self.time_only
    def set_time_only(self, time_only):
        self.time_only = time_only
    def validate_sync_type(self, value):
        # Validate type sync-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'tempo', 'mostly-tempo', 'mostly-event', 'event', 'always-event']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on sync-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_milliseconds(self, value):
        # Validate type milliseconds, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_time_only(self, value):
        # Validate type time-only, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_time_only_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_time_only_patterns_, ))
    validate_time_only_patterns_ = [['^([1-9][0-9]*(, ?[1-9][0-9]*)*)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sync', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sync')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sync':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sync')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sync', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sync'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.latency is not None and 'latency' not in already_processed:
            already_processed.add('latency')
            outfile.write(' latency="%s"' % self.gds_format_integer(self.latency, input_name='latency'))
        if self.player is not None and 'player' not in already_processed:
            already_processed.add('player')
            outfile.write(' player=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.player), input_name='player')), ))
        if self.time_only is not None and 'time_only' not in already_processed:
            already_processed.add('time_only')
            outfile.write(' time-only=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time_only), input_name='time-only')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sync', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_sync_type(self.type_)    # validate type sync-type
        value = find_attr_value_('latency', node)
        if value is not None and 'latency' not in already_processed:
            already_processed.add('latency')
            self.latency = self.gds_parse_integer(value, node, 'latency')
            if self.latency < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_milliseconds(self.latency)    # validate type milliseconds
        value = find_attr_value_('player', node)
        if value is not None and 'player' not in already_processed:
            already_processed.add('player')
            self.player = value
        value = find_attr_value_('time-only', node)
        if value is not None and 'time-only' not in already_processed:
            already_processed.add('time-only')
            self.time_only = value
            self.time_only = ' '.join(self.time_only.split())
            self.validate_time_only(self.time_only)    # validate type time-only
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class sync


class timpani(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timpani)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timpani.subclass:
            return timpani.subclass(*args_, **kwargs_)
        else:
            return timpani(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def validate_smufl_pictogram_glyph_name(self, value):
        # Validate type smufl-pictogram-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_pictogram_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_pictogram_glyph_name_patterns_, ))
    validate_smufl_pictogram_glyph_name_patterns_ = [['^(pict\\c+)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='timpani', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('timpani')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'timpani':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='timpani')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='timpani', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='timpani'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='timpani', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_pictogram_glyph_name(self.smufl)    # validate type smufl-pictogram-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class timpani


class wedge(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, spread=None, niente=None, line_type=None, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, color=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.spread = _cast(float, spread)
        self.spread_nsprefix_ = None
        self.niente = _cast(None, niente)
        self.niente_nsprefix_ = None
        self.line_type = _cast(None, line_type)
        self.line_type_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wedge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wedge.subclass:
            return wedge.subclass(*args_, **kwargs_)
        else:
            return wedge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_spread(self):
        return self.spread
    def set_spread(self, spread):
        self.spread = spread
    def get_niente(self):
        return self.niente
    def set_niente(self, niente):
        self.niente = niente
    def get_line_type(self):
        return self.line_type
    def set_line_type(self, line_type):
        self.line_type = line_type
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_wedge_type(self, value):
        # Validate type wedge-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['crescendo', 'diminuendo', 'stop', 'continue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on wedge-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_line_type(self, value):
        # Validate type line-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['solid', 'dashed', 'dotted', 'wavy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='wedge', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wedge')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'wedge':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='wedge')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='wedge', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='wedge'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.spread is not None and 'spread' not in already_processed:
            already_processed.add('spread')
            outfile.write(' spread="%s"' % self.gds_format_decimal(self.spread, input_name='spread'))
        if self.niente is not None and 'niente' not in already_processed:
            already_processed.add('niente')
            outfile.write(' niente=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.niente), input_name='niente')), ))
        if self.line_type is not None and 'line_type' not in already_processed:
            already_processed.add('line_type')
            outfile.write(' line-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_type), input_name='line-type')), ))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='wedge', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_wedge_type(self.type_)    # validate type wedge-type
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('spread', node)
        if value is not None and 'spread' not in already_processed:
            already_processed.add('spread')
            value = self.gds_parse_decimal(value, node, 'spread')
            self.spread = value
        value = find_attr_value_('niente', node)
        if value is not None and 'niente' not in already_processed:
            already_processed.add('niente')
            self.niente = value
            self.niente = ' '.join(self.niente.split())
            self.validate_yes_no(self.niente)    # validate type yes-no
        value = find_attr_value_('line-type', node)
        if value is not None and 'line-type' not in already_processed:
            already_processed.add('line-type')
            self.line_type = value
            self.line_type = ' '.join(self.line_type.split())
            self.validate_line_type(self.line_type)    # validate type line-type
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class wedge


class wood(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wood)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wood.subclass:
            return wood.subclass(*args_, **kwargs_)
        else:
            return wood(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_wood_value(self, value):
        result = True
        # Validate type wood-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['bamboo scraper', 'board clapper', 'cabasa', 'castanets', 'castanets with handle', 'claves', 'football rattle', 'guiro', 'log drum', 'maraca', 'maracas', 'quijada', 'rainstick', 'ratchet', 'reco-reco', 'sandpaper blocks', 'slit drum', 'temple block', 'vibraslap', 'whip', 'wood block']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on wood-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_pictogram_glyph_name(self, value):
        # Validate type smufl-pictogram-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_pictogram_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_pictogram_glyph_name_patterns_, ))
    validate_smufl_pictogram_glyph_name_patterns_ = [['^(pict\\c+)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='wood', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wood')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'wood':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='wood')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='wood', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='wood'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='wood', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_pictogram_glyph_name(self.smufl)    # validate type smufl-pictogram-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class wood


class encoding(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, encoding_date=None, encoder=None, software=None, encoding_description=None, supports=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if encoding_date is None:
            self.encoding_date = []
        else:
            self.encoding_date = encoding_date
        self.encoding_date_nsprefix_ = None
        if encoder is None:
            self.encoder = []
        else:
            self.encoder = encoder
        self.encoder_nsprefix_ = None
        if software is None:
            self.software = []
        else:
            self.software = software
        self.software_nsprefix_ = None
        if encoding_description is None:
            self.encoding_description = []
        else:
            self.encoding_description = encoding_description
        self.encoding_description_nsprefix_ = None
        if supports is None:
            self.supports = []
        else:
            self.supports = supports
        self.supports_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, encoding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if encoding.subclass:
            return encoding.subclass(*args_, **kwargs_)
        else:
            return encoding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_encoding_date(self):
        return self.encoding_date
    def set_encoding_date(self, encoding_date):
        self.encoding_date = encoding_date
    def add_encoding_date(self, value):
        self.encoding_date.append(value)
    def insert_encoding_date_at(self, index, value):
        self.encoding_date.insert(index, value)
    def replace_encoding_date_at(self, index, value):
        self.encoding_date[index] = value
    def get_encoder(self):
        return self.encoder
    def set_encoder(self, encoder):
        self.encoder = encoder
    def add_encoder(self, value):
        self.encoder.append(value)
    def insert_encoder_at(self, index, value):
        self.encoder.insert(index, value)
    def replace_encoder_at(self, index, value):
        self.encoder[index] = value
    def get_software(self):
        return self.software
    def set_software(self, software):
        self.software = software
    def add_software(self, value):
        self.software.append(value)
    def insert_software_at(self, index, value):
        self.software.insert(index, value)
    def replace_software_at(self, index, value):
        self.software[index] = value
    def get_encoding_description(self):
        return self.encoding_description
    def set_encoding_description(self, encoding_description):
        self.encoding_description = encoding_description
    def add_encoding_description(self, value):
        self.encoding_description.append(value)
    def insert_encoding_description_at(self, index, value):
        self.encoding_description.insert(index, value)
    def replace_encoding_description_at(self, index, value):
        self.encoding_description[index] = value
    def get_supports(self):
        return self.supports
    def set_supports(self, supports):
        self.supports = supports
    def add_supports(self, value):
        self.supports.append(value)
    def insert_supports_at(self, index, value):
        self.supports.insert(index, value)
    def replace_supports_at(self, index, value):
        self.supports[index] = value
    def validate_yyyy_mm_dd(self, value):
        result = True
        # Validate type yyyy-mm-dd, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            value = str(value)
            if not self.gds_validate_simple_patterns(
                    self.validate_yyyy_mm_dd_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_yyyy_mm_dd_patterns_, ))
                result = False
        return result
    validate_yyyy_mm_dd_patterns_ = [['^([^:Z]*)$']]
    def _hasContent(self):
        if (
            self.encoding_date or
            self.encoder or
            self.software or
            self.encoding_description or
            self.supports
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='encoding', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('encoding')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'encoding':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='encoding')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='encoding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='encoding'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='encoding', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for encoding_date_ in self.encoding_date:
            namespaceprefix_ = self.encoding_date_nsprefix_ + ':' if (UseCapturedNS_ and self.encoding_date_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencoding-date>%s</%sencoding-date>%s' % (namespaceprefix_ , self.gds_format_date(encoding_date_, input_name='encoding-date'), namespaceprefix_ , eol_))
        for encoder_ in self.encoder:
            namespaceprefix_ = self.encoder_nsprefix_ + ':' if (UseCapturedNS_ and self.encoder_nsprefix_) else ''
            encoder_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encoder', pretty_print=pretty_print)
        for software_ in self.software:
            namespaceprefix_ = self.software_nsprefix_ + ':' if (UseCapturedNS_ and self.software_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftware>%s</%ssoftware>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(software_), input_name='software')), namespaceprefix_ , eol_))
        for encoding_description_ in self.encoding_description:
            namespaceprefix_ = self.encoding_description_nsprefix_ + ':' if (UseCapturedNS_ and self.encoding_description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencoding-description>%s</%sencoding-description>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(encoding_description_), input_name='encoding-description')), namespaceprefix_ , eol_))
        for supports_ in self.supports:
            namespaceprefix_ = self.supports_nsprefix_ + ':' if (UseCapturedNS_ and self.supports_nsprefix_) else ''
            supports_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supports', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'encoding-date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.encoding_date.append(dval_)
            self.encoding_date_nsprefix_ = child_.prefix
            # validate type yyyy-mm-dd
            self.validate_yyyy_mm_dd(self.encoding_date[-1])
        elif nodeName_ == 'encoder':
            obj_ = typed_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encoder.append(obj_)
            obj_.original_tagname_ = 'encoder'
        elif nodeName_ == 'software':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'software')
            value_ = self.gds_validate_string(value_, node, 'software')
            self.software.append(value_)
            self.software_nsprefix_ = child_.prefix
        elif nodeName_ == 'encoding-description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'encoding_description')
            value_ = self.gds_validate_string(value_, node, 'encoding_description')
            self.encoding_description.append(value_)
            self.encoding_description_nsprefix_ = child_.prefix
        elif nodeName_ == 'supports':
            obj_ = supports.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supports.append(obj_)
            obj_.original_tagname_ = 'supports'
# end class encoding


class identification(GeneratedsSuper):
    """creator -- The creator element is borrowed from Dublin Core. It is used for the creators of the score. The type attribute is used to distinguish different creative contributions. Thus, there can be multiple creators within an identification. Standard type values are composer, lyricist, and arranger. Other type values may be used for different types of creative roles. The type attribute should usually be used even if there is just a single creator element. The MusicXML format does not use the creator / contributor distinction from Dublin Core.
    rights -- The rights element is borrowed from Dublin Core. It contains copyright and other intellectual property notices. Words, music, and derivatives can have different types, so multiple rights elements with different type attributes are supported. Standard type values are music, words, and arrangement, but other types may be used. The type attribute is only needed when there are multiple rights elements.
    source -- The source for the music that is encoded. This is similar to the Dublin Core source element.
    relation -- A related resource for the music that is encoded. This is similar to the Dublin Core relation element. Standard type values are music, words, and arrangement, but other types may be used.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, creator=None, rights=None, encoding=None, source=None, relation=None, miscellaneous=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if creator is None:
            self.creator = []
        else:
            self.creator = creator
        self.creator_nsprefix_ = None
        if rights is None:
            self.rights = []
        else:
            self.rights = rights
        self.rights_nsprefix_ = None
        self.encoding = encoding
        self.encoding_nsprefix_ = None
        self.source = source
        self.source_nsprefix_ = None
        if relation is None:
            self.relation = []
        else:
            self.relation = relation
        self.relation_nsprefix_ = None
        self.miscellaneous = miscellaneous
        self.miscellaneous_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, identification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if identification.subclass:
            return identification.subclass(*args_, **kwargs_)
        else:
            return identification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_creator(self):
        return self.creator
    def set_creator(self, creator):
        self.creator = creator
    def add_creator(self, value):
        self.creator.append(value)
    def insert_creator_at(self, index, value):
        self.creator.insert(index, value)
    def replace_creator_at(self, index, value):
        self.creator[index] = value
    def get_rights(self):
        return self.rights
    def set_rights(self, rights):
        self.rights = rights
    def add_rights(self, value):
        self.rights.append(value)
    def insert_rights_at(self, index, value):
        self.rights.insert(index, value)
    def replace_rights_at(self, index, value):
        self.rights[index] = value
    def get_encoding(self):
        return self.encoding
    def set_encoding(self, encoding):
        self.encoding = encoding
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_relation(self):
        return self.relation
    def set_relation(self, relation):
        self.relation = relation
    def add_relation(self, value):
        self.relation.append(value)
    def insert_relation_at(self, index, value):
        self.relation.insert(index, value)
    def replace_relation_at(self, index, value):
        self.relation[index] = value
    def get_miscellaneous(self):
        return self.miscellaneous
    def set_miscellaneous(self, miscellaneous):
        self.miscellaneous = miscellaneous
    def _hasContent(self):
        if (
            self.creator or
            self.rights or
            self.encoding is not None or
            self.source is not None or
            self.relation or
            self.miscellaneous is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='identification', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('identification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'identification':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='identification')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='identification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='identification'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='identification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for creator_ in self.creator:
            namespaceprefix_ = self.creator_nsprefix_ + ':' if (UseCapturedNS_ and self.creator_nsprefix_) else ''
            creator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creator', pretty_print=pretty_print)
        for rights_ in self.rights:
            namespaceprefix_ = self.rights_nsprefix_ + ':' if (UseCapturedNS_ and self.rights_nsprefix_) else ''
            rights_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rights', pretty_print=pretty_print)
        if self.encoding is not None:
            namespaceprefix_ = self.encoding_nsprefix_ + ':' if (UseCapturedNS_ and self.encoding_nsprefix_) else ''
            self.encoding.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encoding', pretty_print=pretty_print)
        if self.source is not None:
            namespaceprefix_ = self.source_nsprefix_ + ':' if (UseCapturedNS_ and self.source_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespaceprefix_ , eol_))
        for relation_ in self.relation:
            namespaceprefix_ = self.relation_nsprefix_ + ':' if (UseCapturedNS_ and self.relation_nsprefix_) else ''
            relation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relation', pretty_print=pretty_print)
        if self.miscellaneous is not None:
            namespaceprefix_ = self.miscellaneous_nsprefix_ + ':' if (UseCapturedNS_ and self.miscellaneous_nsprefix_) else ''
            self.miscellaneous.export(outfile, level, namespaceprefix_, namespacedef_='', name_='miscellaneous', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'creator':
            obj_ = typed_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creator.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'rights':
            obj_ = typed_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'encoding':
            obj_ = encoding.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encoding = obj_
            obj_.original_tagname_ = 'encoding'
        elif nodeName_ == 'source':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'source')
            value_ = self.gds_validate_string(value_, node, 'source')
            self.source = value_
            self.source_nsprefix_ = child_.prefix
        elif nodeName_ == 'relation':
            obj_ = typed_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'miscellaneous':
            obj_ = miscellaneous.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.miscellaneous = obj_
            obj_.original_tagname_ = 'miscellaneous'
# end class identification


class miscellaneous(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, miscellaneous_field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if miscellaneous_field is None:
            self.miscellaneous_field = []
        else:
            self.miscellaneous_field = miscellaneous_field
        self.miscellaneous_field_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, miscellaneous)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if miscellaneous.subclass:
            return miscellaneous.subclass(*args_, **kwargs_)
        else:
            return miscellaneous(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_miscellaneous_field(self):
        return self.miscellaneous_field
    def set_miscellaneous_field(self, miscellaneous_field):
        self.miscellaneous_field = miscellaneous_field
    def add_miscellaneous_field(self, value):
        self.miscellaneous_field.append(value)
    def insert_miscellaneous_field_at(self, index, value):
        self.miscellaneous_field.insert(index, value)
    def replace_miscellaneous_field_at(self, index, value):
        self.miscellaneous_field[index] = value
    def _hasContent(self):
        if (
            self.miscellaneous_field
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='miscellaneous', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('miscellaneous')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'miscellaneous':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='miscellaneous')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='miscellaneous', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='miscellaneous'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='miscellaneous', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for miscellaneous_field_ in self.miscellaneous_field:
            namespaceprefix_ = self.miscellaneous_field_nsprefix_ + ':' if (UseCapturedNS_ and self.miscellaneous_field_nsprefix_) else ''
            miscellaneous_field_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='miscellaneous-field', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'miscellaneous-field':
            obj_ = miscellaneous_field.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.miscellaneous_field.append(obj_)
            obj_.original_tagname_ = 'miscellaneous-field'
# end class miscellaneous


class miscellaneous_field(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, miscellaneous_field)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if miscellaneous_field.subclass:
            return miscellaneous_field.subclass(*args_, **kwargs_)
        else:
            return miscellaneous_field(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='miscellaneous-field', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('miscellaneous-field')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'miscellaneous-field':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='miscellaneous-field')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='miscellaneous-field', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='miscellaneous-field'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='miscellaneous-field', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.name = ' '.join(self.name.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class miscellaneous_field


class supports(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, element=None, attribute=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.element = _cast(None, element)
        self.element_nsprefix_ = None
        self.attribute = _cast(None, attribute)
        self.attribute_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, supports)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if supports.subclass:
            return supports.subclass(*args_, **kwargs_)
        else:
            return supports(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_element(self):
        return self.element
    def set_element(self, element):
        self.element = element
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='supports', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('supports')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'supports':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='supports')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='supports', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='supports'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.element is not None and 'element' not in already_processed:
            already_processed.add('element')
            outfile.write(' element=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.element), input_name='element')), ))
        if self.attribute is not None and 'attribute' not in already_processed:
            already_processed.add('attribute')
            outfile.write(' attribute=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.attribute), input_name='attribute')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='supports', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_yes_no(self.type_)    # validate type yes-no
        value = find_attr_value_('element', node)
        if value is not None and 'element' not in already_processed:
            already_processed.add('element')
            self.element = value
        value = find_attr_value_('attribute', node)
        if value is not None and 'attribute' not in already_processed:
            already_processed.add('attribute')
            self.attribute = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.value = ' '.join(self.value.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class supports


class appearance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, line_width=None, note_size=None, distance=None, glyph=None, other_appearance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if line_width is None:
            self.line_width = []
        else:
            self.line_width = line_width
        self.line_width_nsprefix_ = None
        if note_size is None:
            self.note_size = []
        else:
            self.note_size = note_size
        self.note_size_nsprefix_ = None
        if distance is None:
            self.distance = []
        else:
            self.distance = distance
        self.distance_nsprefix_ = None
        if glyph is None:
            self.glyph = []
        else:
            self.glyph = glyph
        self.glyph_nsprefix_ = None
        if other_appearance is None:
            self.other_appearance = []
        else:
            self.other_appearance = other_appearance
        self.other_appearance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, appearance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if appearance.subclass:
            return appearance.subclass(*args_, **kwargs_)
        else:
            return appearance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line_width(self):
        return self.line_width
    def set_line_width(self, line_width):
        self.line_width = line_width
    def add_line_width(self, value):
        self.line_width.append(value)
    def insert_line_width_at(self, index, value):
        self.line_width.insert(index, value)
    def replace_line_width_at(self, index, value):
        self.line_width[index] = value
    def get_note_size(self):
        return self.note_size
    def set_note_size(self, note_size):
        self.note_size = note_size
    def add_note_size(self, value):
        self.note_size.append(value)
    def insert_note_size_at(self, index, value):
        self.note_size.insert(index, value)
    def replace_note_size_at(self, index, value):
        self.note_size[index] = value
    def get_distance(self):
        return self.distance
    def set_distance(self, distance):
        self.distance = distance
    def add_distance(self, value):
        self.distance.append(value)
    def insert_distance_at(self, index, value):
        self.distance.insert(index, value)
    def replace_distance_at(self, index, value):
        self.distance[index] = value
    def get_glyph(self):
        return self.glyph
    def set_glyph(self, glyph):
        self.glyph = glyph
    def add_glyph(self, value):
        self.glyph.append(value)
    def insert_glyph_at(self, index, value):
        self.glyph.insert(index, value)
    def replace_glyph_at(self, index, value):
        self.glyph[index] = value
    def get_other_appearance(self):
        return self.other_appearance
    def set_other_appearance(self, other_appearance):
        self.other_appearance = other_appearance
    def add_other_appearance(self, value):
        self.other_appearance.append(value)
    def insert_other_appearance_at(self, index, value):
        self.other_appearance.insert(index, value)
    def replace_other_appearance_at(self, index, value):
        self.other_appearance[index] = value
    def _hasContent(self):
        if (
            self.line_width or
            self.note_size or
            self.distance or
            self.glyph or
            self.other_appearance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='appearance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('appearance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'appearance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='appearance')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='appearance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='appearance'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='appearance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_width_ in self.line_width:
            namespaceprefix_ = self.line_width_nsprefix_ + ':' if (UseCapturedNS_ and self.line_width_nsprefix_) else ''
            line_width_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line-width', pretty_print=pretty_print)
        for note_size_ in self.note_size:
            namespaceprefix_ = self.note_size_nsprefix_ + ':' if (UseCapturedNS_ and self.note_size_nsprefix_) else ''
            note_size_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='note-size', pretty_print=pretty_print)
        for distance_ in self.distance:
            namespaceprefix_ = self.distance_nsprefix_ + ':' if (UseCapturedNS_ and self.distance_nsprefix_) else ''
            distance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distance', pretty_print=pretty_print)
        for glyph_ in self.glyph:
            namespaceprefix_ = self.glyph_nsprefix_ + ':' if (UseCapturedNS_ and self.glyph_nsprefix_) else ''
            glyph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glyph', pretty_print=pretty_print)
        for other_appearance_ in self.other_appearance:
            namespaceprefix_ = self.other_appearance_nsprefix_ + ':' if (UseCapturedNS_ and self.other_appearance_nsprefix_) else ''
            other_appearance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-appearance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'line-width':
            obj_ = line_width.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line_width.append(obj_)
            obj_.original_tagname_ = 'line-width'
        elif nodeName_ == 'note-size':
            obj_ = note_size.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note_size.append(obj_)
            obj_.original_tagname_ = 'note-size'
        elif nodeName_ == 'distance':
            obj_ = distance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distance.append(obj_)
            obj_.original_tagname_ = 'distance'
        elif nodeName_ == 'glyph':
            obj_ = glyph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glyph.append(obj_)
            obj_.original_tagname_ = 'glyph'
        elif nodeName_ == 'other-appearance':
            obj_ = other_appearance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_appearance.append(obj_)
            obj_.original_tagname_ = 'other-appearance'
# end class appearance


class distance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, distance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if distance.subclass:
            return distance.subclass(*args_, **kwargs_)
        else:
            return distance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_distance_type(self, value):
        # Validate type distance-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='distance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('distance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'distance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='distance')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='distance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='distance'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='distance', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_distance_type(self.type_)    # validate type distance-type
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class distance


class glyph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, glyph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if glyph.subclass:
            return glyph.subclass(*args_, **kwargs_)
        else:
            return glyph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_smufl_glyph_name(self, value):
        result = True
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_glyph_type(self, value):
        # Validate type glyph-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='glyph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('glyph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'glyph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='glyph')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='glyph', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='glyph'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='glyph', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_glyph_type(self.type_)    # validate type glyph-type
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class glyph


class line_width(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, line_width)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if line_width.subclass:
            return line_width.subclass(*args_, **kwargs_)
        else:
            return line_width(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_line_width_type(self, value):
        # Validate type line-width-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='line-width', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('line-width')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'line-width':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='line-width')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='line-width', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='line-width'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='line-width', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_line_width_type(self.type_)    # validate type line-width-type
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class line_width


class measure_layout(GeneratedsSuper):
    """measure-distance -- The measure-distance element specifies the horizontal distance from the previous measure. This value is only used for systems where there is horizontal whitespace in the middle of a system, as in systems with codas. To specify the measure width, use the width attribute of the measure element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, measure_distance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.measure_distance = measure_distance
        self.validate_tenths(self.measure_distance)
        self.measure_distance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, measure_layout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if measure_layout.subclass:
            return measure_layout.subclass(*args_, **kwargs_)
        else:
            return measure_layout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_measure_distance(self):
        return self.measure_distance
    def set_measure_distance(self, measure_distance):
        self.measure_distance = measure_distance
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.measure_distance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measure-layout', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('measure-layout')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'measure-layout':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='measure-layout')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='measure-layout', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='measure-layout'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measure-layout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.measure_distance is not None:
            namespaceprefix_ = self.measure_distance_nsprefix_ + ':' if (UseCapturedNS_ and self.measure_distance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smeasure-distance>%s</%smeasure-distance>%s' % (namespaceprefix_ , self.gds_format_decimal(self.measure_distance, input_name='measure-distance'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'measure-distance' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'measure_distance')
            fval_ = self.gds_validate_decimal(fval_, node, 'measure_distance')
            self.measure_distance = fval_
            self.measure_distance_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.measure_distance)
# end class measure_layout


class note_size(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, note_size)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if note_size.subclass:
            return note_size.subclass(*args_, **kwargs_)
        else:
            return note_size(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_non_negative_decimal(self, value):
        result = True
        # Validate type non-negative-decimal, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on non-negative-decimal' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_note_size_type(self, value):
        # Validate type note-size-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['cue', 'grace', 'grace-cue', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-size-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='note-size', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('note-size')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'note-size':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='note-size')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='note-size', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='note-size'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='note-size', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_note_size_type(self.type_)    # validate type note-size-type
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class note_size


class other_appearance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, other_appearance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if other_appearance.subclass:
            return other_appearance.subclass(*args_, **kwargs_)
        else:
            return other_appearance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-appearance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('other-appearance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'other-appearance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='other-appearance')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='other-appearance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='other-appearance'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-appearance', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class other_appearance


class page_layout(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, page_height=None, page_width=None, page_margins=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.page_height = page_height
        self.validate_tenths(self.page_height)
        self.page_height_nsprefix_ = None
        self.page_width = page_width
        self.validate_tenths(self.page_width)
        self.page_width_nsprefix_ = None
        if page_margins is None:
            self.page_margins = []
        else:
            self.page_margins = page_margins
        self.page_margins_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, page_layout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if page_layout.subclass:
            return page_layout.subclass(*args_, **kwargs_)
        else:
            return page_layout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_page_height(self):
        return self.page_height
    def set_page_height(self, page_height):
        self.page_height = page_height
    def get_page_width(self):
        return self.page_width
    def set_page_width(self, page_width):
        self.page_width = page_width
    def get_page_margins(self):
        return self.page_margins
    def set_page_margins(self, page_margins):
        self.page_margins = page_margins
    def add_page_margins(self, value):
        self.page_margins.append(value)
    def insert_page_margins_at(self, index, value):
        self.page_margins.insert(index, value)
    def replace_page_margins_at(self, index, value):
        self.page_margins[index] = value
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.page_height is not None or
            self.page_width is not None or
            self.page_margins
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='page-layout', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('page-layout')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'page-layout':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='page-layout')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='page-layout', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='page-layout'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='page-layout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.page_height is not None:
            namespaceprefix_ = self.page_height_nsprefix_ + ':' if (UseCapturedNS_ and self.page_height_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spage-height>%s</%spage-height>%s' % (namespaceprefix_ , self.gds_format_decimal(self.page_height, input_name='page-height'), namespaceprefix_ , eol_))
        if self.page_width is not None:
            namespaceprefix_ = self.page_width_nsprefix_ + ':' if (UseCapturedNS_ and self.page_width_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spage-width>%s</%spage-width>%s' % (namespaceprefix_ , self.gds_format_decimal(self.page_width, input_name='page-width'), namespaceprefix_ , eol_))
        for page_margins_ in self.page_margins:
            namespaceprefix_ = self.page_margins_nsprefix_ + ':' if (UseCapturedNS_ and self.page_margins_nsprefix_) else ''
            page_margins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='page-margins', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'page-height' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'page_height')
            fval_ = self.gds_validate_decimal(fval_, node, 'page_height')
            self.page_height = fval_
            self.page_height_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.page_height)
        elif nodeName_ == 'page-width' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'page_width')
            fval_ = self.gds_validate_decimal(fval_, node, 'page_width')
            self.page_width = fval_
            self.page_width_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.page_width)
        elif nodeName_ == 'page-margins':
            obj_ = page_margins.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.page_margins.append(obj_)
            obj_.original_tagname_ = 'page-margins'
# end class page_layout


class page_margins(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, left_margin=None, right_margin=None, top_margin=None, bottom_margin=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.left_margin = left_margin
        self.validate_tenths(self.left_margin)
        self.left_margin_nsprefix_ = None
        self.right_margin = right_margin
        self.validate_tenths(self.right_margin)
        self.right_margin_nsprefix_ = None
        self.top_margin = top_margin
        self.validate_tenths(self.top_margin)
        self.top_margin_nsprefix_ = None
        self.bottom_margin = bottom_margin
        self.validate_tenths(self.bottom_margin)
        self.bottom_margin_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, page_margins)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if page_margins.subclass:
            return page_margins.subclass(*args_, **kwargs_)
        else:
            return page_margins(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left_margin(self):
        return self.left_margin
    def set_left_margin(self, left_margin):
        self.left_margin = left_margin
    def get_right_margin(self):
        return self.right_margin
    def set_right_margin(self, right_margin):
        self.right_margin = right_margin
    def get_top_margin(self):
        return self.top_margin
    def set_top_margin(self, top_margin):
        self.top_margin = top_margin
    def get_bottom_margin(self):
        return self.bottom_margin
    def set_bottom_margin(self, bottom_margin):
        self.bottom_margin = bottom_margin
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_margin_type(self, value):
        # Validate type margin-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['odd', 'even', 'both']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on margin-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.left_margin is not None or
            self.right_margin is not None or
            self.top_margin is not None or
            self.bottom_margin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='page-margins', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('page-margins')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'page-margins':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='page-margins')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='page-margins', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='page-margins'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='page-margins', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left_margin is not None:
            namespaceprefix_ = self.left_margin_nsprefix_ + ':' if (UseCapturedNS_ and self.left_margin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sleft-margin>%s</%sleft-margin>%s' % (namespaceprefix_ , self.gds_format_decimal(self.left_margin, input_name='left-margin'), namespaceprefix_ , eol_))
        if self.right_margin is not None:
            namespaceprefix_ = self.right_margin_nsprefix_ + ':' if (UseCapturedNS_ and self.right_margin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sright-margin>%s</%sright-margin>%s' % (namespaceprefix_ , self.gds_format_decimal(self.right_margin, input_name='right-margin'), namespaceprefix_ , eol_))
        if self.top_margin is not None:
            namespaceprefix_ = self.top_margin_nsprefix_ + ':' if (UseCapturedNS_ and self.top_margin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stop-margin>%s</%stop-margin>%s' % (namespaceprefix_ , self.gds_format_decimal(self.top_margin, input_name='top-margin'), namespaceprefix_ , eol_))
        if self.bottom_margin is not None:
            namespaceprefix_ = self.bottom_margin_nsprefix_ + ':' if (UseCapturedNS_ and self.bottom_margin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbottom-margin>%s</%sbottom-margin>%s' % (namespaceprefix_ , self.gds_format_decimal(self.bottom_margin, input_name='bottom-margin'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_margin_type(self.type_)    # validate type margin-type
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left-margin' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'left_margin')
            fval_ = self.gds_validate_decimal(fval_, node, 'left_margin')
            self.left_margin = fval_
            self.left_margin_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.left_margin)
        elif nodeName_ == 'right-margin' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'right_margin')
            fval_ = self.gds_validate_decimal(fval_, node, 'right_margin')
            self.right_margin = fval_
            self.right_margin_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.right_margin)
        elif nodeName_ == 'top-margin' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'top_margin')
            fval_ = self.gds_validate_decimal(fval_, node, 'top_margin')
            self.top_margin = fval_
            self.top_margin_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.top_margin)
        elif nodeName_ == 'bottom-margin' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'bottom_margin')
            fval_ = self.gds_validate_decimal(fval_, node, 'bottom_margin')
            self.bottom_margin = fval_
            self.bottom_margin_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.bottom_margin)
# end class page_margins


class scaling(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, millimeters=None, tenths=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.millimeters = millimeters
        self.validate_millimeters(self.millimeters)
        self.millimeters_nsprefix_ = None
        self.tenths = tenths
        self.validate_tenths(self.tenths)
        self.tenths_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scaling)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scaling.subclass:
            return scaling.subclass(*args_, **kwargs_)
        else:
            return scaling(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_millimeters(self):
        return self.millimeters
    def set_millimeters(self, millimeters):
        self.millimeters = millimeters
    def get_tenths(self):
        return self.tenths
    def set_tenths(self, tenths):
        self.tenths = tenths
    def validate_millimeters(self, value):
        result = True
        # Validate type millimeters, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.millimeters is not None or
            self.tenths is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scaling', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scaling')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scaling':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scaling')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scaling', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scaling'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scaling', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.millimeters is not None:
            namespaceprefix_ = self.millimeters_nsprefix_ + ':' if (UseCapturedNS_ and self.millimeters_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smillimeters>%s</%smillimeters>%s' % (namespaceprefix_ , self.gds_format_decimal(self.millimeters, input_name='millimeters'), namespaceprefix_ , eol_))
        if self.tenths is not None:
            namespaceprefix_ = self.tenths_nsprefix_ + ':' if (UseCapturedNS_ and self.tenths_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stenths>%s</%stenths>%s' % (namespaceprefix_ , self.gds_format_decimal(self.tenths, input_name='tenths'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'millimeters' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'millimeters')
            fval_ = self.gds_validate_decimal(fval_, node, 'millimeters')
            self.millimeters = fval_
            self.millimeters_nsprefix_ = child_.prefix
            # validate type millimeters
            self.validate_millimeters(self.millimeters)
        elif nodeName_ == 'tenths' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'tenths')
            fval_ = self.gds_validate_decimal(fval_, node, 'tenths')
            self.tenths = fval_
            self.tenths_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.tenths)
# end class scaling


class staff_layout(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, staff_distance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.staff_distance = staff_distance
        self.validate_tenths(self.staff_distance)
        self.staff_distance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, staff_layout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if staff_layout.subclass:
            return staff_layout.subclass(*args_, **kwargs_)
        else:
            return staff_layout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_staff_distance(self):
        return self.staff_distance
    def set_staff_distance(self, staff_distance):
        self.staff_distance = staff_distance
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_staff_number(self, value):
        # Validate type staff-number, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.staff_distance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-layout', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('staff-layout')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'staff-layout':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='staff-layout')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='staff-layout', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='staff-layout'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='staff-layout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.staff_distance is not None:
            namespaceprefix_ = self.staff_distance_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_distance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaff-distance>%s</%sstaff-distance>%s' % (namespaceprefix_ , self.gds_format_decimal(self.staff_distance, input_name='staff-distance'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_staff_number(self.number)    # validate type staff-number
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'staff-distance' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'staff_distance')
            fval_ = self.gds_validate_decimal(fval_, node, 'staff_distance')
            self.staff_distance = fval_
            self.staff_distance_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.staff_distance)
# end class staff_layout


class system_dividers(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, left_divider=None, right_divider=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.left_divider = left_divider
        self.left_divider_nsprefix_ = None
        self.right_divider = right_divider
        self.right_divider_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, system_dividers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if system_dividers.subclass:
            return system_dividers.subclass(*args_, **kwargs_)
        else:
            return system_dividers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left_divider(self):
        return self.left_divider
    def set_left_divider(self, left_divider):
        self.left_divider = left_divider
    def get_right_divider(self):
        return self.right_divider
    def set_right_divider(self, right_divider):
        self.right_divider = right_divider
    def _hasContent(self):
        if (
            self.left_divider is not None or
            self.right_divider is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='system-dividers', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('system-dividers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'system-dividers':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='system-dividers')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='system-dividers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='system-dividers'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='system-dividers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left_divider is not None:
            namespaceprefix_ = self.left_divider_nsprefix_ + ':' if (UseCapturedNS_ and self.left_divider_nsprefix_) else ''
            self.left_divider.export(outfile, level, namespaceprefix_, namespacedef_='', name_='left-divider', pretty_print=pretty_print)
        if self.right_divider is not None:
            namespaceprefix_ = self.right_divider_nsprefix_ + ':' if (UseCapturedNS_ and self.right_divider_nsprefix_) else ''
            self.right_divider.export(outfile, level, namespaceprefix_, namespacedef_='', name_='right-divider', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left-divider':
            obj_ = empty_print_object_style_align.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.left_divider = obj_
            obj_.original_tagname_ = 'left-divider'
        elif nodeName_ == 'right-divider':
            obj_ = empty_print_object_style_align.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.right_divider = obj_
            obj_.original_tagname_ = 'right-divider'
# end class system_dividers


class system_layout(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, system_margins=None, system_distance=None, top_system_distance=None, system_dividers=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.system_margins = system_margins
        self.system_margins_nsprefix_ = None
        self.system_distance = system_distance
        self.validate_tenths(self.system_distance)
        self.system_distance_nsprefix_ = None
        self.top_system_distance = top_system_distance
        self.validate_tenths(self.top_system_distance)
        self.top_system_distance_nsprefix_ = None
        self.system_dividers = system_dividers
        self.system_dividers_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, system_layout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if system_layout.subclass:
            return system_layout.subclass(*args_, **kwargs_)
        else:
            return system_layout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system_margins(self):
        return self.system_margins
    def set_system_margins(self, system_margins):
        self.system_margins = system_margins
    def get_system_distance(self):
        return self.system_distance
    def set_system_distance(self, system_distance):
        self.system_distance = system_distance
    def get_top_system_distance(self):
        return self.top_system_distance
    def set_top_system_distance(self, top_system_distance):
        self.top_system_distance = top_system_distance
    def get_system_dividers(self):
        return self.system_dividers
    def set_system_dividers(self, system_dividers):
        self.system_dividers = system_dividers
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.system_margins is not None or
            self.system_distance is not None or
            self.top_system_distance is not None or
            self.system_dividers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='system-layout', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('system-layout')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'system-layout':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='system-layout')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='system-layout', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='system-layout'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='system-layout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.system_margins is not None:
            namespaceprefix_ = self.system_margins_nsprefix_ + ':' if (UseCapturedNS_ and self.system_margins_nsprefix_) else ''
            self.system_margins.export(outfile, level, namespaceprefix_, namespacedef_='', name_='system-margins', pretty_print=pretty_print)
        if self.system_distance is not None:
            namespaceprefix_ = self.system_distance_nsprefix_ + ':' if (UseCapturedNS_ and self.system_distance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystem-distance>%s</%ssystem-distance>%s' % (namespaceprefix_ , self.gds_format_decimal(self.system_distance, input_name='system-distance'), namespaceprefix_ , eol_))
        if self.top_system_distance is not None:
            namespaceprefix_ = self.top_system_distance_nsprefix_ + ':' if (UseCapturedNS_ and self.top_system_distance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stop-system-distance>%s</%stop-system-distance>%s' % (namespaceprefix_ , self.gds_format_decimal(self.top_system_distance, input_name='top-system-distance'), namespaceprefix_ , eol_))
        if self.system_dividers is not None:
            namespaceprefix_ = self.system_dividers_nsprefix_ + ':' if (UseCapturedNS_ and self.system_dividers_nsprefix_) else ''
            self.system_dividers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='system-dividers', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'system-margins':
            obj_ = system_margins.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.system_margins = obj_
            obj_.original_tagname_ = 'system-margins'
        elif nodeName_ == 'system-distance' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'system_distance')
            fval_ = self.gds_validate_decimal(fval_, node, 'system_distance')
            self.system_distance = fval_
            self.system_distance_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.system_distance)
        elif nodeName_ == 'top-system-distance' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'top_system_distance')
            fval_ = self.gds_validate_decimal(fval_, node, 'top_system_distance')
            self.top_system_distance = fval_
            self.top_system_distance_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.top_system_distance)
        elif nodeName_ == 'system-dividers':
            obj_ = system_dividers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.system_dividers = obj_
            obj_.original_tagname_ = 'system-dividers'
# end class system_layout


class system_margins(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, left_margin=None, right_margin=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.left_margin = left_margin
        self.validate_tenths(self.left_margin)
        self.left_margin_nsprefix_ = None
        self.right_margin = right_margin
        self.validate_tenths(self.right_margin)
        self.right_margin_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, system_margins)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if system_margins.subclass:
            return system_margins.subclass(*args_, **kwargs_)
        else:
            return system_margins(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left_margin(self):
        return self.left_margin
    def set_left_margin(self, left_margin):
        self.left_margin = left_margin
    def get_right_margin(self):
        return self.right_margin
    def set_right_margin(self, right_margin):
        self.right_margin = right_margin
    def validate_tenths(self, value):
        result = True
        # Validate type tenths, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.left_margin is not None or
            self.right_margin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='system-margins', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('system-margins')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'system-margins':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='system-margins')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='system-margins', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='system-margins'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='system-margins', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left_margin is not None:
            namespaceprefix_ = self.left_margin_nsprefix_ + ':' if (UseCapturedNS_ and self.left_margin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sleft-margin>%s</%sleft-margin>%s' % (namespaceprefix_ , self.gds_format_decimal(self.left_margin, input_name='left-margin'), namespaceprefix_ , eol_))
        if self.right_margin is not None:
            namespaceprefix_ = self.right_margin_nsprefix_ + ':' if (UseCapturedNS_ and self.right_margin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sright-margin>%s</%sright-margin>%s' % (namespaceprefix_ , self.gds_format_decimal(self.right_margin, input_name='right-margin'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left-margin' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'left_margin')
            fval_ = self.gds_validate_decimal(fval_, node, 'left_margin')
            self.left_margin = fval_
            self.left_margin_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.left_margin)
        elif nodeName_ == 'right-margin' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'right_margin')
            fval_ = self.gds_validate_decimal(fval_, node, 'right_margin')
            self.right_margin = fval_
            self.right_margin_nsprefix_ = child_.prefix
            # validate type tenths
            self.validate_tenths(self.right_margin)
# end class system_margins


class bookmark(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, element=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.element = _cast(None, element)
        self.element_nsprefix_ = None
        self.position = _cast(int, position)
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bookmark)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bookmark.subclass:
            return bookmark.subclass(*args_, **kwargs_)
        else:
            return bookmark(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_element(self):
        return self.element
    def set_element(self, element):
        self.element = element
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bookmark', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bookmark')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bookmark':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bookmark')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bookmark', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bookmark'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.element is not None and 'element' not in already_processed:
            already_processed.add('element')
            outfile.write(' element=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.element), input_name='element')), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bookmark', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.name = ' '.join(self.name.split())
        value = find_attr_value_('element', node)
        if value is not None and 'element' not in already_processed:
            already_processed.add('element')
            self.element = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = self.gds_parse_integer(value, node, 'position')
            if self.position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class bookmark


class link(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, href=None, type_='simple', role=None, title=None, show='replace', actuate='onRequest', element=None, position=None, default_x=None, default_y=None, relative_x=None, relative_y=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.element = _cast(None, element)
        self.element_nsprefix_ = None
        self.position = _cast(int, position)
        self.position_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if link.subclass:
            return link.subclass(*args_, **kwargs_)
        else:
            return link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_element(self):
        return self.element
    def set_element(self, element):
        self.element = element
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='link', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'link':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='link')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='link', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='link'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' xlink:href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' xlink:role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' xlink:title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.show != "replace" and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' xlink:show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate != "onRequest" and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' xlink:actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.element is not None and 'element' not in already_processed:
            already_processed.add('element')
            outfile.write(' element=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.element), input_name='element')), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='link', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.name = ' '.join(self.name.split())
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.role = ' '.join(self.role.split())
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.title = ' '.join(self.title.split())
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('element', node)
        if value is not None and 'element' not in already_processed:
            already_processed.add('element')
            self.element = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = self.gds_parse_integer(value, node, 'position')
            if self.position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class link


class accidental(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cautionary=None, editorial=None, smufl=None, parentheses=None, bracket=None, size=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cautionary = _cast(None, cautionary)
        self.cautionary_nsprefix_ = None
        self.editorial = _cast(None, editorial)
        self.editorial_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.parentheses = _cast(None, parentheses)
        self.parentheses_nsprefix_ = None
        self.bracket = _cast(None, bracket)
        self.bracket_nsprefix_ = None
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accidental)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accidental.subclass:
            return accidental.subclass(*args_, **kwargs_)
        else:
            return accidental(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cautionary(self):
        return self.cautionary
    def set_cautionary(self, cautionary):
        self.cautionary = cautionary
    def get_editorial(self):
        return self.editorial
    def set_editorial(self, editorial):
        self.editorial = editorial
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_parentheses(self):
        return self.parentheses
    def set_parentheses(self, parentheses):
        self.parentheses = parentheses
    def get_bracket(self):
        return self.bracket
    def set_bracket(self, bracket):
        self.bracket = bracket
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_accidental_value(self, value):
        result = True
        # Validate type accidental-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['sharp', 'natural', 'flat', 'double-sharp', 'sharp-sharp', 'flat-flat', 'natural-sharp', 'natural-flat', 'quarter-flat', 'quarter-sharp', 'three-quarters-flat', 'three-quarters-sharp', 'sharp-down', 'sharp-up', 'natural-down', 'natural-up', 'flat-down', 'flat-up', 'double-sharp-down', 'double-sharp-up', 'flat-flat-down', 'flat-flat-up', 'arrow-down', 'arrow-up', 'triple-sharp', 'triple-flat', 'slash-quarter-sharp', 'slash-sharp', 'slash-flat', 'double-slash-flat', 'sharp-1', 'sharp-2', 'sharp-3', 'sharp-5', 'flat-1', 'flat-2', 'flat-3', 'flat-4', 'sori', 'koron', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on accidental-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_smufl_accidental_glyph_name(self, value):
        # Validate type smufl-accidental-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_accidental_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_accidental_glyph_name_patterns_, ))
    validate_smufl_accidental_glyph_name_patterns_ = [['^((acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)(\\c+))$']]
    def validate_symbol_size(self, value):
        # Validate type symbol-size, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['full', 'cue', 'grace-cue', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on symbol-size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accidental', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accidental')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accidental':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accidental')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accidental', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accidental'):
        if self.cautionary is not None and 'cautionary' not in already_processed:
            already_processed.add('cautionary')
            outfile.write(' cautionary=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cautionary), input_name='cautionary')), ))
        if self.editorial is not None and 'editorial' not in already_processed:
            already_processed.add('editorial')
            outfile.write(' editorial=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.editorial), input_name='editorial')), ))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
        if self.parentheses is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            outfile.write(' parentheses=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentheses), input_name='parentheses')), ))
        if self.bracket is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            outfile.write(' bracket=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bracket), input_name='bracket')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accidental', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cautionary', node)
        if value is not None and 'cautionary' not in already_processed:
            already_processed.add('cautionary')
            self.cautionary = value
            self.cautionary = ' '.join(self.cautionary.split())
            self.validate_yes_no(self.cautionary)    # validate type yes-no
        value = find_attr_value_('editorial', node)
        if value is not None and 'editorial' not in already_processed:
            already_processed.add('editorial')
            self.editorial = value
            self.editorial = ' '.join(self.editorial.split())
            self.validate_yes_no(self.editorial)    # validate type yes-no
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_accidental_glyph_name(self.smufl)    # validate type smufl-accidental-glyph-name
        value = find_attr_value_('parentheses', node)
        if value is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            self.parentheses = value
            self.parentheses = ' '.join(self.parentheses.split())
            self.validate_yes_no(self.parentheses)    # validate type yes-no
        value = find_attr_value_('bracket', node)
        if value is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            self.bracket = value
            self.bracket = ' '.join(self.bracket.split())
            self.validate_yes_no(self.bracket)    # validate type yes-no
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.size = ' '.join(self.size.split())
            self.validate_symbol_size(self.size)    # validate type symbol-size
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class accidental


class accidental_mark(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, parentheses=None, bracket=None, size=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.parentheses = _cast(None, parentheses)
        self.parentheses_nsprefix_ = None
        self.bracket = _cast(None, bracket)
        self.bracket_nsprefix_ = None
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accidental_mark)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accidental_mark.subclass:
            return accidental_mark.subclass(*args_, **kwargs_)
        else:
            return accidental_mark(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_parentheses(self):
        return self.parentheses
    def set_parentheses(self, parentheses):
        self.parentheses = parentheses
    def get_bracket(self):
        return self.bracket
    def set_bracket(self, bracket):
        self.bracket = bracket
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_accidental_value(self, value):
        result = True
        # Validate type accidental-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['sharp', 'natural', 'flat', 'double-sharp', 'sharp-sharp', 'flat-flat', 'natural-sharp', 'natural-flat', 'quarter-flat', 'quarter-sharp', 'three-quarters-flat', 'three-quarters-sharp', 'sharp-down', 'sharp-up', 'natural-down', 'natural-up', 'flat-down', 'flat-up', 'double-sharp-down', 'double-sharp-up', 'flat-flat-down', 'flat-flat-up', 'arrow-down', 'arrow-up', 'triple-sharp', 'triple-flat', 'slash-quarter-sharp', 'slash-sharp', 'slash-flat', 'double-slash-flat', 'sharp-1', 'sharp-2', 'sharp-3', 'sharp-5', 'flat-1', 'flat-2', 'flat-3', 'flat-4', 'sori', 'koron', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on accidental-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_smufl_accidental_glyph_name(self, value):
        # Validate type smufl-accidental-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_accidental_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_accidental_glyph_name_patterns_, ))
    validate_smufl_accidental_glyph_name_patterns_ = [['^((acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)(\\c+))$']]
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_symbol_size(self, value):
        # Validate type symbol-size, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['full', 'cue', 'grace-cue', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on symbol-size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accidental-mark', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accidental-mark')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accidental-mark':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accidental-mark')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accidental-mark', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accidental-mark'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
        if self.parentheses is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            outfile.write(' parentheses=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentheses), input_name='parentheses')), ))
        if self.bracket is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            outfile.write(' bracket=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bracket), input_name='bracket')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accidental-mark', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_accidental_glyph_name(self.smufl)    # validate type smufl-accidental-glyph-name
        value = find_attr_value_('parentheses', node)
        if value is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            self.parentheses = value
            self.parentheses = ' '.join(self.parentheses.split())
            self.validate_yes_no(self.parentheses)    # validate type yes-no
        value = find_attr_value_('bracket', node)
        if value is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            self.bracket = value
            self.bracket = ' '.join(self.bracket.split())
            self.validate_yes_no(self.bracket)    # validate type yes-no
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.size = ' '.join(self.size.split())
            self.validate_symbol_size(self.size)    # validate type symbol-size
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class accidental_mark


class arpeggiate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, direction=None, unbroken=None, default_x=None, default_y=None, relative_x=None, relative_y=None, placement=None, color=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
        self.unbroken = _cast(None, unbroken)
        self.unbroken_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, arpeggiate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if arpeggiate.subclass:
            return arpeggiate.subclass(*args_, **kwargs_)
        else:
            return arpeggiate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_unbroken(self):
        return self.unbroken
    def set_unbroken(self, unbroken):
        self.unbroken = unbroken
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_up_down(self, value):
        # Validate type up-down, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['up', 'down']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on up-down' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='arpeggiate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('arpeggiate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'arpeggiate':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='arpeggiate')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='arpeggiate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='arpeggiate'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
        if self.unbroken is not None and 'unbroken' not in already_processed:
            already_processed.add('unbroken')
            outfile.write(' unbroken=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unbroken), input_name='unbroken')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='arpeggiate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
            self.direction = ' '.join(self.direction.split())
            self.validate_up_down(self.direction)    # validate type up-down
        value = find_attr_value_('unbroken', node)
        if value is not None and 'unbroken' not in already_processed:
            already_processed.add('unbroken')
            self.unbroken = value
            self.unbroken = ' '.join(self.unbroken.split())
            self.validate_yes_no(self.unbroken)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class arpeggiate


class articulations(GeneratedsSuper):
    """accent -- The accent element indicates a regular horizontal accent mark.
    strong-accent -- The strong-accent element indicates a vertical accent mark.
    staccato -- The staccato element is used for a dot articulation, as opposed to a stroke or a wedge.
    tenuto -- The tenuto element indicates a tenuto line symbol.
    detached-legato -- The detached-legato element indicates the combination of a tenuto line and staccato dot symbol.
    staccatissimo -- The staccatissimo element is used for a wedge articulation, as opposed to a dot or a stroke.
    spiccato -- The spiccato element is used for a stroke articulation, as opposed to a dot or a wedge.
    scoop -- The scoop element is an indeterminate slide attached to a single note. The scoop appears before the main note and comes from below the main pitch.
    plop -- The plop element is an indeterminate slide attached to a single note. The plop appears before the main note and comes from above the main pitch.
    doit -- The doit element is an indeterminate slide attached to a single note. The doit appears after the main note and goes above the main pitch.
    falloff -- The falloff element is an indeterminate slide attached to a single note. The falloff appears after the main note and goes below the main pitch.
    stress -- The stress element indicates a stressed note.
    unstress -- The unstress element indicates an unstressed note. It is often notated using a u-shaped symbol.
    soft-accent -- The soft-accent element indicates a soft accent that is not as heavy as a normal accent. It is often notated as
    <
    >
    . It can be combined with other articulations to implement the first eight symbols in the SMuFL Articulation supplement range.
    other-articulation -- The other-articulation element is used to define any articulations not yet in the MusicXML format. The smufl attribute can be used to specify a particular articulation, allowing application interoperability without requiring every SMuFL articulation to have a MusicXML element equivalent. Using the other-articulation element without the smufl attribute allows for extended representation, though without application interoperability.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, accent=None, strong_accent=None, staccato=None, tenuto=None, detached_legato=None, staccatissimo=None, spiccato=None, scoop=None, plop=None, doit=None, falloff=None, breath_mark=None, caesura=None, stress=None, unstress=None, soft_accent=None, other_articulation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if accent is None:
            self.accent = []
        else:
            self.accent = accent
        self.accent_nsprefix_ = None
        if strong_accent is None:
            self.strong_accent = []
        else:
            self.strong_accent = strong_accent
        self.strong_accent_nsprefix_ = None
        if staccato is None:
            self.staccato = []
        else:
            self.staccato = staccato
        self.staccato_nsprefix_ = None
        if tenuto is None:
            self.tenuto = []
        else:
            self.tenuto = tenuto
        self.tenuto_nsprefix_ = None
        if detached_legato is None:
            self.detached_legato = []
        else:
            self.detached_legato = detached_legato
        self.detached_legato_nsprefix_ = None
        if staccatissimo is None:
            self.staccatissimo = []
        else:
            self.staccatissimo = staccatissimo
        self.staccatissimo_nsprefix_ = None
        if spiccato is None:
            self.spiccato = []
        else:
            self.spiccato = spiccato
        self.spiccato_nsprefix_ = None
        if scoop is None:
            self.scoop = []
        else:
            self.scoop = scoop
        self.scoop_nsprefix_ = None
        if plop is None:
            self.plop = []
        else:
            self.plop = plop
        self.plop_nsprefix_ = None
        if doit is None:
            self.doit = []
        else:
            self.doit = doit
        self.doit_nsprefix_ = None
        if falloff is None:
            self.falloff = []
        else:
            self.falloff = falloff
        self.falloff_nsprefix_ = None
        if breath_mark is None:
            self.breath_mark = []
        else:
            self.breath_mark = breath_mark
        self.breath_mark_nsprefix_ = None
        if caesura is None:
            self.caesura = []
        else:
            self.caesura = caesura
        self.caesura_nsprefix_ = None
        if stress is None:
            self.stress = []
        else:
            self.stress = stress
        self.stress_nsprefix_ = None
        if unstress is None:
            self.unstress = []
        else:
            self.unstress = unstress
        self.unstress_nsprefix_ = None
        if soft_accent is None:
            self.soft_accent = []
        else:
            self.soft_accent = soft_accent
        self.soft_accent_nsprefix_ = None
        if other_articulation is None:
            self.other_articulation = []
        else:
            self.other_articulation = other_articulation
        self.other_articulation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, articulations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if articulations.subclass:
            return articulations.subclass(*args_, **kwargs_)
        else:
            return articulations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accent(self):
        return self.accent
    def set_accent(self, accent):
        self.accent = accent
    def add_accent(self, value):
        self.accent.append(value)
    def insert_accent_at(self, index, value):
        self.accent.insert(index, value)
    def replace_accent_at(self, index, value):
        self.accent[index] = value
    def get_strong_accent(self):
        return self.strong_accent
    def set_strong_accent(self, strong_accent):
        self.strong_accent = strong_accent
    def add_strong_accent(self, value):
        self.strong_accent.append(value)
    def insert_strong_accent_at(self, index, value):
        self.strong_accent.insert(index, value)
    def replace_strong_accent_at(self, index, value):
        self.strong_accent[index] = value
    def get_staccato(self):
        return self.staccato
    def set_staccato(self, staccato):
        self.staccato = staccato
    def add_staccato(self, value):
        self.staccato.append(value)
    def insert_staccato_at(self, index, value):
        self.staccato.insert(index, value)
    def replace_staccato_at(self, index, value):
        self.staccato[index] = value
    def get_tenuto(self):
        return self.tenuto
    def set_tenuto(self, tenuto):
        self.tenuto = tenuto
    def add_tenuto(self, value):
        self.tenuto.append(value)
    def insert_tenuto_at(self, index, value):
        self.tenuto.insert(index, value)
    def replace_tenuto_at(self, index, value):
        self.tenuto[index] = value
    def get_detached_legato(self):
        return self.detached_legato
    def set_detached_legato(self, detached_legato):
        self.detached_legato = detached_legato
    def add_detached_legato(self, value):
        self.detached_legato.append(value)
    def insert_detached_legato_at(self, index, value):
        self.detached_legato.insert(index, value)
    def replace_detached_legato_at(self, index, value):
        self.detached_legato[index] = value
    def get_staccatissimo(self):
        return self.staccatissimo
    def set_staccatissimo(self, staccatissimo):
        self.staccatissimo = staccatissimo
    def add_staccatissimo(self, value):
        self.staccatissimo.append(value)
    def insert_staccatissimo_at(self, index, value):
        self.staccatissimo.insert(index, value)
    def replace_staccatissimo_at(self, index, value):
        self.staccatissimo[index] = value
    def get_spiccato(self):
        return self.spiccato
    def set_spiccato(self, spiccato):
        self.spiccato = spiccato
    def add_spiccato(self, value):
        self.spiccato.append(value)
    def insert_spiccato_at(self, index, value):
        self.spiccato.insert(index, value)
    def replace_spiccato_at(self, index, value):
        self.spiccato[index] = value
    def get_scoop(self):
        return self.scoop
    def set_scoop(self, scoop):
        self.scoop = scoop
    def add_scoop(self, value):
        self.scoop.append(value)
    def insert_scoop_at(self, index, value):
        self.scoop.insert(index, value)
    def replace_scoop_at(self, index, value):
        self.scoop[index] = value
    def get_plop(self):
        return self.plop
    def set_plop(self, plop):
        self.plop = plop
    def add_plop(self, value):
        self.plop.append(value)
    def insert_plop_at(self, index, value):
        self.plop.insert(index, value)
    def replace_plop_at(self, index, value):
        self.plop[index] = value
    def get_doit(self):
        return self.doit
    def set_doit(self, doit):
        self.doit = doit
    def add_doit(self, value):
        self.doit.append(value)
    def insert_doit_at(self, index, value):
        self.doit.insert(index, value)
    def replace_doit_at(self, index, value):
        self.doit[index] = value
    def get_falloff(self):
        return self.falloff
    def set_falloff(self, falloff):
        self.falloff = falloff
    def add_falloff(self, value):
        self.falloff.append(value)
    def insert_falloff_at(self, index, value):
        self.falloff.insert(index, value)
    def replace_falloff_at(self, index, value):
        self.falloff[index] = value
    def get_breath_mark(self):
        return self.breath_mark
    def set_breath_mark(self, breath_mark):
        self.breath_mark = breath_mark
    def add_breath_mark(self, value):
        self.breath_mark.append(value)
    def insert_breath_mark_at(self, index, value):
        self.breath_mark.insert(index, value)
    def replace_breath_mark_at(self, index, value):
        self.breath_mark[index] = value
    def get_caesura(self):
        return self.caesura
    def set_caesura(self, caesura):
        self.caesura = caesura
    def add_caesura(self, value):
        self.caesura.append(value)
    def insert_caesura_at(self, index, value):
        self.caesura.insert(index, value)
    def replace_caesura_at(self, index, value):
        self.caesura[index] = value
    def get_stress(self):
        return self.stress
    def set_stress(self, stress):
        self.stress = stress
    def add_stress(self, value):
        self.stress.append(value)
    def insert_stress_at(self, index, value):
        self.stress.insert(index, value)
    def replace_stress_at(self, index, value):
        self.stress[index] = value
    def get_unstress(self):
        return self.unstress
    def set_unstress(self, unstress):
        self.unstress = unstress
    def add_unstress(self, value):
        self.unstress.append(value)
    def insert_unstress_at(self, index, value):
        self.unstress.insert(index, value)
    def replace_unstress_at(self, index, value):
        self.unstress[index] = value
    def get_soft_accent(self):
        return self.soft_accent
    def set_soft_accent(self, soft_accent):
        self.soft_accent = soft_accent
    def add_soft_accent(self, value):
        self.soft_accent.append(value)
    def insert_soft_accent_at(self, index, value):
        self.soft_accent.insert(index, value)
    def replace_soft_accent_at(self, index, value):
        self.soft_accent[index] = value
    def get_other_articulation(self):
        return self.other_articulation
    def set_other_articulation(self, other_articulation):
        self.other_articulation = other_articulation
    def add_other_articulation(self, value):
        self.other_articulation.append(value)
    def insert_other_articulation_at(self, index, value):
        self.other_articulation.insert(index, value)
    def replace_other_articulation_at(self, index, value):
        self.other_articulation[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.accent or
            self.strong_accent or
            self.staccato or
            self.tenuto or
            self.detached_legato or
            self.staccatissimo or
            self.spiccato or
            self.scoop or
            self.plop or
            self.doit or
            self.falloff or
            self.breath_mark or
            self.caesura or
            self.stress or
            self.unstress or
            self.soft_accent or
            self.other_articulation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='articulations', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('articulations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'articulations':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='articulations')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='articulations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='articulations'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='articulations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accent_ in self.accent:
            namespaceprefix_ = self.accent_nsprefix_ + ':' if (UseCapturedNS_ and self.accent_nsprefix_) else ''
            accent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accent', pretty_print=pretty_print)
        for strong_accent_ in self.strong_accent:
            namespaceprefix_ = self.strong_accent_nsprefix_ + ':' if (UseCapturedNS_ and self.strong_accent_nsprefix_) else ''
            strong_accent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strong-accent', pretty_print=pretty_print)
        for staccato_ in self.staccato:
            namespaceprefix_ = self.staccato_nsprefix_ + ':' if (UseCapturedNS_ and self.staccato_nsprefix_) else ''
            staccato_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='staccato', pretty_print=pretty_print)
        for tenuto_ in self.tenuto:
            namespaceprefix_ = self.tenuto_nsprefix_ + ':' if (UseCapturedNS_ and self.tenuto_nsprefix_) else ''
            tenuto_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tenuto', pretty_print=pretty_print)
        for detached_legato_ in self.detached_legato:
            namespaceprefix_ = self.detached_legato_nsprefix_ + ':' if (UseCapturedNS_ and self.detached_legato_nsprefix_) else ''
            detached_legato_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detached-legato', pretty_print=pretty_print)
        for staccatissimo_ in self.staccatissimo:
            namespaceprefix_ = self.staccatissimo_nsprefix_ + ':' if (UseCapturedNS_ and self.staccatissimo_nsprefix_) else ''
            staccatissimo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='staccatissimo', pretty_print=pretty_print)
        for spiccato_ in self.spiccato:
            namespaceprefix_ = self.spiccato_nsprefix_ + ':' if (UseCapturedNS_ and self.spiccato_nsprefix_) else ''
            spiccato_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spiccato', pretty_print=pretty_print)
        for scoop_ in self.scoop:
            namespaceprefix_ = self.scoop_nsprefix_ + ':' if (UseCapturedNS_ and self.scoop_nsprefix_) else ''
            scoop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scoop', pretty_print=pretty_print)
        for plop_ in self.plop:
            namespaceprefix_ = self.plop_nsprefix_ + ':' if (UseCapturedNS_ and self.plop_nsprefix_) else ''
            plop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plop', pretty_print=pretty_print)
        for doit_ in self.doit:
            namespaceprefix_ = self.doit_nsprefix_ + ':' if (UseCapturedNS_ and self.doit_nsprefix_) else ''
            doit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='doit', pretty_print=pretty_print)
        for falloff_ in self.falloff:
            namespaceprefix_ = self.falloff_nsprefix_ + ':' if (UseCapturedNS_ and self.falloff_nsprefix_) else ''
            falloff_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='falloff', pretty_print=pretty_print)
        for breath_mark_ in self.breath_mark:
            namespaceprefix_ = self.breath_mark_nsprefix_ + ':' if (UseCapturedNS_ and self.breath_mark_nsprefix_) else ''
            breath_mark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='breath-mark', pretty_print=pretty_print)
        for caesura_ in self.caesura:
            namespaceprefix_ = self.caesura_nsprefix_ + ':' if (UseCapturedNS_ and self.caesura_nsprefix_) else ''
            caesura_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caesura', pretty_print=pretty_print)
        for stress_ in self.stress:
            namespaceprefix_ = self.stress_nsprefix_ + ':' if (UseCapturedNS_ and self.stress_nsprefix_) else ''
            stress_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='stress', pretty_print=pretty_print)
        for unstress_ in self.unstress:
            namespaceprefix_ = self.unstress_nsprefix_ + ':' if (UseCapturedNS_ and self.unstress_nsprefix_) else ''
            unstress_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unstress', pretty_print=pretty_print)
        for soft_accent_ in self.soft_accent:
            namespaceprefix_ = self.soft_accent_nsprefix_ + ':' if (UseCapturedNS_ and self.soft_accent_nsprefix_) else ''
            soft_accent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='soft-accent', pretty_print=pretty_print)
        for other_articulation_ in self.other_articulation:
            namespaceprefix_ = self.other_articulation_nsprefix_ + ':' if (UseCapturedNS_ and self.other_articulation_nsprefix_) else ''
            other_articulation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-articulation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accent':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accent.append(obj_)
            obj_.original_tagname_ = 'accent'
        elif nodeName_ == 'strong-accent':
            obj_ = strong_accent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.strong_accent.append(obj_)
            obj_.original_tagname_ = 'strong-accent'
        elif nodeName_ == 'staccato':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.staccato.append(obj_)
            obj_.original_tagname_ = 'staccato'
        elif nodeName_ == 'tenuto':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tenuto.append(obj_)
            obj_.original_tagname_ = 'tenuto'
        elif nodeName_ == 'detached-legato':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detached_legato.append(obj_)
            obj_.original_tagname_ = 'detached-legato'
        elif nodeName_ == 'staccatissimo':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.staccatissimo.append(obj_)
            obj_.original_tagname_ = 'staccatissimo'
        elif nodeName_ == 'spiccato':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spiccato.append(obj_)
            obj_.original_tagname_ = 'spiccato'
        elif nodeName_ == 'scoop':
            obj_ = empty_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scoop.append(obj_)
            obj_.original_tagname_ = 'scoop'
        elif nodeName_ == 'plop':
            obj_ = empty_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.plop.append(obj_)
            obj_.original_tagname_ = 'plop'
        elif nodeName_ == 'doit':
            obj_ = empty_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.doit.append(obj_)
            obj_.original_tagname_ = 'doit'
        elif nodeName_ == 'falloff':
            obj_ = empty_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.falloff.append(obj_)
            obj_.original_tagname_ = 'falloff'
        elif nodeName_ == 'breath-mark':
            obj_ = breath_mark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.breath_mark.append(obj_)
            obj_.original_tagname_ = 'breath-mark'
        elif nodeName_ == 'caesura':
            obj_ = caesura.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caesura.append(obj_)
            obj_.original_tagname_ = 'caesura'
        elif nodeName_ == 'stress':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stress.append(obj_)
            obj_.original_tagname_ = 'stress'
        elif nodeName_ == 'unstress':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unstress.append(obj_)
            obj_.original_tagname_ = 'unstress'
        elif nodeName_ == 'soft-accent':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.soft_accent.append(obj_)
            obj_.original_tagname_ = 'soft-accent'
        elif nodeName_ == 'other-articulation':
            obj_ = other_placement_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_articulation.append(obj_)
            obj_.original_tagname_ = 'other-articulation'
# end class articulations


class arrow(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, smufl=None, arrow_direction=None, arrow_style=None, arrowhead=None, circular_arrow=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.arrow_direction = arrow_direction
        self.validate_arrow_direction(self.arrow_direction)
        self.arrow_direction_nsprefix_ = None
        self.arrow_style = arrow_style
        self.validate_arrow_style(self.arrow_style)
        self.arrow_style_nsprefix_ = None
        self.arrowhead = arrowhead
        self.arrowhead_nsprefix_ = None
        self.circular_arrow = circular_arrow
        self.validate_circular_arrow(self.circular_arrow)
        self.circular_arrow_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, arrow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if arrow.subclass:
            return arrow.subclass(*args_, **kwargs_)
        else:
            return arrow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_arrow_direction(self):
        return self.arrow_direction
    def set_arrow_direction(self, arrow_direction):
        self.arrow_direction = arrow_direction
    def get_arrow_style(self):
        return self.arrow_style
    def set_arrow_style(self, arrow_style):
        self.arrow_style = arrow_style
    def get_arrowhead(self):
        return self.arrowhead
    def set_arrowhead(self, arrowhead):
        self.arrowhead = arrowhead
    def get_circular_arrow(self):
        return self.circular_arrow
    def set_circular_arrow(self, circular_arrow):
        self.circular_arrow = circular_arrow
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def validate_arrow_direction(self, value):
        result = True
        # Validate type arrow-direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'up', 'right', 'down', 'northwest', 'northeast', 'southeast', 'southwest', 'left right', 'up down', 'northwest southeast', 'northeast southwest', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on arrow-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_arrow_style(self, value):
        result = True
        # Validate type arrow-style, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['single', 'double', 'filled', 'hollow', 'paired', 'combined', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on arrow-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_circular_arrow(self, value):
        result = True
        # Validate type circular-arrow, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['clockwise', 'anticlockwise']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on circular-arrow' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_smufl_glyph_name(self, value):
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.arrow_direction is not None or
            self.arrow_style is not None or
            self.arrowhead is not None or
            self.circular_arrow is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='arrow', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('arrow')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'arrow':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='arrow')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='arrow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='arrow'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smufl), input_name='smufl')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='arrow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.arrow_direction is not None:
            namespaceprefix_ = self.arrow_direction_nsprefix_ + ':' if (UseCapturedNS_ and self.arrow_direction_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarrow-direction>%s</%sarrow-direction>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.arrow_direction), input_name='arrow-direction')), namespaceprefix_ , eol_))
        if self.arrow_style is not None:
            namespaceprefix_ = self.arrow_style_nsprefix_ + ':' if (UseCapturedNS_ and self.arrow_style_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarrow-style>%s</%sarrow-style>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.arrow_style), input_name='arrow-style')), namespaceprefix_ , eol_))
        if self.arrowhead is not None:
            namespaceprefix_ = self.arrowhead_nsprefix_ + ':' if (UseCapturedNS_ and self.arrowhead_nsprefix_) else ''
            self.arrowhead.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arrowhead', pretty_print=pretty_print)
        if self.circular_arrow is not None:
            namespaceprefix_ = self.circular_arrow_nsprefix_ + ':' if (UseCapturedNS_ and self.circular_arrow_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scircular-arrow>%s</%scircular-arrow>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.circular_arrow), input_name='circular-arrow')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_glyph_name(self.smufl)    # validate type smufl-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'arrow-direction':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'arrow_direction')
            value_ = self.gds_validate_string(value_, node, 'arrow_direction')
            self.arrow_direction = value_
            self.arrow_direction_nsprefix_ = child_.prefix
            # validate type arrow-direction
            self.validate_arrow_direction(self.arrow_direction)
        elif nodeName_ == 'arrow-style':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'arrow_style')
            value_ = self.gds_validate_string(value_, node, 'arrow_style')
            self.arrow_style = value_
            self.arrow_style_nsprefix_ = child_.prefix
            # validate type arrow-style
            self.validate_arrow_style(self.arrow_style)
        elif nodeName_ == 'arrowhead':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrowhead = obj_
            obj_.original_tagname_ = 'arrowhead'
        elif nodeName_ == 'circular-arrow':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'circular_arrow')
            value_ = self.gds_validate_string(value_, node, 'circular_arrow')
            self.circular_arrow = value_
            self.circular_arrow_nsprefix_ = child_.prefix
            # validate type circular-arrow
            self.validate_circular_arrow(self.circular_arrow)
# end class arrow


class assess(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, player=None, time_only=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.player = _cast(None, player)
        self.player_nsprefix_ = None
        self.time_only = _cast(None, time_only)
        self.time_only_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, assess)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if assess.subclass:
            return assess.subclass(*args_, **kwargs_)
        else:
            return assess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_player(self):
        return self.player
    def set_player(self, player):
        self.player = player
    def get_time_only(self):
        return self.time_only
    def set_time_only(self, time_only):
        self.time_only = time_only
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_time_only(self, value):
        # Validate type time-only, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_time_only_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_time_only_patterns_, ))
    validate_time_only_patterns_ = [['^([1-9][0-9]*(, ?[1-9][0-9]*)*)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='assess', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('assess')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'assess':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='assess')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='assess', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='assess'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.player is not None and 'player' not in already_processed:
            already_processed.add('player')
            outfile.write(' player=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.player), input_name='player')), ))
        if self.time_only is not None and 'time_only' not in already_processed:
            already_processed.add('time_only')
            outfile.write(' time-only=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time_only), input_name='time-only')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='assess', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_yes_no(self.type_)    # validate type yes-no
        value = find_attr_value_('player', node)
        if value is not None and 'player' not in already_processed:
            already_processed.add('player')
            self.player = value
        value = find_attr_value_('time-only', node)
        if value is not None and 'time-only' not in already_processed:
            already_processed.add('time-only')
            self.time_only = value
            self.time_only = ' '.join(self.time_only.split())
            self.validate_time_only(self.time_only)    # validate type time-only
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class assess


class backup(GeneratedsSuper):
    """duration -- Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should be represented using the note element's attack and release attributes.
    The duration element moves the musical position when used in backup elements, forward elements, and note elements that do not contain a chord child element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, duration=None, footnote=None, level=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.duration = duration
        self.validate_positive_divisions(self.duration)
        self.duration_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, backup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if backup.subclass:
            return backup.subclass(*args_, **kwargs_)
        else:
            return backup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def validate_positive_divisions(self, value):
        result = True
        # Validate type positive-divisions, a restriction on divisions.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on positive-divisions' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.duration is not None or
            self.footnote is not None or
            self.level is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='backup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('backup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'backup':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='backup')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='backup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='backup'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='backup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.duration is not None:
            namespaceprefix_ = self.duration_nsprefix_ + ':' if (UseCapturedNS_ and self.duration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespaceprefix_ , self.gds_format_decimal(self.duration, input_name='duration'), namespaceprefix_ , eol_))
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'duration' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'duration')
            fval_ = self.gds_validate_decimal(fval_, node, 'duration')
            self.duration = fval_
            self.duration_nsprefix_ = child_.prefix
            # validate type positive-divisions
            self.validate_positive_divisions(self.duration)
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
# end class backup


class beam(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number='1', repeater=None, fan=None, color=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.repeater = _cast(None, repeater)
        self.repeater_nsprefix_ = None
        self.fan = _cast(None, fan)
        self.fan_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, beam)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if beam.subclass:
            return beam.subclass(*args_, **kwargs_)
        else:
            return beam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_repeater(self):
        return self.repeater
    def set_repeater(self, repeater):
        self.repeater = repeater
    def get_fan(self):
        return self.fan
    def set_fan(self, fan):
        self.fan = fan
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_beam_value(self, value):
        result = True
        # Validate type beam-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['begin', 'continue', 'end', 'forward hook', 'backward hook']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on beam-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_beam_level(self, value):
        # Validate type beam-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on beam-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on beam-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_fan(self, value):
        # Validate type fan, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['accel', 'rit', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on fan' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='beam', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('beam')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'beam':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='beam')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='beam', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='beam'):
        if self.number != 1 and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.repeater is not None and 'repeater' not in already_processed:
            already_processed.add('repeater')
            outfile.write(' repeater=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.repeater), input_name='repeater')), ))
        if self.fan is not None and 'fan' not in already_processed:
            already_processed.add('fan')
            outfile.write(' fan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fan), input_name='fan')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='beam', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_beam_level(self.number)    # validate type beam-level
        value = find_attr_value_('repeater', node)
        if value is not None and 'repeater' not in already_processed:
            already_processed.add('repeater')
            self.repeater = value
            self.repeater = ' '.join(self.repeater.split())
            self.validate_yes_no(self.repeater)    # validate type yes-no
        value = find_attr_value_('fan', node)
        if value is not None and 'fan' not in already_processed:
            already_processed.add('fan')
            self.fan = value
            self.fan = ' '.join(self.fan.split())
            self.validate_fan(self.fan)    # validate type fan
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class beam


class bend(GeneratedsSuper):
    """bend-alter -- The bend-alter element indicates the number of semitones in the bend, similar to the alter element. As with the alter element, numbers like 0.5 can be used to indicate microtones. Negative values indicate pre-bends or releases. The pre-bend and release elements are used to distinguish what is intended. Because the bend-alter element represents the number of steps in the bend, a release after a bend has a negative bend-alter value, not a zero value.
    pre-bend -- The pre-bend element indicates that a bend is a pre-bend rather than a normal bend or a release.
    with-bar -- The with-bar element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The content of the element indicates how this should be notated. Content values of "scoop" and "dip" refer to the SMuFL guitarVibratoBarScoop and guitarVibratoBarDip glyphs.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, shape=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, accelerate=None, beats=None, first_beat=None, last_beat=None, bend_alter=None, pre_bend=None, release=None, with_bar=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.shape = _cast(None, shape)
        self.shape_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.accelerate = _cast(None, accelerate)
        self.accelerate_nsprefix_ = None
        self.beats = _cast(float, beats)
        self.beats_nsprefix_ = None
        self.first_beat = _cast(float, first_beat)
        self.first_beat_nsprefix_ = None
        self.last_beat = _cast(float, last_beat)
        self.last_beat_nsprefix_ = None
        self.bend_alter = bend_alter
        self.validate_semitones(self.bend_alter)
        self.bend_alter_nsprefix_ = None
        self.pre_bend = pre_bend
        self.pre_bend_nsprefix_ = None
        self.release = release
        self.release_nsprefix_ = None
        self.with_bar = with_bar
        self.with_bar_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bend)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bend.subclass:
            return bend.subclass(*args_, **kwargs_)
        else:
            return bend(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_bend_alter(self):
        return self.bend_alter
    def set_bend_alter(self, bend_alter):
        self.bend_alter = bend_alter
    def get_pre_bend(self):
        return self.pre_bend
    def set_pre_bend(self, pre_bend):
        self.pre_bend = pre_bend
    def get_release(self):
        return self.release
    def set_release(self, release):
        self.release = release
    def get_with_bar(self):
        return self.with_bar
    def set_with_bar(self, with_bar):
        self.with_bar = with_bar
    def get_shape(self):
        return self.shape
    def set_shape(self, shape):
        self.shape = shape
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_accelerate(self):
        return self.accelerate
    def set_accelerate(self, accelerate):
        self.accelerate = accelerate
    def get_beats(self):
        return self.beats
    def set_beats(self, beats):
        self.beats = beats
    def get_first_beat(self):
        return self.first_beat
    def set_first_beat(self, first_beat):
        self.first_beat = first_beat
    def get_last_beat(self):
        return self.last_beat
    def set_last_beat(self, last_beat):
        self.last_beat = last_beat
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_bend_shape(self, value):
        # Validate type bend-shape, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['angled', 'curved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on bend-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_trill_beats(self, value):
        # Validate type trill-beats, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on trill-beats' % {"value": value, "lineno": lineno} )
                result = False
    def validate_percent(self, value):
        # Validate type percent, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.bend_alter is not None or
            self.pre_bend is not None or
            self.release is not None or
            self.with_bar is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bend', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bend')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bend':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bend')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bend', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bend'):
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.add('shape')
            outfile.write(' shape=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shape), input_name='shape')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.accelerate is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            outfile.write(' accelerate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accelerate), input_name='accelerate')), ))
        if self.beats is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            outfile.write(' beats="%s"' % self.gds_format_decimal(self.beats, input_name='beats'))
        if self.first_beat is not None and 'first_beat' not in already_processed:
            already_processed.add('first_beat')
            outfile.write(' first-beat="%s"' % self.gds_format_decimal(self.first_beat, input_name='first-beat'))
        if self.last_beat is not None and 'last_beat' not in already_processed:
            already_processed.add('last_beat')
            outfile.write(' last-beat="%s"' % self.gds_format_decimal(self.last_beat, input_name='last-beat'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bend', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bend_alter is not None:
            namespaceprefix_ = self.bend_alter_nsprefix_ + ':' if (UseCapturedNS_ and self.bend_alter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbend-alter>%s</%sbend-alter>%s' % (namespaceprefix_ , self.gds_format_decimal(self.bend_alter, input_name='bend-alter'), namespaceprefix_ , eol_))
        if self.pre_bend is not None:
            namespaceprefix_ = self.pre_bend_nsprefix_ + ':' if (UseCapturedNS_ and self.pre_bend_nsprefix_) else ''
            self.pre_bend.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pre-bend', pretty_print=pretty_print)
        if self.release is not None:
            namespaceprefix_ = self.release_nsprefix_ + ':' if (UseCapturedNS_ and self.release_nsprefix_) else ''
            self.release.export(outfile, level, namespaceprefix_, namespacedef_='', name_='release', pretty_print=pretty_print)
        if self.with_bar is not None:
            namespaceprefix_ = self.with_bar_nsprefix_ + ':' if (UseCapturedNS_ and self.with_bar_nsprefix_) else ''
            self.with_bar.export(outfile, level, namespaceprefix_, namespacedef_='', name_='with-bar', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('shape', node)
        if value is not None and 'shape' not in already_processed:
            already_processed.add('shape')
            self.shape = value
            self.validate_bend_shape(self.shape)    # validate type bend-shape
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('accelerate', node)
        if value is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            self.accelerate = value
            self.accelerate = ' '.join(self.accelerate.split())
            self.validate_yes_no(self.accelerate)    # validate type yes-no
        value = find_attr_value_('beats', node)
        if value is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            value = self.gds_parse_decimal(value, node, 'beats')
            self.beats = value
            self.validate_trill_beats(self.beats)    # validate type trill-beats
        value = find_attr_value_('first-beat', node)
        if value is not None and 'first-beat' not in already_processed:
            already_processed.add('first-beat')
            value = self.gds_parse_decimal(value, node, 'first-beat')
            self.first_beat = value
            self.validate_percent(self.first_beat)    # validate type percent
        value = find_attr_value_('last-beat', node)
        if value is not None and 'last-beat' not in already_processed:
            already_processed.add('last-beat')
            value = self.gds_parse_decimal(value, node, 'last-beat')
            self.last_beat = value
            self.validate_percent(self.last_beat)    # validate type percent
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'bend-alter' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'bend_alter')
            fval_ = self.gds_validate_decimal(fval_, node, 'bend_alter')
            self.bend_alter = fval_
            self.bend_alter_nsprefix_ = child_.prefix
            # validate type semitones
            self.validate_semitones(self.bend_alter)
        elif nodeName_ == 'pre-bend':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pre_bend = obj_
            obj_.original_tagname_ = 'pre-bend'
        elif nodeName_ == 'release':
            obj_ = release.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.release = obj_
            obj_.original_tagname_ = 'release'
        elif nodeName_ == 'with-bar':
            obj_ = placement_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.with_bar = obj_
            obj_.original_tagname_ = 'with-bar'
# end class bend


class breath_mark(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, breath_mark)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if breath_mark.subclass:
            return breath_mark.subclass(*args_, **kwargs_)
        else:
            return breath_mark(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_breath_mark_value(self, value):
        result = True
        # Validate type breath-mark-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['', 'comma', 'tick', 'upbow', 'salzedo']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on breath-mark-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='breath-mark', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('breath-mark')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'breath-mark':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='breath-mark')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='breath-mark', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='breath-mark'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='breath-mark', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class breath_mark


class caesura(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, caesura)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if caesura.subclass:
            return caesura.subclass(*args_, **kwargs_)
        else:
            return caesura(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_caesura_value(self, value):
        result = True
        # Validate type caesura-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'thick', 'short', 'curved', 'single', '']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on caesura-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='caesura', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('caesura')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'caesura':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='caesura')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='caesura', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='caesura'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='caesura', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class caesura


class elision(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, elision)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if elision.subclass:
            return elision.subclass(*args_, **kwargs_)
        else:
            return elision(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_smufl_lyrics_glyph_name(self, value):
        # Validate type smufl-lyrics-glyph-name, a restriction on smufl-glyph-name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_smufl_lyrics_glyph_name_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_smufl_lyrics_glyph_name_patterns_, ))
    validate_smufl_lyrics_glyph_name_patterns_ = [['^(lyrics\\c+)$']]
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='elision', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('elision')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'elision':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='elision')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='elision', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='elision'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (quote_attrib(self.smufl), ))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='elision', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_lyrics_glyph_name(self.smufl)    # validate type smufl-lyrics-glyph-name
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class elision


class empty_line(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, line_shape=None, line_type=None, line_length=None, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.line_shape = _cast(None, line_shape)
        self.line_shape_nsprefix_ = None
        self.line_type = _cast(None, line_type)
        self.line_type_nsprefix_ = None
        self.line_length = _cast(None, line_length)
        self.line_length_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_line.subclass:
            return empty_line.subclass(*args_, **kwargs_)
        else:
            return empty_line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_line_shape(self):
        return self.line_shape
    def set_line_shape(self, line_shape):
        self.line_shape = line_shape
    def get_line_type(self):
        return self.line_type
    def set_line_type(self, line_type):
        self.line_type = line_type
    def get_line_length(self):
        return self.line_length
    def set_line_length(self, line_length):
        self.line_length = line_length
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def validate_line_shape(self, value):
        # Validate type line-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['straight', 'curved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_line_type(self, value):
        # Validate type line-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['solid', 'dashed', 'dotted', 'wavy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_line_length(self, value):
        # Validate type line-length, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['short', 'medium', 'long']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-length' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-line', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-line':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-line')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-line', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-line'):
        if self.line_shape is not None and 'line_shape' not in already_processed:
            already_processed.add('line_shape')
            outfile.write(' line-shape=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_shape), input_name='line-shape')), ))
        if self.line_type is not None and 'line_type' not in already_processed:
            already_processed.add('line_type')
            outfile.write(' line-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_type), input_name='line-type')), ))
        if self.line_length is not None and 'line_length' not in already_processed:
            already_processed.add('line_length')
            outfile.write(' line-length=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_length), input_name='line-length')), ))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-line', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('line-shape', node)
        if value is not None and 'line-shape' not in already_processed:
            already_processed.add('line-shape')
            self.line_shape = value
            self.line_shape = ' '.join(self.line_shape.split())
            self.validate_line_shape(self.line_shape)    # validate type line-shape
        value = find_attr_value_('line-type', node)
        if value is not None and 'line-type' not in already_processed:
            already_processed.add('line-type')
            self.line_type = value
            self.line_type = ' '.join(self.line_type.split())
            self.validate_line_type(self.line_type)    # validate type line-type
        value = find_attr_value_('line-length', node)
        if value is not None and 'line-length' not in already_processed:
            already_processed.add('line-length')
            self.line_length = value
            self.line_length = ' '.join(self.line_length.split())
            self.validate_line_length(self.line_length)    # validate type line-length
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_line


class extend(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, default_x=None, default_y=None, relative_x=None, relative_y=None, color=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extend)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extend.subclass:
            return extend.subclass(*args_, **kwargs_)
        else:
            return extend(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def validate_start_stop_continue(self, value):
        # Validate type start-stop-continue, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'continue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-continue' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='extend', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extend')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extend':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extend')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extend', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extend'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='extend', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_continue(self.type_)    # validate type start-stop-continue
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class extend


class figure(GeneratedsSuper):
    """prefix -- Values for the prefix element include plus and the accidental values sharp, flat, natural, double-sharp, flat-flat, and sharp-sharp. The prefix element may contain additional values for symbols specific to particular figured bass styles.
    figure-number -- A figure-number is a number. Overstrikes of the figure number are represented in the suffix element.
    suffix -- Values for the suffix element include plus and the accidental values sharp, flat, natural, double-sharp, flat-flat, and sharp-sharp. Suffixes include both symbols that come after the figure number and those that overstrike the figure number. The suffix values slash, back-slash, and vertical are used for slashed numbers indicating chromatic alteration. The orientation and display of the slash usually depends on the figure number. The suffix element may contain additional values for symbols specific to particular figured bass styles.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, prefix=None, figure_number=None, suffix=None, extend=None, footnote=None, level=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.prefix = prefix
        self.prefix_nsprefix_ = None
        self.figure_number = figure_number
        self.figure_number_nsprefix_ = None
        self.suffix = suffix
        self.suffix_nsprefix_ = None
        self.extend = extend
        self.extend_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, figure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if figure.subclass:
            return figure.subclass(*args_, **kwargs_)
        else:
            return figure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def get_figure_number(self):
        return self.figure_number
    def set_figure_number(self, figure_number):
        self.figure_number = figure_number
    def get_suffix(self):
        return self.suffix
    def set_suffix(self, suffix):
        self.suffix = suffix
    def get_extend(self):
        return self.extend
    def set_extend(self, extend):
        self.extend = extend
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def _hasContent(self):
        if (
            self.prefix is not None or
            self.figure_number is not None or
            self.suffix is not None or
            self.extend is not None or
            self.footnote is not None or
            self.level is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='figure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('figure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'figure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='figure')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='figure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='figure'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='figure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prefix is not None:
            namespaceprefix_ = self.prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.prefix_nsprefix_) else ''
            self.prefix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prefix', pretty_print=pretty_print)
        if self.figure_number is not None:
            namespaceprefix_ = self.figure_number_nsprefix_ + ':' if (UseCapturedNS_ and self.figure_number_nsprefix_) else ''
            self.figure_number.export(outfile, level, namespaceprefix_, namespacedef_='', name_='figure-number', pretty_print=pretty_print)
        if self.suffix is not None:
            namespaceprefix_ = self.suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.suffix_nsprefix_) else ''
            self.suffix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='suffix', pretty_print=pretty_print)
        if self.extend is not None:
            namespaceprefix_ = self.extend_nsprefix_ + ':' if (UseCapturedNS_ and self.extend_nsprefix_) else ''
            self.extend.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extend', pretty_print=pretty_print)
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'prefix':
            obj_ = style_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.prefix = obj_
            obj_.original_tagname_ = 'prefix'
        elif nodeName_ == 'figure-number':
            obj_ = style_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.figure_number = obj_
            obj_.original_tagname_ = 'figure-number'
        elif nodeName_ == 'suffix':
            obj_ = style_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.suffix = obj_
            obj_.original_tagname_ = 'suffix'
        elif nodeName_ == 'extend':
            obj_ = extend.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extend = obj_
            obj_.original_tagname_ = 'extend'
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
# end class figure


class figured_bass(GeneratedsSuper):
    """duration -- Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should be represented using the note element's attack and release attributes.
    The duration element moves the musical position when used in backup elements, forward elements, and note elements that do not contain a chord child element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, parentheses=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, halign=None, valign=None, placement=None, print_object=None, print_dot=None, print_spacing=None, print_lyric=None, id=None, figure=None, duration=None, footnote=None, level=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.parentheses = _cast(None, parentheses)
        self.parentheses_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.halign = _cast(None, halign)
        self.halign_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.print_dot = _cast(None, print_dot)
        self.print_dot_nsprefix_ = None
        self.print_spacing = _cast(None, print_spacing)
        self.print_spacing_nsprefix_ = None
        self.print_lyric = _cast(None, print_lyric)
        self.print_lyric_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if figure is None:
            self.figure = []
        else:
            self.figure = figure
        self.figure_nsprefix_ = None
        self.duration = duration
        self.validate_positive_divisions(self.duration)
        self.duration_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, figured_bass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if figured_bass.subclass:
            return figured_bass.subclass(*args_, **kwargs_)
        else:
            return figured_bass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_figure(self):
        return self.figure
    def set_figure(self, figure):
        self.figure = figure
    def add_figure(self, value):
        self.figure.append(value)
    def insert_figure_at(self, index, value):
        self.figure.insert(index, value)
    def replace_figure_at(self, index, value):
        self.figure[index] = value
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_parentheses(self):
        return self.parentheses
    def set_parentheses(self, parentheses):
        self.parentheses = parentheses
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_halign(self):
        return self.halign
    def set_halign(self, halign):
        self.halign = halign
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_print_dot(self):
        return self.print_dot
    def set_print_dot(self, print_dot):
        self.print_dot = print_dot
    def get_print_spacing(self):
        return self.print_spacing
    def set_print_spacing(self, print_spacing):
        self.print_spacing = print_spacing
    def get_print_lyric(self):
        return self.print_lyric
    def set_print_lyric(self, print_lyric):
        self.print_lyric = print_lyric
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_positive_divisions(self, value):
        result = True
        # Validate type positive-divisions, a restriction on divisions.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on positive-divisions' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valign(self, value):
        # Validate type valign, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.figure or
            self.duration is not None or
            self.footnote is not None or
            self.level is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='figured-bass', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('figured-bass')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'figured-bass':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='figured-bass')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='figured-bass', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='figured-bass'):
        if self.parentheses is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            outfile.write(' parentheses=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentheses), input_name='parentheses')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.halign is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            outfile.write(' halign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.halign), input_name='halign')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.print_dot is not None and 'print_dot' not in already_processed:
            already_processed.add('print_dot')
            outfile.write(' print-dot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_dot), input_name='print-dot')), ))
        if self.print_spacing is not None and 'print_spacing' not in already_processed:
            already_processed.add('print_spacing')
            outfile.write(' print-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_spacing), input_name='print-spacing')), ))
        if self.print_lyric is not None and 'print_lyric' not in already_processed:
            already_processed.add('print_lyric')
            outfile.write(' print-lyric=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_lyric), input_name='print-lyric')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='figured-bass', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for figure_ in self.figure:
            namespaceprefix_ = self.figure_nsprefix_ + ':' if (UseCapturedNS_ and self.figure_nsprefix_) else ''
            figure_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='figure', pretty_print=pretty_print)
        if self.duration is not None:
            namespaceprefix_ = self.duration_nsprefix_ + ':' if (UseCapturedNS_ and self.duration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespaceprefix_ , self.gds_format_decimal(self.duration, input_name='duration'), namespaceprefix_ , eol_))
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parentheses', node)
        if value is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            self.parentheses = value
            self.parentheses = ' '.join(self.parentheses.split())
            self.validate_yes_no(self.parentheses)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('halign', node)
        if value is not None and 'halign' not in already_processed:
            already_processed.add('halign')
            self.halign = value
            self.halign = ' '.join(self.halign.split())
            self.validate_left_center_right(self.halign)    # validate type left-center-right
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.valign = ' '.join(self.valign.split())
            self.validate_valign(self.valign)    # validate type valign
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('print-dot', node)
        if value is not None and 'print-dot' not in already_processed:
            already_processed.add('print-dot')
            self.print_dot = value
            self.print_dot = ' '.join(self.print_dot.split())
            self.validate_yes_no(self.print_dot)    # validate type yes-no
        value = find_attr_value_('print-spacing', node)
        if value is not None and 'print-spacing' not in already_processed:
            already_processed.add('print-spacing')
            self.print_spacing = value
            self.print_spacing = ' '.join(self.print_spacing.split())
            self.validate_yes_no(self.print_spacing)    # validate type yes-no
        value = find_attr_value_('print-lyric', node)
        if value is not None and 'print-lyric' not in already_processed:
            already_processed.add('print-lyric')
            self.print_lyric = value
            self.print_lyric = ' '.join(self.print_lyric.split())
            self.validate_yes_no(self.print_lyric)    # validate type yes-no
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'figure':
            obj_ = figure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.figure.append(obj_)
            obj_.original_tagname_ = 'figure'
        elif nodeName_ == 'duration' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'duration')
            fval_ = self.gds_validate_decimal(fval_, node, 'duration')
            self.duration = fval_
            self.duration_nsprefix_ = child_.prefix
            # validate type positive-divisions
            self.validate_positive_divisions(self.duration)
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
# end class figured_bass


class forward(GeneratedsSuper):
    """duration -- Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should be represented using the note element's attack and release attributes.
    The duration element moves the musical position when used in backup elements, forward elements, and note elements that do not contain a chord child element.
    staff -- Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, duration=None, footnote=None, level=None, voice=None, staff=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.duration = duration
        self.validate_positive_divisions(self.duration)
        self.duration_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
        self.voice = voice
        self.voice_nsprefix_ = None
        self.staff = staff
        self.staff_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, forward)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if forward.subclass:
            return forward.subclass(*args_, **kwargs_)
        else:
            return forward(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_voice(self):
        return self.voice
    def set_voice(self, voice):
        self.voice = voice
    def get_staff(self):
        return self.staff
    def set_staff(self, staff):
        self.staff = staff
    def validate_positive_divisions(self, value):
        result = True
        # Validate type positive-divisions, a restriction on divisions.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on positive-divisions' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.duration is not None or
            self.footnote is not None or
            self.level is not None or
            self.voice is not None or
            self.staff is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='forward', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('forward')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'forward':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='forward')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='forward', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='forward'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='forward', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.duration is not None:
            namespaceprefix_ = self.duration_nsprefix_ + ':' if (UseCapturedNS_ and self.duration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespaceprefix_ , self.gds_format_decimal(self.duration, input_name='duration'), namespaceprefix_ , eol_))
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
        if self.voice is not None:
            namespaceprefix_ = self.voice_nsprefix_ + ':' if (UseCapturedNS_ and self.voice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svoice>%s</%svoice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.voice), input_name='voice')), namespaceprefix_ , eol_))
        if self.staff is not None:
            namespaceprefix_ = self.staff_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaff>%s</%sstaff>%s' % (namespaceprefix_ , self.gds_format_integer(self.staff, input_name='staff'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'duration' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'duration')
            fval_ = self.gds_validate_decimal(fval_, node, 'duration')
            self.duration = fval_
            self.duration_nsprefix_ = child_.prefix
            # validate type positive-divisions
            self.validate_positive_divisions(self.duration)
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
        elif nodeName_ == 'voice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'voice')
            value_ = self.gds_validate_string(value_, node, 'voice')
            self.voice = value_
            self.voice_nsprefix_ = child_.prefix
        elif nodeName_ == 'staff' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'staff')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'staff')
            self.staff = ival_
            self.staff_nsprefix_ = child_.prefix
# end class forward


class glissando(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number='1', line_type=None, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.line_type = _cast(None, line_type)
        self.line_type_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, glissando)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if glissando.subclass:
            return glissando.subclass(*args_, **kwargs_)
        else:
            return glissando(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_line_type(self):
        return self.line_type
    def set_line_type(self, line_type):
        self.line_type = line_type
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_line_type(self, value):
        # Validate type line-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['solid', 'dashed', 'dotted', 'wavy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='glissando', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('glissando')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'glissando':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='glissando')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='glissando', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='glissando'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number != 1 and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.line_type is not None and 'line_type' not in already_processed:
            already_processed.add('line_type')
            outfile.write(' line-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_type), input_name='line-type')), ))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='glissando', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('line-type', node)
        if value is not None and 'line-type' not in already_processed:
            already_processed.add('line-type')
            self.line_type = value
            self.line_type = ' '.join(self.line_type.split())
            self.validate_line_type(self.line_type)    # validate type line-type
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class glissando


class grace(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, steal_time_previous=None, steal_time_following=None, make_time=None, slash=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.steal_time_previous = _cast(float, steal_time_previous)
        self.steal_time_previous_nsprefix_ = None
        self.steal_time_following = _cast(float, steal_time_following)
        self.steal_time_following_nsprefix_ = None
        self.make_time = _cast(float, make_time)
        self.make_time_nsprefix_ = None
        self.slash = _cast(None, slash)
        self.slash_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, grace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if grace.subclass:
            return grace.subclass(*args_, **kwargs_)
        else:
            return grace(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_steal_time_previous(self):
        return self.steal_time_previous
    def set_steal_time_previous(self, steal_time_previous):
        self.steal_time_previous = steal_time_previous
    def get_steal_time_following(self):
        return self.steal_time_following
    def set_steal_time_following(self, steal_time_following):
        self.steal_time_following = steal_time_following
    def get_make_time(self):
        return self.make_time
    def set_make_time(self, make_time):
        self.make_time = make_time
    def get_slash(self):
        return self.slash
    def set_slash(self, slash):
        self.slash = slash
    def validate_percent(self, value):
        # Validate type percent, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='grace', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('grace')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'grace':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='grace')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='grace', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='grace'):
        if self.steal_time_previous is not None and 'steal_time_previous' not in already_processed:
            already_processed.add('steal_time_previous')
            outfile.write(' steal-time-previous="%s"' % self.gds_format_decimal(self.steal_time_previous, input_name='steal-time-previous'))
        if self.steal_time_following is not None and 'steal_time_following' not in already_processed:
            already_processed.add('steal_time_following')
            outfile.write(' steal-time-following="%s"' % self.gds_format_decimal(self.steal_time_following, input_name='steal-time-following'))
        if self.make_time is not None and 'make_time' not in already_processed:
            already_processed.add('make_time')
            outfile.write(' make-time="%s"' % self.gds_format_decimal(self.make_time, input_name='make-time'))
        if self.slash is not None and 'slash' not in already_processed:
            already_processed.add('slash')
            outfile.write(' slash=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.slash), input_name='slash')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='grace', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('steal-time-previous', node)
        if value is not None and 'steal-time-previous' not in already_processed:
            already_processed.add('steal-time-previous')
            value = self.gds_parse_decimal(value, node, 'steal-time-previous')
            self.steal_time_previous = value
            self.validate_percent(self.steal_time_previous)    # validate type percent
        value = find_attr_value_('steal-time-following', node)
        if value is not None and 'steal-time-following' not in already_processed:
            already_processed.add('steal-time-following')
            value = self.gds_parse_decimal(value, node, 'steal-time-following')
            self.steal_time_following = value
            self.validate_percent(self.steal_time_following)    # validate type percent
        value = find_attr_value_('make-time', node)
        if value is not None and 'make-time' not in already_processed:
            already_processed.add('make-time')
            value = self.gds_parse_decimal(value, node, 'make-time')
            self.make_time = value
        value = find_attr_value_('slash', node)
        if value is not None and 'slash' not in already_processed:
            already_processed.add('slash')
            self.slash = value
            self.slash = ' '.join(self.slash.split())
            self.validate_yes_no(self.slash)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class grace


class hammer_on_pull_off(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number='1', default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hammer_on_pull_off)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hammer_on_pull_off.subclass:
            return hammer_on_pull_off.subclass(*args_, **kwargs_)
        else:
            return hammer_on_pull_off(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hammer-on-pull-off', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hammer-on-pull-off')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'hammer-on-pull-off':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hammer-on-pull-off')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='hammer-on-pull-off', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hammer-on-pull-off'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number != 1 and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hammer-on-pull-off', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class hammer_on_pull_off


class handbell(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, handbell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if handbell.subclass:
            return handbell.subclass(*args_, **kwargs_)
        else:
            return handbell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_handbell_value(self, value):
        result = True
        # Validate type handbell-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['belltree', 'damp', 'echo', 'gyro', 'hand martellato', 'mallet lift', 'mallet table', 'martellato', 'martellato lift', 'muted martellato', 'pluck lift', 'swing']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on handbell-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='handbell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('handbell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'handbell':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='handbell')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='handbell', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='handbell'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='handbell', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class handbell


class harmon_closed(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, location=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.location = _cast(None, location)
        self.location_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, harmon_closed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if harmon_closed.subclass:
            return harmon_closed.subclass(*args_, **kwargs_)
        else:
            return harmon_closed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_harmon_closed_value(self, value):
        result = True
        # Validate type harmon-closed-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no', 'half']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on harmon-closed-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_harmon_closed_location(self, value):
        # Validate type harmon-closed-location, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['right', 'bottom', 'left', 'top']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on harmon-closed-location' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmon-closed', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('harmon-closed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'harmon-closed':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='harmon-closed')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='harmon-closed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='harmon-closed'):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.location), input_name='location')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmon-closed', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
            self.validate_harmon_closed_location(self.location)    # validate type harmon-closed-location
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class harmon_closed


class harmon_mute(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, harmon_closed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.harmon_closed = harmon_closed
        self.harmon_closed_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, harmon_mute)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if harmon_mute.subclass:
            return harmon_mute.subclass(*args_, **kwargs_)
        else:
            return harmon_mute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_harmon_closed(self):
        return self.harmon_closed
    def set_harmon_closed(self, harmon_closed):
        self.harmon_closed = harmon_closed
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.harmon_closed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmon-mute', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('harmon-mute')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'harmon-mute':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='harmon-mute')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='harmon-mute', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='harmon-mute'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmon-mute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.harmon_closed is not None:
            namespaceprefix_ = self.harmon_closed_nsprefix_ + ':' if (UseCapturedNS_ and self.harmon_closed_nsprefix_) else ''
            self.harmon_closed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='harmon-closed', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'harmon-closed':
            obj_ = harmon_closed.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.harmon_closed = obj_
            obj_.original_tagname_ = 'harmon-closed'
# end class harmon_mute


class harmonic(GeneratedsSuper):
    """natural -- The natural element indicates that this is a natural harmonic. These are usually notated at base pitch rather than sounding pitch.
    artificial -- The artificial element indicates that this is an artificial harmonic.
    base-pitch -- The base pitch is the pitch at which the string is played before touching to create the harmonic.
    touching-pitch -- The touching-pitch is the pitch at which the string is touched lightly to produce the harmonic.
    sounding-pitch -- The sounding-pitch is the pitch which is heard when playing the harmonic.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, print_object=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, natural=None, artificial=None, base_pitch=None, touching_pitch=None, sounding_pitch=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.natural = natural
        self.natural_nsprefix_ = None
        self.artificial = artificial
        self.artificial_nsprefix_ = None
        self.base_pitch = base_pitch
        self.base_pitch_nsprefix_ = None
        self.touching_pitch = touching_pitch
        self.touching_pitch_nsprefix_ = None
        self.sounding_pitch = sounding_pitch
        self.sounding_pitch_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, harmonic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if harmonic.subclass:
            return harmonic.subclass(*args_, **kwargs_)
        else:
            return harmonic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_natural(self):
        return self.natural
    def set_natural(self, natural):
        self.natural = natural
    def get_artificial(self):
        return self.artificial
    def set_artificial(self, artificial):
        self.artificial = artificial
    def get_base_pitch(self):
        return self.base_pitch
    def set_base_pitch(self, base_pitch):
        self.base_pitch = base_pitch
    def get_touching_pitch(self):
        return self.touching_pitch
    def set_touching_pitch(self, touching_pitch):
        self.touching_pitch = touching_pitch
    def get_sounding_pitch(self):
        return self.sounding_pitch
    def set_sounding_pitch(self, sounding_pitch):
        self.sounding_pitch = sounding_pitch
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.natural is not None or
            self.artificial is not None or
            self.base_pitch is not None or
            self.touching_pitch is not None or
            self.sounding_pitch is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmonic', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('harmonic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'harmonic':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='harmonic')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='harmonic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='harmonic'):
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='harmonic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.natural is not None:
            namespaceprefix_ = self.natural_nsprefix_ + ':' if (UseCapturedNS_ and self.natural_nsprefix_) else ''
            self.natural.export(outfile, level, namespaceprefix_, namespacedef_='', name_='natural', pretty_print=pretty_print)
        if self.artificial is not None:
            namespaceprefix_ = self.artificial_nsprefix_ + ':' if (UseCapturedNS_ and self.artificial_nsprefix_) else ''
            self.artificial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artificial', pretty_print=pretty_print)
        if self.base_pitch is not None:
            namespaceprefix_ = self.base_pitch_nsprefix_ + ':' if (UseCapturedNS_ and self.base_pitch_nsprefix_) else ''
            self.base_pitch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='base-pitch', pretty_print=pretty_print)
        if self.touching_pitch is not None:
            namespaceprefix_ = self.touching_pitch_nsprefix_ + ':' if (UseCapturedNS_ and self.touching_pitch_nsprefix_) else ''
            self.touching_pitch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='touching-pitch', pretty_print=pretty_print)
        if self.sounding_pitch is not None:
            namespaceprefix_ = self.sounding_pitch_nsprefix_ + ':' if (UseCapturedNS_ and self.sounding_pitch_nsprefix_) else ''
            self.sounding_pitch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sounding-pitch', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'natural':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.natural = obj_
            obj_.original_tagname_ = 'natural'
        elif nodeName_ == 'artificial':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artificial = obj_
            obj_.original_tagname_ = 'artificial'
        elif nodeName_ == 'base-pitch':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.base_pitch = obj_
            obj_.original_tagname_ = 'base-pitch'
        elif nodeName_ == 'touching-pitch':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.touching_pitch = obj_
            obj_.original_tagname_ = 'touching-pitch'
        elif nodeName_ == 'sounding-pitch':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sounding_pitch = obj_
            obj_.original_tagname_ = 'sounding-pitch'
# end class harmonic


class heel_toe(empty_placement):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = empty_placement
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, substitution=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("heel_toe"), self).__init__(default_x, default_y, relative_x, relative_y, font_family, font_style, font_size, font_weight, color, placement,  **kwargs_)
        self.substitution = _cast(None, substitution)
        self.substitution_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, heel_toe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if heel_toe.subclass:
            return heel_toe.subclass(*args_, **kwargs_)
        else:
            return heel_toe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_substitution(self):
        return self.substitution
    def set_substitution(self, substitution):
        self.substitution = substitution
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            super(heel_toe, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='heel-toe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('heel-toe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'heel-toe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='heel-toe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='heel-toe', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='heel-toe'):
        super(heel_toe, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='heel-toe')
        if self.substitution is not None and 'substitution' not in already_processed:
            already_processed.add('substitution')
            outfile.write(' substitution=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.substitution), input_name='substitution')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='heel-toe', fromsubclass_=False, pretty_print=True):
        super(heel_toe, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('substitution', node)
        if value is not None and 'substitution' not in already_processed:
            already_processed.add('substitution')
            self.substitution = value
            self.substitution = ' '.join(self.substitution.split())
            self.validate_yes_no(self.substitution)    # validate type yes-no
        super(heel_toe, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(heel_toe, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class heel_toe


class hole(GeneratedsSuper):
    """hole-type -- The content of the optional hole-type element indicates what the hole symbol represents in terms of instrument fingering or other techniques.
    hole-shape -- The optional hole-shape element indicates the shape of the hole symbol; the default is a circle.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, hole_type=None, hole_closed=None, hole_shape=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.hole_type = hole_type
        self.hole_type_nsprefix_ = None
        self.hole_closed = hole_closed
        self.hole_closed_nsprefix_ = None
        self.hole_shape = hole_shape
        self.hole_shape_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hole.subclass:
            return hole.subclass(*args_, **kwargs_)
        else:
            return hole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_hole_type(self):
        return self.hole_type
    def set_hole_type(self, hole_type):
        self.hole_type = hole_type
    def get_hole_closed(self):
        return self.hole_closed
    def set_hole_closed(self, hole_closed):
        self.hole_closed = hole_closed
    def get_hole_shape(self):
        return self.hole_shape
    def set_hole_shape(self, hole_shape):
        self.hole_shape = hole_shape
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.hole_type is not None or
            self.hole_closed is not None or
            self.hole_shape is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'hole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hole')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='hole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hole'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hole_type is not None:
            namespaceprefix_ = self.hole_type_nsprefix_ + ':' if (UseCapturedNS_ and self.hole_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shole-type>%s</%shole-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.hole_type), input_name='hole-type')), namespaceprefix_ , eol_))
        if self.hole_closed is not None:
            namespaceprefix_ = self.hole_closed_nsprefix_ + ':' if (UseCapturedNS_ and self.hole_closed_nsprefix_) else ''
            self.hole_closed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hole-closed', pretty_print=pretty_print)
        if self.hole_shape is not None:
            namespaceprefix_ = self.hole_shape_nsprefix_ + ':' if (UseCapturedNS_ and self.hole_shape_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shole-shape>%s</%shole-shape>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.hole_shape), input_name='hole-shape')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'hole-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'hole_type')
            value_ = self.gds_validate_string(value_, node, 'hole_type')
            self.hole_type = value_
            self.hole_type_nsprefix_ = child_.prefix
        elif nodeName_ == 'hole-closed':
            obj_ = hole_closed.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hole_closed = obj_
            obj_.original_tagname_ = 'hole-closed'
        elif nodeName_ == 'hole-shape':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'hole_shape')
            value_ = self.gds_validate_string(value_, node, 'hole_shape')
            self.hole_shape = value_
            self.hole_shape_nsprefix_ = child_.prefix
# end class hole


class hole_closed(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, location=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.location = _cast(None, location)
        self.location_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hole_closed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hole_closed.subclass:
            return hole_closed.subclass(*args_, **kwargs_)
        else:
            return hole_closed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_hole_closed_value(self, value):
        result = True
        # Validate type hole-closed-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no', 'half']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on hole-closed-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_hole_closed_location(self, value):
        # Validate type hole-closed-location, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['right', 'bottom', 'left', 'top']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on hole-closed-location' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hole-closed', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hole-closed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'hole-closed':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hole-closed')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='hole-closed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hole-closed'):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.location), input_name='location')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hole-closed', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
            self.validate_hole_closed_location(self.location)    # validate type hole-closed-location
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class hole_closed


class instrument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instrument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instrument.subclass:
            return instrument.subclass(*args_, **kwargs_)
        else:
            return instrument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='instrument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instrument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instrument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instrument')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instrument', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='instrument'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='instrument', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class instrument


class listen(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, assess=None, wait=None, other_listen=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if assess is None:
            self.assess = []
        else:
            self.assess = assess
        self.assess_nsprefix_ = None
        if wait is None:
            self.wait = []
        else:
            self.wait = wait
        self.wait_nsprefix_ = None
        if other_listen is None:
            self.other_listen = []
        else:
            self.other_listen = other_listen
        self.other_listen_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listen)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listen.subclass:
            return listen.subclass(*args_, **kwargs_)
        else:
            return listen(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_assess(self):
        return self.assess
    def set_assess(self, assess):
        self.assess = assess
    def add_assess(self, value):
        self.assess.append(value)
    def insert_assess_at(self, index, value):
        self.assess.insert(index, value)
    def replace_assess_at(self, index, value):
        self.assess[index] = value
    def get_wait(self):
        return self.wait
    def set_wait(self, wait):
        self.wait = wait
    def add_wait(self, value):
        self.wait.append(value)
    def insert_wait_at(self, index, value):
        self.wait.insert(index, value)
    def replace_wait_at(self, index, value):
        self.wait[index] = value
    def get_other_listen(self):
        return self.other_listen
    def set_other_listen(self, other_listen):
        self.other_listen = other_listen
    def add_other_listen(self, value):
        self.other_listen.append(value)
    def insert_other_listen_at(self, index, value):
        self.other_listen.insert(index, value)
    def replace_other_listen_at(self, index, value):
        self.other_listen[index] = value
    def _hasContent(self):
        if (
            self.assess or
            self.wait or
            self.other_listen
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listen', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listen')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'listen':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listen')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listen', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listen'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listen', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for assess_ in self.assess:
            namespaceprefix_ = self.assess_nsprefix_ + ':' if (UseCapturedNS_ and self.assess_nsprefix_) else ''
            assess_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assess', pretty_print=pretty_print)
        for wait_ in self.wait:
            namespaceprefix_ = self.wait_nsprefix_ + ':' if (UseCapturedNS_ and self.wait_nsprefix_) else ''
            wait_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wait', pretty_print=pretty_print)
        for other_listen_ in self.other_listen:
            namespaceprefix_ = self.other_listen_nsprefix_ + ':' if (UseCapturedNS_ and self.other_listen_nsprefix_) else ''
            other_listen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-listen', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'assess':
            obj_ = assess.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assess.append(obj_)
            obj_.original_tagname_ = 'assess'
        elif nodeName_ == 'wait':
            obj_ = wait.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wait.append(obj_)
            obj_.original_tagname_ = 'wait'
        elif nodeName_ == 'other-listen':
            obj_ = other_listening.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_listen.append(obj_)
            obj_.original_tagname_ = 'other-listen'
# end class listen


class lyric(GeneratedsSuper):
    """laughing -- The laughing element represents a laughing voice.
    humming -- The humming element represents a humming voice.
    end-line -- The end-line element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for Karaoke and similar applications.
    end-paragraph -- The end-paragraph element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for Karaoke and similar applications.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, name=None, time_only=None, justify=None, default_x=None, default_y=None, relative_x=None, relative_y=None, placement=None, color=None, print_object=None, id=None, elision=None, syllabic=None, text=None, extend=None, laughing=None, humming=None, end_line=None, end_paragraph=None, footnote=None, level=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.time_only = _cast(None, time_only)
        self.time_only_nsprefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.elision = elision
        self.elision_nsprefix_ = None
        self.syllabic = syllabic
        self.validate_syllabic(self.syllabic)
        self.syllabic_nsprefix_ = None
        if text is None:
            self.text = []
        else:
            self.text = text
        self.text_nsprefix_ = None
        self.extend = extend
        self.extend_nsprefix_ = None
        self.laughing = laughing
        self.laughing_nsprefix_ = None
        self.humming = humming
        self.humming_nsprefix_ = None
        self.end_line = end_line
        self.end_line_nsprefix_ = None
        self.end_paragraph = end_paragraph
        self.end_paragraph_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lyric)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lyric.subclass:
            return lyric.subclass(*args_, **kwargs_)
        else:
            return lyric(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_elision(self):
        return self.elision
    def set_elision(self, elision):
        self.elision = elision
    def get_syllabic(self):
        return self.syllabic
    def set_syllabic(self, syllabic):
        self.syllabic = syllabic
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def add_text(self, value):
        self.text.append(value)
    def insert_text_at(self, index, value):
        self.text.insert(index, value)
    def replace_text_at(self, index, value):
        self.text[index] = value
    def get_extend(self):
        return self.extend
    def set_extend(self, extend):
        self.extend = extend
    def get_laughing(self):
        return self.laughing
    def set_laughing(self, laughing):
        self.laughing = laughing
    def get_humming(self):
        return self.humming
    def set_humming(self, humming):
        self.humming = humming
    def get_end_line(self):
        return self.end_line
    def set_end_line(self, end_line):
        self.end_line = end_line
    def get_end_paragraph(self):
        return self.end_paragraph
    def set_end_paragraph(self, end_paragraph):
        self.end_paragraph = end_paragraph
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_time_only(self):
        return self.time_only
    def set_time_only(self, time_only):
        self.time_only = time_only
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_syllabic(self, value):
        result = True
        # Validate type syllabic, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['single', 'begin', 'end', 'middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on syllabic' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_time_only(self, value):
        # Validate type time-only, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_time_only_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_time_only_patterns_, ))
    validate_time_only_patterns_ = [['^([1-9][0-9]*(, ?[1-9][0-9]*)*)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.elision is not None or
            self.syllabic is not None or
            self.text or
            self.extend is not None or
            self.laughing is not None or
            self.humming is not None or
            self.end_line is not None or
            self.end_paragraph is not None or
            self.footnote is not None or
            self.level is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lyric', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lyric')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lyric':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lyric')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lyric', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lyric'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.number), input_name='number')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.time_only is not None and 'time_only' not in already_processed:
            already_processed.add('time_only')
            outfile.write(' time-only=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time_only), input_name='time-only')), ))
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lyric', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.elision is not None:
            namespaceprefix_ = self.elision_nsprefix_ + ':' if (UseCapturedNS_ and self.elision_nsprefix_) else ''
            self.elision.export(outfile, level, namespaceprefix_, namespacedef_='', name_='elision', pretty_print=pretty_print)
        if self.syllabic is not None:
            namespaceprefix_ = self.syllabic_nsprefix_ + ':' if (UseCapturedNS_ and self.syllabic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssyllabic>%s</%ssyllabic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.syllabic), input_name='syllabic')), namespaceprefix_ , eol_))
        for text_ in self.text:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            text_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.extend is not None:
            namespaceprefix_ = self.extend_nsprefix_ + ':' if (UseCapturedNS_ and self.extend_nsprefix_) else ''
            self.extend.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extend', pretty_print=pretty_print)
        if self.laughing is not None:
            namespaceprefix_ = self.laughing_nsprefix_ + ':' if (UseCapturedNS_ and self.laughing_nsprefix_) else ''
            self.laughing.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laughing', pretty_print=pretty_print)
        if self.humming is not None:
            namespaceprefix_ = self.humming_nsprefix_ + ':' if (UseCapturedNS_ and self.humming_nsprefix_) else ''
            self.humming.export(outfile, level, namespaceprefix_, namespacedef_='', name_='humming', pretty_print=pretty_print)
        if self.end_line is not None:
            namespaceprefix_ = self.end_line_nsprefix_ + ':' if (UseCapturedNS_ and self.end_line_nsprefix_) else ''
            self.end_line.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end-line', pretty_print=pretty_print)
        if self.end_paragraph is not None:
            namespaceprefix_ = self.end_paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.end_paragraph_nsprefix_) else ''
            self.end_paragraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end-paragraph', pretty_print=pretty_print)
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.name = ' '.join(self.name.split())
        value = find_attr_value_('time-only', node)
        if value is not None and 'time-only' not in already_processed:
            already_processed.add('time-only')
            self.time_only = value
            self.time_only = ' '.join(self.time_only.split())
            self.validate_time_only(self.time_only)    # validate type time-only
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'elision':
            obj_ = elision.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.elision = obj_
            obj_.original_tagname_ = 'elision'
        elif nodeName_ == 'syllabic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'syllabic')
            value_ = self.gds_validate_string(value_, node, 'syllabic')
            self.syllabic = value_
            self.syllabic_nsprefix_ = child_.prefix
            # validate type syllabic
            self.validate_syllabic(self.syllabic)
        elif nodeName_ == 'text':
            obj_ = text_element_data.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'extend':
            obj_ = extend.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extend = obj_
            obj_.original_tagname_ = 'extend'
        elif nodeName_ == 'laughing':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.laughing = obj_
            obj_.original_tagname_ = 'laughing'
        elif nodeName_ == 'humming':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.humming = obj_
            obj_.original_tagname_ = 'humming'
        elif nodeName_ == 'end-line':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end_line = obj_
            obj_.original_tagname_ = 'end-line'
        elif nodeName_ == 'end-paragraph':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end_paragraph = obj_
            obj_.original_tagname_ = 'end-paragraph'
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
# end class lyric


class mordent(empty_trill_sound):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = empty_trill_sound
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, start_note=None, trill_step=None, two_note_turn=None, accelerate=None, beats=None, second_beat=None, last_beat=None, long=None, approach=None, departure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("mordent"), self).__init__(default_x, default_y, relative_x, relative_y, font_family, font_style, font_size, font_weight, color, placement, start_note, trill_step, two_note_turn, accelerate, beats, second_beat, last_beat,  **kwargs_)
        self.long = _cast(None, long)
        self.long_nsprefix_ = None
        self.approach = _cast(None, approach)
        self.approach_nsprefix_ = None
        self.departure = _cast(None, departure)
        self.departure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mordent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mordent.subclass:
            return mordent.subclass(*args_, **kwargs_)
        else:
            return mordent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_long(self):
        return self.long
    def set_long(self, long):
        self.long = long
    def get_approach(self):
        return self.approach
    def set_approach(self, approach):
        self.approach = approach
    def get_departure(self):
        return self.departure
    def set_departure(self, departure):
        self.departure = departure
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            super(mordent, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mordent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mordent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mordent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mordent')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mordent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mordent'):
        super(mordent, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mordent')
        if self.long is not None and 'long' not in already_processed:
            already_processed.add('long')
            outfile.write(' long=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.long), input_name='long')), ))
        if self.approach is not None and 'approach' not in already_processed:
            already_processed.add('approach')
            outfile.write(' approach=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.approach), input_name='approach')), ))
        if self.departure is not None and 'departure' not in already_processed:
            already_processed.add('departure')
            outfile.write(' departure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.departure), input_name='departure')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mordent', fromsubclass_=False, pretty_print=True):
        super(mordent, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('long', node)
        if value is not None and 'long' not in already_processed:
            already_processed.add('long')
            self.long = value
            self.long = ' '.join(self.long.split())
            self.validate_yes_no(self.long)    # validate type yes-no
        value = find_attr_value_('approach', node)
        if value is not None and 'approach' not in already_processed:
            already_processed.add('approach')
            self.approach = value
            self.approach = ' '.join(self.approach.split())
            self.validate_above_below(self.approach)    # validate type above-below
        value = find_attr_value_('departure', node)
        if value is not None and 'departure' not in already_processed:
            already_processed.add('departure')
            self.departure = value
            self.departure = ' '.join(self.departure.split())
            self.validate_above_below(self.departure)    # validate type above-below
        super(mordent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(mordent, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class mordent


class non_arpeggiate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, default_x=None, default_y=None, relative_x=None, relative_y=None, placement=None, color=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, non_arpeggiate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if non_arpeggiate.subclass:
            return non_arpeggiate.subclass(*args_, **kwargs_)
        else:
            return non_arpeggiate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_top_bottom(self, value):
        # Validate type top-bottom, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'bottom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on top-bottom' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='non-arpeggiate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('non-arpeggiate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'non-arpeggiate':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='non-arpeggiate')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='non-arpeggiate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='non-arpeggiate'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='non-arpeggiate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_top_bottom(self.type_)    # validate type top-bottom
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class non_arpeggiate


class notations(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, print_object=None, id=None, footnote=None, level=None, tied=None, slur=None, tuplet=None, glissando=None, slide=None, ornaments=None, technical=None, articulations=None, dynamics=None, fermata=None, arpeggiate=None, non_arpeggiate=None, accidental_mark=None, other_notation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
        if tied is None:
            self.tied = []
        else:
            self.tied = tied
        self.tied_nsprefix_ = None
        if slur is None:
            self.slur = []
        else:
            self.slur = slur
        self.slur_nsprefix_ = None
        if tuplet is None:
            self.tuplet = []
        else:
            self.tuplet = tuplet
        self.tuplet_nsprefix_ = None
        if glissando is None:
            self.glissando = []
        else:
            self.glissando = glissando
        self.glissando_nsprefix_ = None
        if slide is None:
            self.slide = []
        else:
            self.slide = slide
        self.slide_nsprefix_ = None
        if ornaments is None:
            self.ornaments = []
        else:
            self.ornaments = ornaments
        self.ornaments_nsprefix_ = None
        if technical is None:
            self.technical = []
        else:
            self.technical = technical
        self.technical_nsprefix_ = None
        if articulations is None:
            self.articulations = []
        else:
            self.articulations = articulations
        self.articulations_nsprefix_ = None
        if dynamics is None:
            self.dynamics = []
        else:
            self.dynamics = dynamics
        self.dynamics_nsprefix_ = None
        if fermata is None:
            self.fermata = []
        else:
            self.fermata = fermata
        self.fermata_nsprefix_ = None
        if arpeggiate is None:
            self.arpeggiate = []
        else:
            self.arpeggiate = arpeggiate
        self.arpeggiate_nsprefix_ = None
        if non_arpeggiate is None:
            self.non_arpeggiate = []
        else:
            self.non_arpeggiate = non_arpeggiate
        self.non_arpeggiate_nsprefix_ = None
        if accidental_mark is None:
            self.accidental_mark = []
        else:
            self.accidental_mark = accidental_mark
        self.accidental_mark_nsprefix_ = None
        if other_notation is None:
            self.other_notation = []
        else:
            self.other_notation = other_notation
        self.other_notation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, notations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if notations.subclass:
            return notations.subclass(*args_, **kwargs_)
        else:
            return notations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_tied(self):
        return self.tied
    def set_tied(self, tied):
        self.tied = tied
    def add_tied(self, value):
        self.tied.append(value)
    def insert_tied_at(self, index, value):
        self.tied.insert(index, value)
    def replace_tied_at(self, index, value):
        self.tied[index] = value
    def get_slur(self):
        return self.slur
    def set_slur(self, slur):
        self.slur = slur
    def add_slur(self, value):
        self.slur.append(value)
    def insert_slur_at(self, index, value):
        self.slur.insert(index, value)
    def replace_slur_at(self, index, value):
        self.slur[index] = value
    def get_tuplet(self):
        return self.tuplet
    def set_tuplet(self, tuplet):
        self.tuplet = tuplet
    def add_tuplet(self, value):
        self.tuplet.append(value)
    def insert_tuplet_at(self, index, value):
        self.tuplet.insert(index, value)
    def replace_tuplet_at(self, index, value):
        self.tuplet[index] = value
    def get_glissando(self):
        return self.glissando
    def set_glissando(self, glissando):
        self.glissando = glissando
    def add_glissando(self, value):
        self.glissando.append(value)
    def insert_glissando_at(self, index, value):
        self.glissando.insert(index, value)
    def replace_glissando_at(self, index, value):
        self.glissando[index] = value
    def get_slide(self):
        return self.slide
    def set_slide(self, slide):
        self.slide = slide
    def add_slide(self, value):
        self.slide.append(value)
    def insert_slide_at(self, index, value):
        self.slide.insert(index, value)
    def replace_slide_at(self, index, value):
        self.slide[index] = value
    def get_ornaments(self):
        return self.ornaments
    def set_ornaments(self, ornaments):
        self.ornaments = ornaments
    def add_ornaments(self, value):
        self.ornaments.append(value)
    def insert_ornaments_at(self, index, value):
        self.ornaments.insert(index, value)
    def replace_ornaments_at(self, index, value):
        self.ornaments[index] = value
    def get_technical(self):
        return self.technical
    def set_technical(self, technical):
        self.technical = technical
    def add_technical(self, value):
        self.technical.append(value)
    def insert_technical_at(self, index, value):
        self.technical.insert(index, value)
    def replace_technical_at(self, index, value):
        self.technical[index] = value
    def get_articulations(self):
        return self.articulations
    def set_articulations(self, articulations):
        self.articulations = articulations
    def add_articulations(self, value):
        self.articulations.append(value)
    def insert_articulations_at(self, index, value):
        self.articulations.insert(index, value)
    def replace_articulations_at(self, index, value):
        self.articulations[index] = value
    def get_dynamics(self):
        return self.dynamics
    def set_dynamics(self, dynamics):
        self.dynamics = dynamics
    def add_dynamics(self, value):
        self.dynamics.append(value)
    def insert_dynamics_at(self, index, value):
        self.dynamics.insert(index, value)
    def replace_dynamics_at(self, index, value):
        self.dynamics[index] = value
    def get_fermata(self):
        return self.fermata
    def set_fermata(self, fermata):
        self.fermata = fermata
    def add_fermata(self, value):
        self.fermata.append(value)
    def insert_fermata_at(self, index, value):
        self.fermata.insert(index, value)
    def replace_fermata_at(self, index, value):
        self.fermata[index] = value
    def get_arpeggiate(self):
        return self.arpeggiate
    def set_arpeggiate(self, arpeggiate):
        self.arpeggiate = arpeggiate
    def add_arpeggiate(self, value):
        self.arpeggiate.append(value)
    def insert_arpeggiate_at(self, index, value):
        self.arpeggiate.insert(index, value)
    def replace_arpeggiate_at(self, index, value):
        self.arpeggiate[index] = value
    def get_non_arpeggiate(self):
        return self.non_arpeggiate
    def set_non_arpeggiate(self, non_arpeggiate):
        self.non_arpeggiate = non_arpeggiate
    def add_non_arpeggiate(self, value):
        self.non_arpeggiate.append(value)
    def insert_non_arpeggiate_at(self, index, value):
        self.non_arpeggiate.insert(index, value)
    def replace_non_arpeggiate_at(self, index, value):
        self.non_arpeggiate[index] = value
    def get_accidental_mark(self):
        return self.accidental_mark
    def set_accidental_mark(self, accidental_mark):
        self.accidental_mark = accidental_mark
    def add_accidental_mark(self, value):
        self.accidental_mark.append(value)
    def insert_accidental_mark_at(self, index, value):
        self.accidental_mark.insert(index, value)
    def replace_accidental_mark_at(self, index, value):
        self.accidental_mark[index] = value
    def get_other_notation(self):
        return self.other_notation
    def set_other_notation(self, other_notation):
        self.other_notation = other_notation
    def add_other_notation(self, value):
        self.other_notation.append(value)
    def insert_other_notation_at(self, index, value):
        self.other_notation.insert(index, value)
    def replace_other_notation_at(self, index, value):
        self.other_notation[index] = value
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.footnote is not None or
            self.level is not None or
            self.tied or
            self.slur or
            self.tuplet or
            self.glissando or
            self.slide or
            self.ornaments or
            self.technical or
            self.articulations or
            self.dynamics or
            self.fermata or
            self.arpeggiate or
            self.non_arpeggiate or
            self.accidental_mark or
            self.other_notation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='notations', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('notations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'notations':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='notations')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='notations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='notations'):
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='notations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
        for tied_ in self.tied:
            namespaceprefix_ = self.tied_nsprefix_ + ':' if (UseCapturedNS_ and self.tied_nsprefix_) else ''
            tied_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tied', pretty_print=pretty_print)
        for slur_ in self.slur:
            namespaceprefix_ = self.slur_nsprefix_ + ':' if (UseCapturedNS_ and self.slur_nsprefix_) else ''
            slur_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slur', pretty_print=pretty_print)
        for tuplet_ in self.tuplet:
            namespaceprefix_ = self.tuplet_nsprefix_ + ':' if (UseCapturedNS_ and self.tuplet_nsprefix_) else ''
            tuplet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tuplet', pretty_print=pretty_print)
        for glissando_ in self.glissando:
            namespaceprefix_ = self.glissando_nsprefix_ + ':' if (UseCapturedNS_ and self.glissando_nsprefix_) else ''
            glissando_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glissando', pretty_print=pretty_print)
        for slide_ in self.slide:
            namespaceprefix_ = self.slide_nsprefix_ + ':' if (UseCapturedNS_ and self.slide_nsprefix_) else ''
            slide_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slide', pretty_print=pretty_print)
        for ornaments_ in self.ornaments:
            namespaceprefix_ = self.ornaments_nsprefix_ + ':' if (UseCapturedNS_ and self.ornaments_nsprefix_) else ''
            ornaments_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ornaments', pretty_print=pretty_print)
        for technical_ in self.technical:
            namespaceprefix_ = self.technical_nsprefix_ + ':' if (UseCapturedNS_ and self.technical_nsprefix_) else ''
            technical_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='technical', pretty_print=pretty_print)
        for articulations_ in self.articulations:
            namespaceprefix_ = self.articulations_nsprefix_ + ':' if (UseCapturedNS_ and self.articulations_nsprefix_) else ''
            articulations_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='articulations', pretty_print=pretty_print)
        for dynamics_ in self.dynamics:
            namespaceprefix_ = self.dynamics_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamics_nsprefix_) else ''
            dynamics_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamics', pretty_print=pretty_print)
        for fermata_ in self.fermata:
            namespaceprefix_ = self.fermata_nsprefix_ + ':' if (UseCapturedNS_ and self.fermata_nsprefix_) else ''
            fermata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fermata', pretty_print=pretty_print)
        for arpeggiate_ in self.arpeggiate:
            namespaceprefix_ = self.arpeggiate_nsprefix_ + ':' if (UseCapturedNS_ and self.arpeggiate_nsprefix_) else ''
            arpeggiate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arpeggiate', pretty_print=pretty_print)
        for non_arpeggiate_ in self.non_arpeggiate:
            namespaceprefix_ = self.non_arpeggiate_nsprefix_ + ':' if (UseCapturedNS_ and self.non_arpeggiate_nsprefix_) else ''
            non_arpeggiate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='non-arpeggiate', pretty_print=pretty_print)
        for accidental_mark_ in self.accidental_mark:
            namespaceprefix_ = self.accidental_mark_nsprefix_ + ':' if (UseCapturedNS_ and self.accidental_mark_nsprefix_) else ''
            accidental_mark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accidental-mark', pretty_print=pretty_print)
        for other_notation_ in self.other_notation:
            namespaceprefix_ = self.other_notation_nsprefix_ + ':' if (UseCapturedNS_ and self.other_notation_nsprefix_) else ''
            other_notation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-notation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
        elif nodeName_ == 'tied':
            obj_ = tied.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tied.append(obj_)
            obj_.original_tagname_ = 'tied'
        elif nodeName_ == 'slur':
            obj_ = slur.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slur.append(obj_)
            obj_.original_tagname_ = 'slur'
        elif nodeName_ == 'tuplet':
            obj_ = tuplet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tuplet.append(obj_)
            obj_.original_tagname_ = 'tuplet'
        elif nodeName_ == 'glissando':
            obj_ = glissando.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glissando.append(obj_)
            obj_.original_tagname_ = 'glissando'
        elif nodeName_ == 'slide':
            obj_ = slide.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slide.append(obj_)
            obj_.original_tagname_ = 'slide'
        elif nodeName_ == 'ornaments':
            obj_ = ornaments.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ornaments.append(obj_)
            obj_.original_tagname_ = 'ornaments'
        elif nodeName_ == 'technical':
            obj_ = technical.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.technical.append(obj_)
            obj_.original_tagname_ = 'technical'
        elif nodeName_ == 'articulations':
            obj_ = articulations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.articulations.append(obj_)
            obj_.original_tagname_ = 'articulations'
        elif nodeName_ == 'dynamics':
            obj_ = dynamics.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamics.append(obj_)
            obj_.original_tagname_ = 'dynamics'
        elif nodeName_ == 'fermata':
            obj_ = fermata.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fermata.append(obj_)
            obj_.original_tagname_ = 'fermata'
        elif nodeName_ == 'arpeggiate':
            obj_ = arpeggiate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arpeggiate.append(obj_)
            obj_.original_tagname_ = 'arpeggiate'
        elif nodeName_ == 'non-arpeggiate':
            obj_ = non_arpeggiate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.non_arpeggiate.append(obj_)
            obj_.original_tagname_ = 'non-arpeggiate'
        elif nodeName_ == 'accidental-mark':
            obj_ = accidental_mark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accidental_mark.append(obj_)
            obj_.original_tagname_ = 'accidental-mark'
        elif nodeName_ == 'other-notation':
            obj_ = other_notation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_notation.append(obj_)
            obj_.original_tagname_ = 'other-notation'
# end class notations


class note(GeneratedsSuper):
    """chord -- The chord element indicates that this note is an additional chord tone with the preceding note.
    The duration of a chord note does not move the musical position within a measure. That is done by the duration of the first preceding note without a chord element. Thus the duration of a chord note cannot be longer than the preceding note.
    In most cases the duration will be the same as the preceding note. However it can be shorter in situations such as multiple stops for string instruments.
    cue -- The cue element indicates the presence of a cue note. In MusicXML, a cue note is a silent note with no playback. Normal notes that play can be specified as cue size using the type element. A cue note that is specified as full size using the type element will still remain silent.
    chord -- The chord element indicates that this note is an additional chord tone with the preceding note.
    The duration of a chord note does not move the musical position within a measure. That is done by the duration of the first preceding note without a chord element. Thus the duration of a chord note cannot be longer than the preceding note.
    In most cases the duration will be the same as the preceding note. However it can be shorter in situations such as multiple stops for string instruments.
    chord -- The chord element indicates that this note is an additional chord tone with the preceding note.
    The duration of a chord note does not move the musical position within a measure. That is done by the duration of the first preceding note without a chord element. Thus the duration of a chord note cannot be longer than the preceding note.
    In most cases the duration will be the same as the preceding note. However it can be shorter in situations such as multiple stops for string instruments.
    duration -- Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should be represented using the note element's attack and release attributes.
    The duration element moves the musical position when used in backup elements, forward elements, and note elements that do not contain a chord child element.
    dot -- One dot element is used for each dot of prolongation. The placement attribute is used to specify whether the dot should appear above or below the staff line. It is ignored for notes that appear on a staff space.
    staff -- Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, print_leger=None, dynamics=None, end_dynamics=None, attack=None, release=None, time_only=None, pizzicato=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, print_object=None, print_dot=None, print_spacing=None, print_lyric=None, id=None, grace=None, chord=None, pitch=None, unpitched=None, rest=None, cue=None, duration=None, tie=None, instrument=None, footnote=None, level=None, voice=None, type_=None, dot=None, accidental=None, time_modification=None, stem=None, notehead=None, notehead_text=None, staff=None, beam=None, notations=None, lyric=None, play=None, listen=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.print_leger = _cast(None, print_leger)
        self.print_leger_nsprefix_ = None
        self.dynamics = _cast(float, dynamics)
        self.dynamics_nsprefix_ = None
        self.end_dynamics = _cast(float, end_dynamics)
        self.end_dynamics_nsprefix_ = None
        self.attack = _cast(float, attack)
        self.attack_nsprefix_ = None
        self.release = _cast(float, release)
        self.release_nsprefix_ = None
        self.time_only = _cast(None, time_only)
        self.time_only_nsprefix_ = None
        self.pizzicato = _cast(None, pizzicato)
        self.pizzicato_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.print_dot = _cast(None, print_dot)
        self.print_dot_nsprefix_ = None
        self.print_spacing = _cast(None, print_spacing)
        self.print_spacing_nsprefix_ = None
        self.print_lyric = _cast(None, print_lyric)
        self.print_lyric_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.grace = grace
        self.grace_nsprefix_ = None
        self.chord = chord
        self.chord_nsprefix_ = None
        self.pitch = pitch
        self.pitch_nsprefix_ = None
        self.unpitched = unpitched
        self.unpitched_nsprefix_ = None
        self.rest = rest
        self.rest_nsprefix_ = None
        self.cue = cue
        self.cue_nsprefix_ = None
        self.chord = chord
        self.chord_nsprefix_ = None
        self.pitch = pitch
        self.pitch_nsprefix_ = None
        self.unpitched = unpitched
        self.unpitched_nsprefix_ = None
        self.rest = rest
        self.rest_nsprefix_ = None
        self.chord = chord
        self.chord_nsprefix_ = None
        self.pitch = pitch
        self.pitch_nsprefix_ = None
        self.unpitched = unpitched
        self.unpitched_nsprefix_ = None
        self.rest = rest
        self.rest_nsprefix_ = None
        self.duration = duration
        self.validate_positive_divisions(self.duration)
        self.duration_nsprefix_ = None
        if tie is None:
            self.tie = []
        else:
            self.tie = tie
        self.tie_nsprefix_ = None
        if instrument is None:
            self.instrument = []
        else:
            self.instrument = instrument
        self.instrument_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
        self.voice = voice
        self.voice_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        self.accidental = accidental
        self.accidental_nsprefix_ = None
        self.time_modification = time_modification
        self.time_modification_nsprefix_ = None
        self.stem = stem
        self.stem_nsprefix_ = None
        self.notehead = notehead
        self.notehead_nsprefix_ = None
        self.notehead_text = notehead_text
        self.notehead_text_nsprefix_ = None
        self.staff = staff
        self.staff_nsprefix_ = None
        if beam is None:
            self.beam = []
        else:
            self.beam = beam
        self.beam_nsprefix_ = None
        if notations is None:
            self.notations = []
        else:
            self.notations = notations
        self.notations_nsprefix_ = None
        if lyric is None:
            self.lyric = []
        else:
            self.lyric = lyric
        self.lyric_nsprefix_ = None
        self.play = play
        self.play_nsprefix_ = None
        self.listen = listen
        self.listen_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, note)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if note.subclass:
            return note.subclass(*args_, **kwargs_)
        else:
            return note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_grace(self):
        return self.grace
    def set_grace(self, grace):
        self.grace = grace
    def get_chord(self):
        return self.chord
    def set_chord(self, chord):
        self.chord = chord
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_unpitched(self):
        return self.unpitched
    def set_unpitched(self, unpitched):
        self.unpitched = unpitched
    def get_rest(self):
        return self.rest
    def set_rest(self, rest):
        self.rest = rest
    def get_cue(self):
        return self.cue
    def set_cue(self, cue):
        self.cue = cue
    def get_chord(self):
        return self.chord
    def set_chord(self, chord):
        self.chord = chord
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_unpitched(self):
        return self.unpitched
    def set_unpitched(self, unpitched):
        self.unpitched = unpitched
    def get_rest(self):
        return self.rest
    def set_rest(self, rest):
        self.rest = rest
    def get_chord(self):
        return self.chord
    def set_chord(self, chord):
        self.chord = chord
    def get_pitch(self):
        return self.pitch
    def set_pitch(self, pitch):
        self.pitch = pitch
    def get_unpitched(self):
        return self.unpitched
    def set_unpitched(self, unpitched):
        self.unpitched = unpitched
    def get_rest(self):
        return self.rest
    def set_rest(self, rest):
        self.rest = rest
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_tie(self):
        return self.tie
    def set_tie(self, tie):
        self.tie = tie
    def add_tie(self, value):
        self.tie.append(value)
    def insert_tie_at(self, index, value):
        self.tie.insert(index, value)
    def replace_tie_at(self, index, value):
        self.tie[index] = value
    def get_instrument(self):
        return self.instrument
    def set_instrument(self, instrument):
        self.instrument = instrument
    def add_instrument(self, value):
        self.instrument.append(value)
    def insert_instrument_at(self, index, value):
        self.instrument.insert(index, value)
    def replace_instrument_at(self, index, value):
        self.instrument[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_voice(self):
        return self.voice
    def set_voice(self, voice):
        self.voice = voice
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_accidental(self):
        return self.accidental
    def set_accidental(self, accidental):
        self.accidental = accidental
    def get_time_modification(self):
        return self.time_modification
    def set_time_modification(self, time_modification):
        self.time_modification = time_modification
    def get_stem(self):
        return self.stem
    def set_stem(self, stem):
        self.stem = stem
    def get_notehead(self):
        return self.notehead
    def set_notehead(self, notehead):
        self.notehead = notehead
    def get_notehead_text(self):
        return self.notehead_text
    def set_notehead_text(self, notehead_text):
        self.notehead_text = notehead_text
    def get_staff(self):
        return self.staff
    def set_staff(self, staff):
        self.staff = staff
    def get_beam(self):
        return self.beam
    def set_beam(self, beam):
        self.beam = beam
    def add_beam(self, value):
        self.beam.append(value)
    def insert_beam_at(self, index, value):
        self.beam.insert(index, value)
    def replace_beam_at(self, index, value):
        self.beam[index] = value
    def get_notations(self):
        return self.notations
    def set_notations(self, notations):
        self.notations = notations
    def add_notations(self, value):
        self.notations.append(value)
    def insert_notations_at(self, index, value):
        self.notations.insert(index, value)
    def replace_notations_at(self, index, value):
        self.notations[index] = value
    def get_lyric(self):
        return self.lyric
    def set_lyric(self, lyric):
        self.lyric = lyric
    def add_lyric(self, value):
        self.lyric.append(value)
    def insert_lyric_at(self, index, value):
        self.lyric.insert(index, value)
    def replace_lyric_at(self, index, value):
        self.lyric[index] = value
    def get_play(self):
        return self.play
    def set_play(self, play):
        self.play = play
    def get_listen(self):
        return self.listen
    def set_listen(self, listen):
        self.listen = listen
    def get_print_leger(self):
        return self.print_leger
    def set_print_leger(self, print_leger):
        self.print_leger = print_leger
    def get_dynamics(self):
        return self.dynamics
    def set_dynamics(self, dynamics):
        self.dynamics = dynamics
    def get_end_dynamics(self):
        return self.end_dynamics
    def set_end_dynamics(self, end_dynamics):
        self.end_dynamics = end_dynamics
    def get_attack(self):
        return self.attack
    def set_attack(self, attack):
        self.attack = attack
    def get_release(self):
        return self.release
    def set_release(self, release):
        self.release = release
    def get_time_only(self):
        return self.time_only
    def set_time_only(self, time_only):
        self.time_only = time_only
    def get_pizzicato(self):
        return self.pizzicato
    def set_pizzicato(self, pizzicato):
        self.pizzicato = pizzicato
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_print_dot(self):
        return self.print_dot
    def set_print_dot(self, print_dot):
        self.print_dot = print_dot
    def get_print_spacing(self):
        return self.print_spacing
    def set_print_spacing(self, print_spacing):
        self.print_spacing = print_spacing
    def get_print_lyric(self):
        return self.print_lyric
    def set_print_lyric(self, print_lyric):
        self.print_lyric = print_lyric
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_positive_divisions(self, value):
        result = True
        # Validate type positive-divisions, a restriction on divisions.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on positive-divisions' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_non_negative_decimal(self, value):
        # Validate type non-negative-decimal, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on non-negative-decimal' % {"value": value, "lineno": lineno} )
                result = False
    def validate_time_only(self, value):
        # Validate type time-only, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_time_only_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_time_only_patterns_, ))
    validate_time_only_patterns_ = [['^([1-9][0-9]*(, ?[1-9][0-9]*)*)$']]
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            self.grace is not None or
            self.chord is not None or
            self.pitch is not None or
            self.unpitched is not None or
            self.rest is not None or
            self.cue is not None or
            self.chord is not None or
            self.pitch is not None or
            self.unpitched is not None or
            self.rest is not None or
            self.chord is not None or
            self.pitch is not None or
            self.unpitched is not None or
            self.rest is not None or
            self.duration is not None or
            self.tie or
            self.instrument or
            self.footnote is not None or
            self.level is not None or
            self.voice is not None or
            self.type_ is not None or
            self.dot or
            self.accidental is not None or
            self.time_modification is not None or
            self.stem is not None or
            self.notehead is not None or
            self.notehead_text is not None or
            self.staff is not None or
            self.beam or
            self.notations or
            self.lyric or
            self.play is not None or
            self.listen is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='note', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('note')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'note':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='note')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='note', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='note'):
        if self.print_leger is not None and 'print_leger' not in already_processed:
            already_processed.add('print_leger')
            outfile.write(' print-leger=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_leger), input_name='print-leger')), ))
        if self.dynamics is not None and 'dynamics' not in already_processed:
            already_processed.add('dynamics')
            outfile.write(' dynamics="%s"' % self.gds_format_decimal(self.dynamics, input_name='dynamics'))
        if self.end_dynamics is not None and 'end_dynamics' not in already_processed:
            already_processed.add('end_dynamics')
            outfile.write(' end-dynamics="%s"' % self.gds_format_decimal(self.end_dynamics, input_name='end-dynamics'))
        if self.attack is not None and 'attack' not in already_processed:
            already_processed.add('attack')
            outfile.write(' attack="%s"' % self.gds_format_decimal(self.attack, input_name='attack'))
        if self.release is not None and 'release' not in already_processed:
            already_processed.add('release')
            outfile.write(' release="%s"' % self.gds_format_decimal(self.release, input_name='release'))
        if self.time_only is not None and 'time_only' not in already_processed:
            already_processed.add('time_only')
            outfile.write(' time-only=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time_only), input_name='time-only')), ))
        if self.pizzicato is not None and 'pizzicato' not in already_processed:
            already_processed.add('pizzicato')
            outfile.write(' pizzicato=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pizzicato), input_name='pizzicato')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.print_dot is not None and 'print_dot' not in already_processed:
            already_processed.add('print_dot')
            outfile.write(' print-dot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_dot), input_name='print-dot')), ))
        if self.print_spacing is not None and 'print_spacing' not in already_processed:
            already_processed.add('print_spacing')
            outfile.write(' print-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_spacing), input_name='print-spacing')), ))
        if self.print_lyric is not None and 'print_lyric' not in already_processed:
            already_processed.add('print_lyric')
            outfile.write(' print-lyric=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_lyric), input_name='print-lyric')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='note', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.grace is not None:
            namespaceprefix_ = self.grace_nsprefix_ + ':' if (UseCapturedNS_ and self.grace_nsprefix_) else ''
            self.grace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='grace', pretty_print=pretty_print)
        if self.chord is not None:
            namespaceprefix_ = self.chord_nsprefix_ + ':' if (UseCapturedNS_ and self.chord_nsprefix_) else ''
            self.chord.export(outfile, level, namespaceprefix_, namespacedef_='', name_='chord', pretty_print=pretty_print)
        if self.pitch is not None:
            namespaceprefix_ = self.pitch_nsprefix_ + ':' if (UseCapturedNS_ and self.pitch_nsprefix_) else ''
            self.pitch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pitch', pretty_print=pretty_print)
        if self.unpitched is not None:
            namespaceprefix_ = self.unpitched_nsprefix_ + ':' if (UseCapturedNS_ and self.unpitched_nsprefix_) else ''
            self.unpitched.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unpitched', pretty_print=pretty_print)
        if self.rest is not None:
            namespaceprefix_ = self.rest_nsprefix_ + ':' if (UseCapturedNS_ and self.rest_nsprefix_) else ''
            self.rest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rest', pretty_print=pretty_print)
        if self.cue is not None:
            namespaceprefix_ = self.cue_nsprefix_ + ':' if (UseCapturedNS_ and self.cue_nsprefix_) else ''
            self.cue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cue', pretty_print=pretty_print)
        if self.chord is not None:
            namespaceprefix_ = self.chord_nsprefix_ + ':' if (UseCapturedNS_ and self.chord_nsprefix_) else ''
            self.chord.export(outfile, level, namespaceprefix_, namespacedef_='', name_='chord', pretty_print=pretty_print)
        if self.pitch is not None:
            namespaceprefix_ = self.pitch_nsprefix_ + ':' if (UseCapturedNS_ and self.pitch_nsprefix_) else ''
            self.pitch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pitch', pretty_print=pretty_print)
        if self.unpitched is not None:
            namespaceprefix_ = self.unpitched_nsprefix_ + ':' if (UseCapturedNS_ and self.unpitched_nsprefix_) else ''
            self.unpitched.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unpitched', pretty_print=pretty_print)
        if self.rest is not None:
            namespaceprefix_ = self.rest_nsprefix_ + ':' if (UseCapturedNS_ and self.rest_nsprefix_) else ''
            self.rest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rest', pretty_print=pretty_print)
        if self.chord is not None:
            namespaceprefix_ = self.chord_nsprefix_ + ':' if (UseCapturedNS_ and self.chord_nsprefix_) else ''
            self.chord.export(outfile, level, namespaceprefix_, namespacedef_='', name_='chord', pretty_print=pretty_print)
        if self.pitch is not None:
            namespaceprefix_ = self.pitch_nsprefix_ + ':' if (UseCapturedNS_ and self.pitch_nsprefix_) else ''
            self.pitch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pitch', pretty_print=pretty_print)
        if self.unpitched is not None:
            namespaceprefix_ = self.unpitched_nsprefix_ + ':' if (UseCapturedNS_ and self.unpitched_nsprefix_) else ''
            self.unpitched.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unpitched', pretty_print=pretty_print)
        if self.rest is not None:
            namespaceprefix_ = self.rest_nsprefix_ + ':' if (UseCapturedNS_ and self.rest_nsprefix_) else ''
            self.rest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rest', pretty_print=pretty_print)
        if self.duration is not None:
            namespaceprefix_ = self.duration_nsprefix_ + ':' if (UseCapturedNS_ and self.duration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespaceprefix_ , self.gds_format_decimal(self.duration, input_name='duration'), namespaceprefix_ , eol_))
        for tie_ in self.tie:
            namespaceprefix_ = self.tie_nsprefix_ + ':' if (UseCapturedNS_ and self.tie_nsprefix_) else ''
            tie_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tie', pretty_print=pretty_print)
        for instrument_ in self.instrument:
            namespaceprefix_ = self.instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_nsprefix_) else ''
            instrument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instrument', pretty_print=pretty_print)
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
        if self.voice is not None:
            namespaceprefix_ = self.voice_nsprefix_ + ':' if (UseCapturedNS_ and self.voice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svoice>%s</%svoice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.voice), input_name='voice')), namespaceprefix_ , eol_))
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        if self.accidental is not None:
            namespaceprefix_ = self.accidental_nsprefix_ + ':' if (UseCapturedNS_ and self.accidental_nsprefix_) else ''
            self.accidental.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accidental', pretty_print=pretty_print)
        if self.time_modification is not None:
            namespaceprefix_ = self.time_modification_nsprefix_ + ':' if (UseCapturedNS_ and self.time_modification_nsprefix_) else ''
            self.time_modification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time-modification', pretty_print=pretty_print)
        if self.stem is not None:
            namespaceprefix_ = self.stem_nsprefix_ + ':' if (UseCapturedNS_ and self.stem_nsprefix_) else ''
            self.stem.export(outfile, level, namespaceprefix_, namespacedef_='', name_='stem', pretty_print=pretty_print)
        if self.notehead is not None:
            namespaceprefix_ = self.notehead_nsprefix_ + ':' if (UseCapturedNS_ and self.notehead_nsprefix_) else ''
            self.notehead.export(outfile, level, namespaceprefix_, namespacedef_='', name_='notehead', pretty_print=pretty_print)
        if self.notehead_text is not None:
            namespaceprefix_ = self.notehead_text_nsprefix_ + ':' if (UseCapturedNS_ and self.notehead_text_nsprefix_) else ''
            self.notehead_text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='notehead-text', pretty_print=pretty_print)
        if self.staff is not None:
            namespaceprefix_ = self.staff_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaff>%s</%sstaff>%s' % (namespaceprefix_ , self.gds_format_integer(self.staff, input_name='staff'), namespaceprefix_ , eol_))
        for beam_ in self.beam:
            namespaceprefix_ = self.beam_nsprefix_ + ':' if (UseCapturedNS_ and self.beam_nsprefix_) else ''
            beam_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='beam', pretty_print=pretty_print)
        for notations_ in self.notations:
            namespaceprefix_ = self.notations_nsprefix_ + ':' if (UseCapturedNS_ and self.notations_nsprefix_) else ''
            notations_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='notations', pretty_print=pretty_print)
        for lyric_ in self.lyric:
            namespaceprefix_ = self.lyric_nsprefix_ + ':' if (UseCapturedNS_ and self.lyric_nsprefix_) else ''
            lyric_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lyric', pretty_print=pretty_print)
        if self.play is not None:
            namespaceprefix_ = self.play_nsprefix_ + ':' if (UseCapturedNS_ and self.play_nsprefix_) else ''
            self.play.export(outfile, level, namespaceprefix_, namespacedef_='', name_='play', pretty_print=pretty_print)
        if self.listen is not None:
            namespaceprefix_ = self.listen_nsprefix_ + ':' if (UseCapturedNS_ and self.listen_nsprefix_) else ''
            self.listen.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listen', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('print-leger', node)
        if value is not None and 'print-leger' not in already_processed:
            already_processed.add('print-leger')
            self.print_leger = value
            self.print_leger = ' '.join(self.print_leger.split())
            self.validate_yes_no(self.print_leger)    # validate type yes-no
        value = find_attr_value_('dynamics', node)
        if value is not None and 'dynamics' not in already_processed:
            already_processed.add('dynamics')
            value = self.gds_parse_decimal(value, node, 'dynamics')
            self.dynamics = value
            self.validate_non_negative_decimal(self.dynamics)    # validate type non-negative-decimal
        value = find_attr_value_('end-dynamics', node)
        if value is not None and 'end-dynamics' not in already_processed:
            already_processed.add('end-dynamics')
            value = self.gds_parse_decimal(value, node, 'end-dynamics')
            self.end_dynamics = value
            self.validate_non_negative_decimal(self.end_dynamics)    # validate type non-negative-decimal
        value = find_attr_value_('attack', node)
        if value is not None and 'attack' not in already_processed:
            already_processed.add('attack')
            value = self.gds_parse_decimal(value, node, 'attack')
            self.attack = value
        value = find_attr_value_('release', node)
        if value is not None and 'release' not in already_processed:
            already_processed.add('release')
            value = self.gds_parse_decimal(value, node, 'release')
            self.release = value
        value = find_attr_value_('time-only', node)
        if value is not None and 'time-only' not in already_processed:
            already_processed.add('time-only')
            self.time_only = value
            self.time_only = ' '.join(self.time_only.split())
            self.validate_time_only(self.time_only)    # validate type time-only
        value = find_attr_value_('pizzicato', node)
        if value is not None and 'pizzicato' not in already_processed:
            already_processed.add('pizzicato')
            self.pizzicato = value
            self.pizzicato = ' '.join(self.pizzicato.split())
            self.validate_yes_no(self.pizzicato)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('print-dot', node)
        if value is not None and 'print-dot' not in already_processed:
            already_processed.add('print-dot')
            self.print_dot = value
            self.print_dot = ' '.join(self.print_dot.split())
            self.validate_yes_no(self.print_dot)    # validate type yes-no
        value = find_attr_value_('print-spacing', node)
        if value is not None and 'print-spacing' not in already_processed:
            already_processed.add('print-spacing')
            self.print_spacing = value
            self.print_spacing = ' '.join(self.print_spacing.split())
            self.validate_yes_no(self.print_spacing)    # validate type yes-no
        value = find_attr_value_('print-lyric', node)
        if value is not None and 'print-lyric' not in already_processed:
            already_processed.add('print-lyric')
            self.print_lyric = value
            self.print_lyric = ' '.join(self.print_lyric.split())
            self.validate_yes_no(self.print_lyric)    # validate type yes-no
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'grace':
            obj_ = grace.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.grace = obj_
            obj_.original_tagname_ = 'grace'
        elif nodeName_ == 'chord':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.chord = obj_
            obj_.original_tagname_ = 'chord'
        elif nodeName_ == 'pitch':
            obj_ = pitch.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pitch = obj_
            obj_.original_tagname_ = 'pitch'
        elif nodeName_ == 'unpitched':
            obj_ = unpitched.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unpitched = obj_
            obj_.original_tagname_ = 'unpitched'
        elif nodeName_ == 'rest':
            obj_ = rest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rest = obj_
            obj_.original_tagname_ = 'rest'
        elif nodeName_ == 'cue':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cue = obj_
            obj_.original_tagname_ = 'cue'
        elif nodeName_ == 'chord':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.chord = obj_
            obj_.original_tagname_ = 'chord'
        elif nodeName_ == 'pitch':
            obj_ = pitch.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pitch = obj_
            obj_.original_tagname_ = 'pitch'
        elif nodeName_ == 'unpitched':
            obj_ = unpitched.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unpitched = obj_
            obj_.original_tagname_ = 'unpitched'
        elif nodeName_ == 'rest':
            obj_ = rest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rest = obj_
            obj_.original_tagname_ = 'rest'
        elif nodeName_ == 'chord':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.chord = obj_
            obj_.original_tagname_ = 'chord'
        elif nodeName_ == 'pitch':
            obj_ = pitch.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pitch = obj_
            obj_.original_tagname_ = 'pitch'
        elif nodeName_ == 'unpitched':
            obj_ = unpitched.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unpitched = obj_
            obj_.original_tagname_ = 'unpitched'
        elif nodeName_ == 'rest':
            obj_ = rest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rest = obj_
            obj_.original_tagname_ = 'rest'
        elif nodeName_ == 'duration' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'duration')
            fval_ = self.gds_validate_decimal(fval_, node, 'duration')
            self.duration = fval_
            self.duration_nsprefix_ = child_.prefix
            # validate type positive-divisions
            self.validate_positive_divisions(self.duration)
        elif nodeName_ == 'tie':
            obj_ = tie.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tie.append(obj_)
            obj_.original_tagname_ = 'tie'
        elif nodeName_ == 'instrument':
            obj_ = instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument.append(obj_)
            obj_.original_tagname_ = 'instrument'
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
        elif nodeName_ == 'voice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'voice')
            value_ = self.gds_validate_string(value_, node, 'voice')
            self.voice = value_
            self.voice_nsprefix_ = child_.prefix
        elif nodeName_ == 'type':
            obj_ = note_type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'dot':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dot.append(obj_)
            obj_.original_tagname_ = 'dot'
        elif nodeName_ == 'accidental':
            obj_ = accidental.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accidental = obj_
            obj_.original_tagname_ = 'accidental'
        elif nodeName_ == 'time-modification':
            obj_ = time_modification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_modification = obj_
            obj_.original_tagname_ = 'time-modification'
        elif nodeName_ == 'stem':
            obj_ = stem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stem = obj_
            obj_.original_tagname_ = 'stem'
        elif nodeName_ == 'notehead':
            obj_ = notehead.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notehead = obj_
            obj_.original_tagname_ = 'notehead'
        elif nodeName_ == 'notehead-text':
            obj_ = notehead_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notehead_text = obj_
            obj_.original_tagname_ = 'notehead-text'
        elif nodeName_ == 'staff' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'staff')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'staff')
            self.staff = ival_
            self.staff_nsprefix_ = child_.prefix
        elif nodeName_ == 'beam':
            obj_ = beam.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.beam.append(obj_)
            obj_.original_tagname_ = 'beam'
        elif nodeName_ == 'notations':
            obj_ = notations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notations.append(obj_)
            obj_.original_tagname_ = 'notations'
        elif nodeName_ == 'lyric':
            obj_ = lyric.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lyric.append(obj_)
            obj_.original_tagname_ = 'lyric'
        elif nodeName_ == 'play':
            obj_ = play.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.play = obj_
            obj_.original_tagname_ = 'play'
        elif nodeName_ == 'listen':
            obj_ = listen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listen = obj_
            obj_.original_tagname_ = 'listen'
# end class note


class note_type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, size=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, note_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if note_type.subclass:
            return note_type.subclass(*args_, **kwargs_)
        else:
            return note_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_note_type_value(self, value):
        result = True
        # Validate type note-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_symbol_size(self, value):
        # Validate type symbol-size, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['full', 'cue', 'grace-cue', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on symbol-size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='note-type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('note-type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'note-type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='note-type')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='note-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='note-type'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='note-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.size = ' '.join(self.size.split())
            self.validate_symbol_size(self.size)    # validate type symbol-size
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class note_type


class notehead(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, filled=None, parentheses=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.filled = _cast(None, filled)
        self.filled_nsprefix_ = None
        self.parentheses = _cast(None, parentheses)
        self.parentheses_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, notehead)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if notehead.subclass:
            return notehead.subclass(*args_, **kwargs_)
        else:
            return notehead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_filled(self):
        return self.filled
    def set_filled(self, filled):
        self.filled = filled
    def get_parentheses(self):
        return self.parentheses
    def set_parentheses(self, parentheses):
        self.parentheses = parentheses
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_notehead_value(self, value):
        result = True
        # Validate type notehead-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['slash', 'triangle', 'diamond', 'square', 'cross', 'x', 'circle-x', 'inverted triangle', 'arrow down', 'arrow up', 'circled', 'slashed', 'back slashed', 'normal', 'cluster', 'circle dot', 'left triangle', 'rectangle', 'none', 'do', 're', 'mi', 'fa', 'fa up', 'so', 'la', 'ti', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on notehead-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_smufl_glyph_name(self, value):
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='notehead', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('notehead')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'notehead':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='notehead')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='notehead', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='notehead'):
        if self.filled is not None and 'filled' not in already_processed:
            already_processed.add('filled')
            outfile.write(' filled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filled), input_name='filled')), ))
        if self.parentheses is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            outfile.write(' parentheses=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentheses), input_name='parentheses')), ))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smufl), input_name='smufl')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='notehead', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filled', node)
        if value is not None and 'filled' not in already_processed:
            already_processed.add('filled')
            self.filled = value
            self.filled = ' '.join(self.filled.split())
            self.validate_yes_no(self.filled)    # validate type yes-no
        value = find_attr_value_('parentheses', node)
        if value is not None and 'parentheses' not in already_processed:
            already_processed.add('parentheses')
            self.parentheses = value
            self.parentheses = ' '.join(self.parentheses.split())
            self.validate_yes_no(self.parentheses)    # validate type yes-no
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_glyph_name(self.smufl)    # validate type smufl-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class notehead


class notehead_text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, display_text=None, accidental_text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if display_text is None:
            self.display_text = []
        else:
            self.display_text = display_text
        self.display_text_nsprefix_ = None
        if accidental_text is None:
            self.accidental_text = []
        else:
            self.accidental_text = accidental_text
        self.accidental_text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, notehead_text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if notehead_text.subclass:
            return notehead_text.subclass(*args_, **kwargs_)
        else:
            return notehead_text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_display_text(self):
        return self.display_text
    def set_display_text(self, display_text):
        self.display_text = display_text
    def add_display_text(self, value):
        self.display_text.append(value)
    def insert_display_text_at(self, index, value):
        self.display_text.insert(index, value)
    def replace_display_text_at(self, index, value):
        self.display_text[index] = value
    def get_accidental_text(self):
        return self.accidental_text
    def set_accidental_text(self, accidental_text):
        self.accidental_text = accidental_text
    def add_accidental_text(self, value):
        self.accidental_text.append(value)
    def insert_accidental_text_at(self, index, value):
        self.accidental_text.insert(index, value)
    def replace_accidental_text_at(self, index, value):
        self.accidental_text[index] = value
    def _hasContent(self):
        if (
            self.display_text or
            self.accidental_text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='notehead-text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('notehead-text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'notehead-text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='notehead-text')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='notehead-text', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='notehead-text'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='notehead-text', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for display_text_ in self.display_text:
            namespaceprefix_ = self.display_text_nsprefix_ + ':' if (UseCapturedNS_ and self.display_text_nsprefix_) else ''
            display_text_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='display-text', pretty_print=pretty_print)
        for accidental_text_ in self.accidental_text:
            namespaceprefix_ = self.accidental_text_nsprefix_ + ':' if (UseCapturedNS_ and self.accidental_text_nsprefix_) else ''
            accidental_text_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accidental-text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'display-text':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.display_text.append(obj_)
            obj_.original_tagname_ = 'display-text'
        elif nodeName_ == 'accidental-text':
            obj_ = accidental_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accidental_text.append(obj_)
            obj_.original_tagname_ = 'accidental-text'
# end class notehead_text


class ornaments(GeneratedsSuper):
    """trill-mark -- The trill-mark element represents the trill-mark symbol.
    turn -- The turn element is the normal turn shape which goes up then down.
    delayed-turn -- The delayed-turn element indicates a normal turn that is delayed until the end of the current note.
    inverted-turn -- The inverted-turn element has the shape which goes down and then up.
    delayed-inverted-turn -- The delayed-inverted-turn element indicates an inverted turn that is delayed until the end of the current note.
    vertical-turn -- The vertical-turn element has the turn symbol shape arranged vertically going from upper left to lower right.
    inverted-vertical-turn -- The inverted-vertical-turn element has the turn symbol shape arranged vertically going from upper right to lower left.
    shake -- The shake element has a similar appearance to an inverted-mordent element.
    mordent -- The mordent element represents the sign with the vertical line. The choice of which mordent sign is inverted differs between MusicXML and SMuFL. The long attribute is "no" by default.
    inverted-mordent -- The inverted-mordent element represents the sign without the vertical line. The choice of which mordent is inverted differs between MusicXML and SMuFL. The long attribute is "no" by default.
    schleifer -- The name for this ornament is based on the German, to avoid confusion with the more common slide element defined earlier.
    haydn -- The haydn element represents the Haydn ornament. This is defined in SMuFL as ornamentHaydn.
    other-ornament -- The other-ornament element is used to define any ornaments not yet in the MusicXML format. The smufl attribute can be used to specify a particular ornament, allowing application interoperability without requiring every SMuFL ornament to have a MusicXML element equivalent. Using the other-ornament element without the smufl attribute allows for extended representation, though without application interoperability.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, trill_mark=None, turn=None, delayed_turn=None, inverted_turn=None, delayed_inverted_turn=None, vertical_turn=None, inverted_vertical_turn=None, shake=None, wavy_line=None, mordent=None, inverted_mordent=None, schleifer=None, tremolo=None, haydn=None, other_ornament=None, accidental_mark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if trill_mark is None:
            self.trill_mark = []
        else:
            self.trill_mark = trill_mark
        self.trill_mark_nsprefix_ = None
        if turn is None:
            self.turn = []
        else:
            self.turn = turn
        self.turn_nsprefix_ = None
        if delayed_turn is None:
            self.delayed_turn = []
        else:
            self.delayed_turn = delayed_turn
        self.delayed_turn_nsprefix_ = None
        if inverted_turn is None:
            self.inverted_turn = []
        else:
            self.inverted_turn = inverted_turn
        self.inverted_turn_nsprefix_ = None
        if delayed_inverted_turn is None:
            self.delayed_inverted_turn = []
        else:
            self.delayed_inverted_turn = delayed_inverted_turn
        self.delayed_inverted_turn_nsprefix_ = None
        if vertical_turn is None:
            self.vertical_turn = []
        else:
            self.vertical_turn = vertical_turn
        self.vertical_turn_nsprefix_ = None
        if inverted_vertical_turn is None:
            self.inverted_vertical_turn = []
        else:
            self.inverted_vertical_turn = inverted_vertical_turn
        self.inverted_vertical_turn_nsprefix_ = None
        if shake is None:
            self.shake = []
        else:
            self.shake = shake
        self.shake_nsprefix_ = None
        if wavy_line is None:
            self.wavy_line = []
        else:
            self.wavy_line = wavy_line
        self.wavy_line_nsprefix_ = None
        if mordent is None:
            self.mordent = []
        else:
            self.mordent = mordent
        self.mordent_nsprefix_ = None
        if inverted_mordent is None:
            self.inverted_mordent = []
        else:
            self.inverted_mordent = inverted_mordent
        self.inverted_mordent_nsprefix_ = None
        if schleifer is None:
            self.schleifer = []
        else:
            self.schleifer = schleifer
        self.schleifer_nsprefix_ = None
        if tremolo is None:
            self.tremolo = []
        else:
            self.tremolo = tremolo
        self.tremolo_nsprefix_ = None
        if haydn is None:
            self.haydn = []
        else:
            self.haydn = haydn
        self.haydn_nsprefix_ = None
        if other_ornament is None:
            self.other_ornament = []
        else:
            self.other_ornament = other_ornament
        self.other_ornament_nsprefix_ = None
        if accidental_mark is None:
            self.accidental_mark = []
        else:
            self.accidental_mark = accidental_mark
        self.accidental_mark_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ornaments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ornaments.subclass:
            return ornaments.subclass(*args_, **kwargs_)
        else:
            return ornaments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_trill_mark(self):
        return self.trill_mark
    def set_trill_mark(self, trill_mark):
        self.trill_mark = trill_mark
    def add_trill_mark(self, value):
        self.trill_mark.append(value)
    def insert_trill_mark_at(self, index, value):
        self.trill_mark.insert(index, value)
    def replace_trill_mark_at(self, index, value):
        self.trill_mark[index] = value
    def get_turn(self):
        return self.turn
    def set_turn(self, turn):
        self.turn = turn
    def add_turn(self, value):
        self.turn.append(value)
    def insert_turn_at(self, index, value):
        self.turn.insert(index, value)
    def replace_turn_at(self, index, value):
        self.turn[index] = value
    def get_delayed_turn(self):
        return self.delayed_turn
    def set_delayed_turn(self, delayed_turn):
        self.delayed_turn = delayed_turn
    def add_delayed_turn(self, value):
        self.delayed_turn.append(value)
    def insert_delayed_turn_at(self, index, value):
        self.delayed_turn.insert(index, value)
    def replace_delayed_turn_at(self, index, value):
        self.delayed_turn[index] = value
    def get_inverted_turn(self):
        return self.inverted_turn
    def set_inverted_turn(self, inverted_turn):
        self.inverted_turn = inverted_turn
    def add_inverted_turn(self, value):
        self.inverted_turn.append(value)
    def insert_inverted_turn_at(self, index, value):
        self.inverted_turn.insert(index, value)
    def replace_inverted_turn_at(self, index, value):
        self.inverted_turn[index] = value
    def get_delayed_inverted_turn(self):
        return self.delayed_inverted_turn
    def set_delayed_inverted_turn(self, delayed_inverted_turn):
        self.delayed_inverted_turn = delayed_inverted_turn
    def add_delayed_inverted_turn(self, value):
        self.delayed_inverted_turn.append(value)
    def insert_delayed_inverted_turn_at(self, index, value):
        self.delayed_inverted_turn.insert(index, value)
    def replace_delayed_inverted_turn_at(self, index, value):
        self.delayed_inverted_turn[index] = value
    def get_vertical_turn(self):
        return self.vertical_turn
    def set_vertical_turn(self, vertical_turn):
        self.vertical_turn = vertical_turn
    def add_vertical_turn(self, value):
        self.vertical_turn.append(value)
    def insert_vertical_turn_at(self, index, value):
        self.vertical_turn.insert(index, value)
    def replace_vertical_turn_at(self, index, value):
        self.vertical_turn[index] = value
    def get_inverted_vertical_turn(self):
        return self.inverted_vertical_turn
    def set_inverted_vertical_turn(self, inverted_vertical_turn):
        self.inverted_vertical_turn = inverted_vertical_turn
    def add_inverted_vertical_turn(self, value):
        self.inverted_vertical_turn.append(value)
    def insert_inverted_vertical_turn_at(self, index, value):
        self.inverted_vertical_turn.insert(index, value)
    def replace_inverted_vertical_turn_at(self, index, value):
        self.inverted_vertical_turn[index] = value
    def get_shake(self):
        return self.shake
    def set_shake(self, shake):
        self.shake = shake
    def add_shake(self, value):
        self.shake.append(value)
    def insert_shake_at(self, index, value):
        self.shake.insert(index, value)
    def replace_shake_at(self, index, value):
        self.shake[index] = value
    def get_wavy_line(self):
        return self.wavy_line
    def set_wavy_line(self, wavy_line):
        self.wavy_line = wavy_line
    def add_wavy_line(self, value):
        self.wavy_line.append(value)
    def insert_wavy_line_at(self, index, value):
        self.wavy_line.insert(index, value)
    def replace_wavy_line_at(self, index, value):
        self.wavy_line[index] = value
    def get_mordent(self):
        return self.mordent
    def set_mordent(self, mordent):
        self.mordent = mordent
    def add_mordent(self, value):
        self.mordent.append(value)
    def insert_mordent_at(self, index, value):
        self.mordent.insert(index, value)
    def replace_mordent_at(self, index, value):
        self.mordent[index] = value
    def get_inverted_mordent(self):
        return self.inverted_mordent
    def set_inverted_mordent(self, inverted_mordent):
        self.inverted_mordent = inverted_mordent
    def add_inverted_mordent(self, value):
        self.inverted_mordent.append(value)
    def insert_inverted_mordent_at(self, index, value):
        self.inverted_mordent.insert(index, value)
    def replace_inverted_mordent_at(self, index, value):
        self.inverted_mordent[index] = value
    def get_schleifer(self):
        return self.schleifer
    def set_schleifer(self, schleifer):
        self.schleifer = schleifer
    def add_schleifer(self, value):
        self.schleifer.append(value)
    def insert_schleifer_at(self, index, value):
        self.schleifer.insert(index, value)
    def replace_schleifer_at(self, index, value):
        self.schleifer[index] = value
    def get_tremolo(self):
        return self.tremolo
    def set_tremolo(self, tremolo):
        self.tremolo = tremolo
    def add_tremolo(self, value):
        self.tremolo.append(value)
    def insert_tremolo_at(self, index, value):
        self.tremolo.insert(index, value)
    def replace_tremolo_at(self, index, value):
        self.tremolo[index] = value
    def get_haydn(self):
        return self.haydn
    def set_haydn(self, haydn):
        self.haydn = haydn
    def add_haydn(self, value):
        self.haydn.append(value)
    def insert_haydn_at(self, index, value):
        self.haydn.insert(index, value)
    def replace_haydn_at(self, index, value):
        self.haydn[index] = value
    def get_other_ornament(self):
        return self.other_ornament
    def set_other_ornament(self, other_ornament):
        self.other_ornament = other_ornament
    def add_other_ornament(self, value):
        self.other_ornament.append(value)
    def insert_other_ornament_at(self, index, value):
        self.other_ornament.insert(index, value)
    def replace_other_ornament_at(self, index, value):
        self.other_ornament[index] = value
    def get_accidental_mark(self):
        return self.accidental_mark
    def set_accidental_mark(self, accidental_mark):
        self.accidental_mark = accidental_mark
    def add_accidental_mark(self, value):
        self.accidental_mark.append(value)
    def insert_accidental_mark_at(self, index, value):
        self.accidental_mark.insert(index, value)
    def replace_accidental_mark_at(self, index, value):
        self.accidental_mark[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.trill_mark or
            self.turn or
            self.delayed_turn or
            self.inverted_turn or
            self.delayed_inverted_turn or
            self.vertical_turn or
            self.inverted_vertical_turn or
            self.shake or
            self.wavy_line or
            self.mordent or
            self.inverted_mordent or
            self.schleifer or
            self.tremolo or
            self.haydn or
            self.other_ornament or
            self.accidental_mark
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ornaments', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ornaments')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ornaments':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ornaments')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ornaments', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ornaments'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ornaments', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for trill_mark_ in self.trill_mark:
            namespaceprefix_ = self.trill_mark_nsprefix_ + ':' if (UseCapturedNS_ and self.trill_mark_nsprefix_) else ''
            trill_mark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='trill-mark', pretty_print=pretty_print)
        for turn_ in self.turn:
            namespaceprefix_ = self.turn_nsprefix_ + ':' if (UseCapturedNS_ and self.turn_nsprefix_) else ''
            turn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='turn', pretty_print=pretty_print)
        for delayed_turn_ in self.delayed_turn:
            namespaceprefix_ = self.delayed_turn_nsprefix_ + ':' if (UseCapturedNS_ and self.delayed_turn_nsprefix_) else ''
            delayed_turn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delayed-turn', pretty_print=pretty_print)
        for inverted_turn_ in self.inverted_turn:
            namespaceprefix_ = self.inverted_turn_nsprefix_ + ':' if (UseCapturedNS_ and self.inverted_turn_nsprefix_) else ''
            inverted_turn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inverted-turn', pretty_print=pretty_print)
        for delayed_inverted_turn_ in self.delayed_inverted_turn:
            namespaceprefix_ = self.delayed_inverted_turn_nsprefix_ + ':' if (UseCapturedNS_ and self.delayed_inverted_turn_nsprefix_) else ''
            delayed_inverted_turn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delayed-inverted-turn', pretty_print=pretty_print)
        for vertical_turn_ in self.vertical_turn:
            namespaceprefix_ = self.vertical_turn_nsprefix_ + ':' if (UseCapturedNS_ and self.vertical_turn_nsprefix_) else ''
            vertical_turn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vertical-turn', pretty_print=pretty_print)
        for inverted_vertical_turn_ in self.inverted_vertical_turn:
            namespaceprefix_ = self.inverted_vertical_turn_nsprefix_ + ':' if (UseCapturedNS_ and self.inverted_vertical_turn_nsprefix_) else ''
            inverted_vertical_turn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inverted-vertical-turn', pretty_print=pretty_print)
        for shake_ in self.shake:
            namespaceprefix_ = self.shake_nsprefix_ + ':' if (UseCapturedNS_ and self.shake_nsprefix_) else ''
            shake_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shake', pretty_print=pretty_print)
        for wavy_line_ in self.wavy_line:
            namespaceprefix_ = self.wavy_line_nsprefix_ + ':' if (UseCapturedNS_ and self.wavy_line_nsprefix_) else ''
            wavy_line_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wavy-line', pretty_print=pretty_print)
        for mordent_ in self.mordent:
            namespaceprefix_ = self.mordent_nsprefix_ + ':' if (UseCapturedNS_ and self.mordent_nsprefix_) else ''
            mordent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mordent', pretty_print=pretty_print)
        for inverted_mordent_ in self.inverted_mordent:
            namespaceprefix_ = self.inverted_mordent_nsprefix_ + ':' if (UseCapturedNS_ and self.inverted_mordent_nsprefix_) else ''
            inverted_mordent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inverted-mordent', pretty_print=pretty_print)
        for schleifer_ in self.schleifer:
            namespaceprefix_ = self.schleifer_nsprefix_ + ':' if (UseCapturedNS_ and self.schleifer_nsprefix_) else ''
            schleifer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='schleifer', pretty_print=pretty_print)
        for tremolo_ in self.tremolo:
            namespaceprefix_ = self.tremolo_nsprefix_ + ':' if (UseCapturedNS_ and self.tremolo_nsprefix_) else ''
            tremolo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tremolo', pretty_print=pretty_print)
        for haydn_ in self.haydn:
            namespaceprefix_ = self.haydn_nsprefix_ + ':' if (UseCapturedNS_ and self.haydn_nsprefix_) else ''
            haydn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='haydn', pretty_print=pretty_print)
        for other_ornament_ in self.other_ornament:
            namespaceprefix_ = self.other_ornament_nsprefix_ + ':' if (UseCapturedNS_ and self.other_ornament_nsprefix_) else ''
            other_ornament_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-ornament', pretty_print=pretty_print)
        for accidental_mark_ in self.accidental_mark:
            namespaceprefix_ = self.accidental_mark_nsprefix_ + ':' if (UseCapturedNS_ and self.accidental_mark_nsprefix_) else ''
            accidental_mark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accidental-mark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'trill-mark':
            obj_ = empty_trill_sound.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.trill_mark.append(obj_)
            obj_.original_tagname_ = 'trill-mark'
        elif nodeName_ == 'turn':
            obj_ = horizontal_turn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.turn.append(obj_)
            obj_.original_tagname_ = 'turn'
        elif nodeName_ == 'delayed-turn':
            obj_ = horizontal_turn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delayed_turn.append(obj_)
            obj_.original_tagname_ = 'delayed-turn'
        elif nodeName_ == 'inverted-turn':
            obj_ = horizontal_turn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inverted_turn.append(obj_)
            obj_.original_tagname_ = 'inverted-turn'
        elif nodeName_ == 'delayed-inverted-turn':
            obj_ = horizontal_turn.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delayed_inverted_turn.append(obj_)
            obj_.original_tagname_ = 'delayed-inverted-turn'
        elif nodeName_ == 'vertical-turn':
            obj_ = empty_trill_sound.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vertical_turn.append(obj_)
            obj_.original_tagname_ = 'vertical-turn'
        elif nodeName_ == 'inverted-vertical-turn':
            obj_ = empty_trill_sound.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inverted_vertical_turn.append(obj_)
            obj_.original_tagname_ = 'inverted-vertical-turn'
        elif nodeName_ == 'shake':
            obj_ = empty_trill_sound.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shake.append(obj_)
            obj_.original_tagname_ = 'shake'
        elif nodeName_ == 'wavy-line':
            obj_ = wavy_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wavy_line.append(obj_)
            obj_.original_tagname_ = 'wavy-line'
        elif nodeName_ == 'mordent':
            obj_ = mordent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mordent.append(obj_)
            obj_.original_tagname_ = 'mordent'
        elif nodeName_ == 'inverted-mordent':
            obj_ = mordent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inverted_mordent.append(obj_)
            obj_.original_tagname_ = 'inverted-mordent'
        elif nodeName_ == 'schleifer':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.schleifer.append(obj_)
            obj_.original_tagname_ = 'schleifer'
        elif nodeName_ == 'tremolo':
            obj_ = tremolo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tremolo.append(obj_)
            obj_.original_tagname_ = 'tremolo'
        elif nodeName_ == 'haydn':
            obj_ = empty_trill_sound.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.haydn.append(obj_)
            obj_.original_tagname_ = 'haydn'
        elif nodeName_ == 'other-ornament':
            obj_ = other_placement_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_ornament.append(obj_)
            obj_.original_tagname_ = 'other-ornament'
        elif nodeName_ == 'accidental-mark':
            obj_ = accidental_mark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accidental_mark.append(obj_)
            obj_.original_tagname_ = 'accidental-mark'
# end class ornaments


class other_notation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number='1', print_object=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, smufl=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, other_notation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if other_notation.subclass:
            return other_notation.subclass(*args_, **kwargs_)
        else:
            return other_notation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_start_stop_single(self, value):
        # Validate type start-stop-single, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'single']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-single' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_smufl_glyph_name(self, value):
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-notation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('other-notation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'other-notation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='other-notation')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='other-notation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='other-notation'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number != 1 and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smufl), input_name='smufl')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-notation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_single(self.type_)    # validate type start-stop-single
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_glyph_name(self.smufl)    # validate type smufl-glyph-name
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class other_notation


class other_placement_text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, other_placement_text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if other_placement_text.subclass:
            return other_placement_text.subclass(*args_, **kwargs_)
        else:
            return other_placement_text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_smufl_glyph_name(self, value):
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-placement-text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('other-placement-text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'other-placement-text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='other-placement-text')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='other-placement-text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='other-placement-text'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smufl), input_name='smufl')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-placement-text', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_glyph_name(self.smufl)    # validate type smufl-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class other_placement_text


class other_text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, other_text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if other_text.subclass:
            return other_text.subclass(*args_, **kwargs_)
        else:
            return other_text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_smufl_glyph_name(self, value):
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('other-text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'other-text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='other-text')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='other-text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='other-text'):
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smufl), input_name='smufl')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='other-text', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_glyph_name(self.smufl)    # validate type smufl-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class other_text


class pitch(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, step=None, alter=None, octave=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.step = step
        self.validate_step(self.step)
        self.step_nsprefix_ = None
        self.alter = alter
        self.validate_semitones(self.alter)
        self.alter_nsprefix_ = None
        self.octave = octave
        self.validate_octave(self.octave)
        self.octave_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pitch)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pitch.subclass:
            return pitch.subclass(*args_, **kwargs_)
        else:
            return pitch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_step(self):
        return self.step
    def set_step(self, step):
        self.step = step
    def get_alter(self):
        return self.alter
    def set_alter(self, alter):
        self.alter = alter
    def get_octave(self):
        return self.octave
    def set_octave(self, octave):
        self.octave = octave
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_semitones(self, value):
        result = True
        # Validate type semitones, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_octave(self, value):
        result = True
        # Validate type octave, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
            if value > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.step is not None or
            self.alter is not None or
            self.octave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pitch', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pitch')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pitch':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pitch')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pitch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pitch'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pitch', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.step is not None:
            namespaceprefix_ = self.step_nsprefix_ + ':' if (UseCapturedNS_ and self.step_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstep>%s</%sstep>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.step), input_name='step')), namespaceprefix_ , eol_))
        if self.alter is not None:
            namespaceprefix_ = self.alter_nsprefix_ + ':' if (UseCapturedNS_ and self.alter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salter>%s</%salter>%s' % (namespaceprefix_ , self.gds_format_decimal(self.alter, input_name='alter'), namespaceprefix_ , eol_))
        if self.octave is not None:
            namespaceprefix_ = self.octave_nsprefix_ + ':' if (UseCapturedNS_ and self.octave_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soctave>%s</%soctave>%s' % (namespaceprefix_ , self.gds_format_integer(self.octave, input_name='octave'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'step':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'step')
            value_ = self.gds_validate_string(value_, node, 'step')
            self.step = value_
            self.step_nsprefix_ = child_.prefix
            # validate type step
            self.validate_step(self.step)
        elif nodeName_ == 'alter' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'alter')
            fval_ = self.gds_validate_decimal(fval_, node, 'alter')
            self.alter = fval_
            self.alter_nsprefix_ = child_.prefix
            # validate type semitones
            self.validate_semitones(self.alter)
        elif nodeName_ == 'octave' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'octave')
            ival_ = self.gds_validate_integer(ival_, node, 'octave')
            self.octave = ival_
            self.octave_nsprefix_ = child_.prefix
            # validate type octave
            self.validate_octave(self.octave)
# end class pitch


class placement_text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placement_text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placement_text.subclass:
            return placement_text.subclass(*args_, **kwargs_)
        else:
            return placement_text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='placement-text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('placement-text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'placement-text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='placement-text')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='placement-text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='placement-text'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='placement-text', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class placement_text


class release(empty):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = empty
    def __init__(self, offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("release"), self).__init__( **kwargs_)
        self.offset = _cast(float, offset)
        self.offset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release.subclass:
            return release.subclass(*args_, **kwargs_)
        else:
            return release(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def _hasContent(self):
        if (
            super(release, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='release', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('release')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'release':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='release')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='release', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='release'):
        super(release, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='release')
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_decimal(self.offset, input_name='offset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='release', fromsubclass_=False, pretty_print=True):
        super(release, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            value = self.gds_parse_decimal(value, node, 'offset')
            self.offset = value
        super(release, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(release, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class release


class rest(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, measure=None, display_step=None, display_octave=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.measure = _cast(None, measure)
        self.measure_nsprefix_ = None
        self.display_step = display_step
        self.validate_step(self.display_step)
        self.display_step_nsprefix_ = None
        self.display_octave = display_octave
        self.validate_octave(self.display_octave)
        self.display_octave_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rest.subclass:
            return rest.subclass(*args_, **kwargs_)
        else:
            return rest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_display_step(self):
        return self.display_step
    def set_display_step(self, display_step):
        self.display_step = display_step
    def get_display_octave(self):
        return self.display_octave
    def set_display_octave(self, display_octave):
        self.display_octave = display_octave
    def get_measure(self):
        return self.measure
    def set_measure(self, measure):
        self.measure = measure
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_octave(self, value):
        result = True
        # Validate type octave, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
            if value > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.display_step is not None or
            self.display_octave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rest'):
        if self.measure is not None and 'measure' not in already_processed:
            already_processed.add('measure')
            outfile.write(' measure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.measure), input_name='measure')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.display_step is not None:
            namespaceprefix_ = self.display_step_nsprefix_ + ':' if (UseCapturedNS_ and self.display_step_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplay-step>%s</%sdisplay-step>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.display_step), input_name='display-step')), namespaceprefix_ , eol_))
        if self.display_octave is not None:
            namespaceprefix_ = self.display_octave_nsprefix_ + ':' if (UseCapturedNS_ and self.display_octave_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplay-octave>%s</%sdisplay-octave>%s' % (namespaceprefix_ , self.gds_format_integer(self.display_octave, input_name='display-octave'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('measure', node)
        if value is not None and 'measure' not in already_processed:
            already_processed.add('measure')
            self.measure = value
            self.measure = ' '.join(self.measure.split())
            self.validate_yes_no(self.measure)    # validate type yes-no
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'display-step':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'display_step')
            value_ = self.gds_validate_string(value_, node, 'display_step')
            self.display_step = value_
            self.display_step_nsprefix_ = child_.prefix
            # validate type step
            self.validate_step(self.display_step)
        elif nodeName_ == 'display-octave' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'display_octave')
            ival_ = self.gds_validate_integer(ival_, node, 'display_octave')
            self.display_octave = ival_
            self.display_octave_nsprefix_ = child_.prefix
            # validate type octave
            self.validate_octave(self.display_octave)
# end class rest


class slide(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number='1', line_type=None, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, accelerate=None, beats=None, first_beat=None, last_beat=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.line_type = _cast(None, line_type)
        self.line_type_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.accelerate = _cast(None, accelerate)
        self.accelerate_nsprefix_ = None
        self.beats = _cast(float, beats)
        self.beats_nsprefix_ = None
        self.first_beat = _cast(float, first_beat)
        self.first_beat_nsprefix_ = None
        self.last_beat = _cast(float, last_beat)
        self.last_beat_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, slide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if slide.subclass:
            return slide.subclass(*args_, **kwargs_)
        else:
            return slide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_line_type(self):
        return self.line_type
    def set_line_type(self, line_type):
        self.line_type = line_type
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_accelerate(self):
        return self.accelerate
    def set_accelerate(self, accelerate):
        self.accelerate = accelerate
    def get_beats(self):
        return self.beats
    def set_beats(self, beats):
        self.beats = beats
    def get_first_beat(self):
        return self.first_beat
    def set_first_beat(self, first_beat):
        self.first_beat = first_beat
    def get_last_beat(self):
        return self.last_beat
    def set_last_beat(self, last_beat):
        self.last_beat = last_beat
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_line_type(self, value):
        # Validate type line-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['solid', 'dashed', 'dotted', 'wavy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_trill_beats(self, value):
        # Validate type trill-beats, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on trill-beats' % {"value": value, "lineno": lineno} )
                result = False
    def validate_percent(self, value):
        # Validate type percent, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on percent' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='slide', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'slide':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='slide')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='slide', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='slide'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number != 1 and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.line_type is not None and 'line_type' not in already_processed:
            already_processed.add('line_type')
            outfile.write(' line-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_type), input_name='line-type')), ))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.accelerate is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            outfile.write(' accelerate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accelerate), input_name='accelerate')), ))
        if self.beats is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            outfile.write(' beats="%s"' % self.gds_format_decimal(self.beats, input_name='beats'))
        if self.first_beat is not None and 'first_beat' not in already_processed:
            already_processed.add('first_beat')
            outfile.write(' first-beat="%s"' % self.gds_format_decimal(self.first_beat, input_name='first-beat'))
        if self.last_beat is not None and 'last_beat' not in already_processed:
            already_processed.add('last_beat')
            outfile.write(' last-beat="%s"' % self.gds_format_decimal(self.last_beat, input_name='last-beat'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='slide', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('line-type', node)
        if value is not None and 'line-type' not in already_processed:
            already_processed.add('line-type')
            self.line_type = value
            self.line_type = ' '.join(self.line_type.split())
            self.validate_line_type(self.line_type)    # validate type line-type
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('accelerate', node)
        if value is not None and 'accelerate' not in already_processed:
            already_processed.add('accelerate')
            self.accelerate = value
            self.accelerate = ' '.join(self.accelerate.split())
            self.validate_yes_no(self.accelerate)    # validate type yes-no
        value = find_attr_value_('beats', node)
        if value is not None and 'beats' not in already_processed:
            already_processed.add('beats')
            value = self.gds_parse_decimal(value, node, 'beats')
            self.beats = value
            self.validate_trill_beats(self.beats)    # validate type trill-beats
        value = find_attr_value_('first-beat', node)
        if value is not None and 'first-beat' not in already_processed:
            already_processed.add('first-beat')
            value = self.gds_parse_decimal(value, node, 'first-beat')
            self.first_beat = value
            self.validate_percent(self.first_beat)    # validate type percent
        value = find_attr_value_('last-beat', node)
        if value is not None and 'last-beat' not in already_processed:
            already_processed.add('last-beat')
            value = self.gds_parse_decimal(value, node, 'last-beat')
            self.last_beat = value
            self.validate_percent(self.last_beat)    # validate type percent
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class slide


class slur(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number='1', line_type=None, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, placement=None, orientation=None, bezier_x=None, bezier_y=None, bezier_x2=None, bezier_y2=None, bezier_offset=None, bezier_offset2=None, color=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.line_type = _cast(None, line_type)
        self.line_type_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.bezier_x = _cast(float, bezier_x)
        self.bezier_x_nsprefix_ = None
        self.bezier_y = _cast(float, bezier_y)
        self.bezier_y_nsprefix_ = None
        self.bezier_x2 = _cast(float, bezier_x2)
        self.bezier_x2_nsprefix_ = None
        self.bezier_y2 = _cast(float, bezier_y2)
        self.bezier_y2_nsprefix_ = None
        self.bezier_offset = _cast(float, bezier_offset)
        self.bezier_offset_nsprefix_ = None
        self.bezier_offset2 = _cast(float, bezier_offset2)
        self.bezier_offset2_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, slur)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if slur.subclass:
            return slur.subclass(*args_, **kwargs_)
        else:
            return slur(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_line_type(self):
        return self.line_type
    def set_line_type(self, line_type):
        self.line_type = line_type
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_bezier_x(self):
        return self.bezier_x
    def set_bezier_x(self, bezier_x):
        self.bezier_x = bezier_x
    def get_bezier_y(self):
        return self.bezier_y
    def set_bezier_y(self, bezier_y):
        self.bezier_y = bezier_y
    def get_bezier_x2(self):
        return self.bezier_x2
    def set_bezier_x2(self, bezier_x2):
        self.bezier_x2 = bezier_x2
    def get_bezier_y2(self):
        return self.bezier_y2
    def set_bezier_y2(self, bezier_y2):
        self.bezier_y2 = bezier_y2
    def get_bezier_offset(self):
        return self.bezier_offset
    def set_bezier_offset(self, bezier_offset):
        self.bezier_offset = bezier_offset
    def get_bezier_offset2(self):
        return self.bezier_offset2
    def set_bezier_offset2(self, bezier_offset2):
        self.bezier_offset2 = bezier_offset2
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_start_stop_continue(self, value):
        # Validate type start-stop-continue, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'continue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop-continue' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_line_type(self, value):
        # Validate type line-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['solid', 'dashed', 'dotted', 'wavy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_over_under(self, value):
        # Validate type over-under, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['over', 'under']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on over-under' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='slur', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slur')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'slur':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='slur')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='slur', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='slur'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number != 1 and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.line_type is not None and 'line_type' not in already_processed:
            already_processed.add('line_type')
            outfile.write(' line-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_type), input_name='line-type')), ))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.bezier_x is not None and 'bezier_x' not in already_processed:
            already_processed.add('bezier_x')
            outfile.write(' bezier-x="%s"' % self.gds_format_decimal(self.bezier_x, input_name='bezier-x'))
        if self.bezier_y is not None and 'bezier_y' not in already_processed:
            already_processed.add('bezier_y')
            outfile.write(' bezier-y="%s"' % self.gds_format_decimal(self.bezier_y, input_name='bezier-y'))
        if self.bezier_x2 is not None and 'bezier_x2' not in already_processed:
            already_processed.add('bezier_x2')
            outfile.write(' bezier-x2="%s"' % self.gds_format_decimal(self.bezier_x2, input_name='bezier-x2'))
        if self.bezier_y2 is not None and 'bezier_y2' not in already_processed:
            already_processed.add('bezier_y2')
            outfile.write(' bezier-y2="%s"' % self.gds_format_decimal(self.bezier_y2, input_name='bezier-y2'))
        if self.bezier_offset is not None and 'bezier_offset' not in already_processed:
            already_processed.add('bezier_offset')
            outfile.write(' bezier-offset="%s"' % self.gds_format_decimal(self.bezier_offset, input_name='bezier-offset'))
        if self.bezier_offset2 is not None and 'bezier_offset2' not in already_processed:
            already_processed.add('bezier_offset2')
            outfile.write(' bezier-offset2="%s"' % self.gds_format_decimal(self.bezier_offset2, input_name='bezier-offset2'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='slur', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop_continue(self.type_)    # validate type start-stop-continue
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('line-type', node)
        if value is not None and 'line-type' not in already_processed:
            already_processed.add('line-type')
            self.line_type = value
            self.line_type = ' '.join(self.line_type.split())
            self.validate_line_type(self.line_type)    # validate type line-type
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.orientation = ' '.join(self.orientation.split())
            self.validate_over_under(self.orientation)    # validate type over-under
        value = find_attr_value_('bezier-x', node)
        if value is not None and 'bezier-x' not in already_processed:
            already_processed.add('bezier-x')
            value = self.gds_parse_decimal(value, node, 'bezier-x')
            self.bezier_x = value
        value = find_attr_value_('bezier-y', node)
        if value is not None and 'bezier-y' not in already_processed:
            already_processed.add('bezier-y')
            value = self.gds_parse_decimal(value, node, 'bezier-y')
            self.bezier_y = value
        value = find_attr_value_('bezier-x2', node)
        if value is not None and 'bezier-x2' not in already_processed:
            already_processed.add('bezier-x2')
            value = self.gds_parse_decimal(value, node, 'bezier-x2')
            self.bezier_x2 = value
        value = find_attr_value_('bezier-y2', node)
        if value is not None and 'bezier-y2' not in already_processed:
            already_processed.add('bezier-y2')
            value = self.gds_parse_decimal(value, node, 'bezier-y2')
            self.bezier_y2 = value
        value = find_attr_value_('bezier-offset', node)
        if value is not None and 'bezier-offset' not in already_processed:
            already_processed.add('bezier-offset')
            value = self.gds_parse_decimal(value, node, 'bezier-offset')
            self.bezier_offset = value
        value = find_attr_value_('bezier-offset2', node)
        if value is not None and 'bezier-offset2' not in already_processed:
            already_processed.add('bezier-offset2')
            value = self.gds_parse_decimal(value, node, 'bezier-offset2')
            self.bezier_offset2 = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class slur


class stem(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stem.subclass:
            return stem.subclass(*args_, **kwargs_)
        else:
            return stem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_stem_value(self, value):
        result = True
        # Validate type stem-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['down', 'up', 'double', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on stem-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'stem':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stem')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='stem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='stem'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class stem


class strong_accent(empty_placement):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = empty_placement
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, type_='up', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("strong_accent"), self).__init__(default_x, default_y, relative_x, relative_y, font_family, font_style, font_size, font_weight, color, placement,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, strong_accent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if strong_accent.subclass:
            return strong_accent.subclass(*args_, **kwargs_)
        else:
            return strong_accent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_up_down(self, value):
        # Validate type up-down, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['up', 'down']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on up-down' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            super(strong_accent, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='strong-accent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('strong-accent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'strong-accent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='strong-accent')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='strong-accent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='strong-accent'):
        super(strong_accent, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='strong-accent')
        if self.type_ != "up" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='strong-accent', fromsubclass_=False, pretty_print=True):
        super(strong_accent, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_up_down(self.type_)    # validate type up-down
        super(strong_accent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(strong_accent, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class strong_accent


class style_text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, style_text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if style_text.subclass:
            return style_text.subclass(*args_, **kwargs_)
        else:
            return style_text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='style-text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('style-text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'style-text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='style-text')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='style-text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='style-text'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='style-text', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class style_text


class tap(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, hand=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.hand = _cast(None, hand)
        self.hand_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tap.subclass:
            return tap.subclass(*args_, **kwargs_)
        else:
            return tap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_hand(self):
        return self.hand
    def set_hand(self, hand):
        self.hand = hand
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tap_hand(self, value):
        # Validate type tap-hand, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tap-hand' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tap', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tap':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tap')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tap', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tap'):
        if self.hand is not None and 'hand' not in already_processed:
            already_processed.add('hand')
            outfile.write(' hand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hand), input_name='hand')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tap', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hand', node)
        if value is not None and 'hand' not in already_processed:
            already_processed.add('hand')
            self.hand = value
            self.validate_tap_hand(self.hand)    # validate type tap-hand
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tap


class technical(GeneratedsSuper):
    """up-bow -- The up-bow element represents the symbol that is used both for up-bowing on bowed instruments, and up-stroke on plucked instruments.
    down-bow -- The down-bow element represents the symbol that is used both for down-bowing on bowed instruments, and down-stroke on plucked instruments.
    open-string -- The open-string element represents the zero-shaped open string symbol.
    thumb-position -- The thumb-position element represents the thumb position symbol. This is a circle with a line, where the line does not come within the circle. It is distinct from the snap pizzicato symbol, where the line comes inside the circle.
    pluck -- The pluck element is used to specify the plucking fingering on a fretted instrument, where the fingering element refers to the fretting fingering. Typical values are p, i, m, a for pulgar/thumb, indicio/index, medio/middle, and anular/ring fingers.
    double-tongue -- The double-tongue element represents the double tongue symbol (two dots arranged horizontally).
    triple-tongue -- The triple-tongue element represents the triple tongue symbol (three dots arranged horizontally).
    stopped -- The stopped element represents the stopped symbol, which looks like a plus sign. The smufl attribute distinguishes different SMuFL glyphs that have a similar appearance such as handbellsMalletBellSuspended and guitarClosePedal. If not present, the default glyph is brassMuteClosed.
    snap-pizzicato -- The snap-pizzicato element represents the snap pizzicato symbol. This is a circle with a line, where the line comes inside the circle. It is distinct from the thumb-position symbol, where the line does not come inside the circle.
    fingernails -- The fingernails element is used in notation for harp and other plucked string instruments.
    brass-bend -- The brass-bend element represents the u-shaped bend symbol used in brass notation, distinct from the bend element used in guitar music.
    flip -- The flip element represents the flip symbol used in brass notation.
    smear -- The smear element represents the tilde-shaped smear symbol used in brass notation.
    open -- The open element represents the open symbol, which looks like a circle. The smufl attribute can be used to distinguish different SMuFL glyphs that have a similar appearance such as brassMuteOpen and guitarOpenPedal. If not present, the default glyph is brassMuteOpen.
    half-muted -- The half-muted element represents the half-muted symbol, which looks like a circle with a plus sign inside. The smufl attribute can be used to distinguish different SMuFL glyphs that have a similar appearance such as brassMuteHalfClosed and guitarHalfOpenPedal. If not present, the default glyph is brassMuteHalfClosed.
    golpe -- The golpe element represents the golpe symbol that is used for tapping the pick guard in guitar music.
    other-technical -- The other-technical element is used to define any technical indications not yet in the MusicXML format. The smufl attribute can be used to specify a particular glyph, allowing application interoperability without requiring every SMuFL technical indication to have a MusicXML element equivalent. Using the other-technical element without the smufl attribute allows for extended representation, though without application interoperability.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, up_bow=None, down_bow=None, harmonic=None, open_string=None, thumb_position=None, fingering=None, pluck=None, double_tongue=None, triple_tongue=None, stopped=None, snap_pizzicato=None, fret=None, string=None, hammer_on=None, pull_off=None, bend=None, tap=None, heel=None, toe=None, fingernails=None, hole=None, arrow=None, handbell=None, brass_bend=None, flip=None, smear=None, open=None, half_muted=None, harmon_mute=None, golpe=None, other_technical=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if up_bow is None:
            self.up_bow = []
        else:
            self.up_bow = up_bow
        self.up_bow_nsprefix_ = None
        if down_bow is None:
            self.down_bow = []
        else:
            self.down_bow = down_bow
        self.down_bow_nsprefix_ = None
        if harmonic is None:
            self.harmonic = []
        else:
            self.harmonic = harmonic
        self.harmonic_nsprefix_ = None
        if open_string is None:
            self.open_string = []
        else:
            self.open_string = open_string
        self.open_string_nsprefix_ = None
        if thumb_position is None:
            self.thumb_position = []
        else:
            self.thumb_position = thumb_position
        self.thumb_position_nsprefix_ = None
        if fingering is None:
            self.fingering = []
        else:
            self.fingering = fingering
        self.fingering_nsprefix_ = None
        if pluck is None:
            self.pluck = []
        else:
            self.pluck = pluck
        self.pluck_nsprefix_ = None
        if double_tongue is None:
            self.double_tongue = []
        else:
            self.double_tongue = double_tongue
        self.double_tongue_nsprefix_ = None
        if triple_tongue is None:
            self.triple_tongue = []
        else:
            self.triple_tongue = triple_tongue
        self.triple_tongue_nsprefix_ = None
        if stopped is None:
            self.stopped = []
        else:
            self.stopped = stopped
        self.stopped_nsprefix_ = None
        if snap_pizzicato is None:
            self.snap_pizzicato = []
        else:
            self.snap_pizzicato = snap_pizzicato
        self.snap_pizzicato_nsprefix_ = None
        if fret is None:
            self.fret = []
        else:
            self.fret = fret
        self.fret_nsprefix_ = None
        if string is None:
            self.string = []
        else:
            self.string = string
        self.string_nsprefix_ = None
        if hammer_on is None:
            self.hammer_on = []
        else:
            self.hammer_on = hammer_on
        self.hammer_on_nsprefix_ = None
        if pull_off is None:
            self.pull_off = []
        else:
            self.pull_off = pull_off
        self.pull_off_nsprefix_ = None
        if bend is None:
            self.bend = []
        else:
            self.bend = bend
        self.bend_nsprefix_ = None
        if tap is None:
            self.tap = []
        else:
            self.tap = tap
        self.tap_nsprefix_ = None
        if heel is None:
            self.heel = []
        else:
            self.heel = heel
        self.heel_nsprefix_ = None
        if toe is None:
            self.toe = []
        else:
            self.toe = toe
        self.toe_nsprefix_ = None
        if fingernails is None:
            self.fingernails = []
        else:
            self.fingernails = fingernails
        self.fingernails_nsprefix_ = None
        if hole is None:
            self.hole = []
        else:
            self.hole = hole
        self.hole_nsprefix_ = None
        if arrow is None:
            self.arrow = []
        else:
            self.arrow = arrow
        self.arrow_nsprefix_ = None
        if handbell is None:
            self.handbell = []
        else:
            self.handbell = handbell
        self.handbell_nsprefix_ = None
        if brass_bend is None:
            self.brass_bend = []
        else:
            self.brass_bend = brass_bend
        self.brass_bend_nsprefix_ = None
        if flip is None:
            self.flip = []
        else:
            self.flip = flip
        self.flip_nsprefix_ = None
        if smear is None:
            self.smear = []
        else:
            self.smear = smear
        self.smear_nsprefix_ = None
        if open is None:
            self.open = []
        else:
            self.open = open
        self.open_nsprefix_ = None
        if half_muted is None:
            self.half_muted = []
        else:
            self.half_muted = half_muted
        self.half_muted_nsprefix_ = None
        if harmon_mute is None:
            self.harmon_mute = []
        else:
            self.harmon_mute = harmon_mute
        self.harmon_mute_nsprefix_ = None
        if golpe is None:
            self.golpe = []
        else:
            self.golpe = golpe
        self.golpe_nsprefix_ = None
        if other_technical is None:
            self.other_technical = []
        else:
            self.other_technical = other_technical
        self.other_technical_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, technical)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if technical.subclass:
            return technical.subclass(*args_, **kwargs_)
        else:
            return technical(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_up_bow(self):
        return self.up_bow
    def set_up_bow(self, up_bow):
        self.up_bow = up_bow
    def add_up_bow(self, value):
        self.up_bow.append(value)
    def insert_up_bow_at(self, index, value):
        self.up_bow.insert(index, value)
    def replace_up_bow_at(self, index, value):
        self.up_bow[index] = value
    def get_down_bow(self):
        return self.down_bow
    def set_down_bow(self, down_bow):
        self.down_bow = down_bow
    def add_down_bow(self, value):
        self.down_bow.append(value)
    def insert_down_bow_at(self, index, value):
        self.down_bow.insert(index, value)
    def replace_down_bow_at(self, index, value):
        self.down_bow[index] = value
    def get_harmonic(self):
        return self.harmonic
    def set_harmonic(self, harmonic):
        self.harmonic = harmonic
    def add_harmonic(self, value):
        self.harmonic.append(value)
    def insert_harmonic_at(self, index, value):
        self.harmonic.insert(index, value)
    def replace_harmonic_at(self, index, value):
        self.harmonic[index] = value
    def get_open_string(self):
        return self.open_string
    def set_open_string(self, open_string):
        self.open_string = open_string
    def add_open_string(self, value):
        self.open_string.append(value)
    def insert_open_string_at(self, index, value):
        self.open_string.insert(index, value)
    def replace_open_string_at(self, index, value):
        self.open_string[index] = value
    def get_thumb_position(self):
        return self.thumb_position
    def set_thumb_position(self, thumb_position):
        self.thumb_position = thumb_position
    def add_thumb_position(self, value):
        self.thumb_position.append(value)
    def insert_thumb_position_at(self, index, value):
        self.thumb_position.insert(index, value)
    def replace_thumb_position_at(self, index, value):
        self.thumb_position[index] = value
    def get_fingering(self):
        return self.fingering
    def set_fingering(self, fingering):
        self.fingering = fingering
    def add_fingering(self, value):
        self.fingering.append(value)
    def insert_fingering_at(self, index, value):
        self.fingering.insert(index, value)
    def replace_fingering_at(self, index, value):
        self.fingering[index] = value
    def get_pluck(self):
        return self.pluck
    def set_pluck(self, pluck):
        self.pluck = pluck
    def add_pluck(self, value):
        self.pluck.append(value)
    def insert_pluck_at(self, index, value):
        self.pluck.insert(index, value)
    def replace_pluck_at(self, index, value):
        self.pluck[index] = value
    def get_double_tongue(self):
        return self.double_tongue
    def set_double_tongue(self, double_tongue):
        self.double_tongue = double_tongue
    def add_double_tongue(self, value):
        self.double_tongue.append(value)
    def insert_double_tongue_at(self, index, value):
        self.double_tongue.insert(index, value)
    def replace_double_tongue_at(self, index, value):
        self.double_tongue[index] = value
    def get_triple_tongue(self):
        return self.triple_tongue
    def set_triple_tongue(self, triple_tongue):
        self.triple_tongue = triple_tongue
    def add_triple_tongue(self, value):
        self.triple_tongue.append(value)
    def insert_triple_tongue_at(self, index, value):
        self.triple_tongue.insert(index, value)
    def replace_triple_tongue_at(self, index, value):
        self.triple_tongue[index] = value
    def get_stopped(self):
        return self.stopped
    def set_stopped(self, stopped):
        self.stopped = stopped
    def add_stopped(self, value):
        self.stopped.append(value)
    def insert_stopped_at(self, index, value):
        self.stopped.insert(index, value)
    def replace_stopped_at(self, index, value):
        self.stopped[index] = value
    def get_snap_pizzicato(self):
        return self.snap_pizzicato
    def set_snap_pizzicato(self, snap_pizzicato):
        self.snap_pizzicato = snap_pizzicato
    def add_snap_pizzicato(self, value):
        self.snap_pizzicato.append(value)
    def insert_snap_pizzicato_at(self, index, value):
        self.snap_pizzicato.insert(index, value)
    def replace_snap_pizzicato_at(self, index, value):
        self.snap_pizzicato[index] = value
    def get_fret(self):
        return self.fret
    def set_fret(self, fret):
        self.fret = fret
    def add_fret(self, value):
        self.fret.append(value)
    def insert_fret_at(self, index, value):
        self.fret.insert(index, value)
    def replace_fret_at(self, index, value):
        self.fret[index] = value
    def get_string(self):
        return self.string
    def set_string(self, string):
        self.string = string
    def add_string(self, value):
        self.string.append(value)
    def insert_string_at(self, index, value):
        self.string.insert(index, value)
    def replace_string_at(self, index, value):
        self.string[index] = value
    def get_hammer_on(self):
        return self.hammer_on
    def set_hammer_on(self, hammer_on):
        self.hammer_on = hammer_on
    def add_hammer_on(self, value):
        self.hammer_on.append(value)
    def insert_hammer_on_at(self, index, value):
        self.hammer_on.insert(index, value)
    def replace_hammer_on_at(self, index, value):
        self.hammer_on[index] = value
    def get_pull_off(self):
        return self.pull_off
    def set_pull_off(self, pull_off):
        self.pull_off = pull_off
    def add_pull_off(self, value):
        self.pull_off.append(value)
    def insert_pull_off_at(self, index, value):
        self.pull_off.insert(index, value)
    def replace_pull_off_at(self, index, value):
        self.pull_off[index] = value
    def get_bend(self):
        return self.bend
    def set_bend(self, bend):
        self.bend = bend
    def add_bend(self, value):
        self.bend.append(value)
    def insert_bend_at(self, index, value):
        self.bend.insert(index, value)
    def replace_bend_at(self, index, value):
        self.bend[index] = value
    def get_tap(self):
        return self.tap
    def set_tap(self, tap):
        self.tap = tap
    def add_tap(self, value):
        self.tap.append(value)
    def insert_tap_at(self, index, value):
        self.tap.insert(index, value)
    def replace_tap_at(self, index, value):
        self.tap[index] = value
    def get_heel(self):
        return self.heel
    def set_heel(self, heel):
        self.heel = heel
    def add_heel(self, value):
        self.heel.append(value)
    def insert_heel_at(self, index, value):
        self.heel.insert(index, value)
    def replace_heel_at(self, index, value):
        self.heel[index] = value
    def get_toe(self):
        return self.toe
    def set_toe(self, toe):
        self.toe = toe
    def add_toe(self, value):
        self.toe.append(value)
    def insert_toe_at(self, index, value):
        self.toe.insert(index, value)
    def replace_toe_at(self, index, value):
        self.toe[index] = value
    def get_fingernails(self):
        return self.fingernails
    def set_fingernails(self, fingernails):
        self.fingernails = fingernails
    def add_fingernails(self, value):
        self.fingernails.append(value)
    def insert_fingernails_at(self, index, value):
        self.fingernails.insert(index, value)
    def replace_fingernails_at(self, index, value):
        self.fingernails[index] = value
    def get_hole(self):
        return self.hole
    def set_hole(self, hole):
        self.hole = hole
    def add_hole(self, value):
        self.hole.append(value)
    def insert_hole_at(self, index, value):
        self.hole.insert(index, value)
    def replace_hole_at(self, index, value):
        self.hole[index] = value
    def get_arrow(self):
        return self.arrow
    def set_arrow(self, arrow):
        self.arrow = arrow
    def add_arrow(self, value):
        self.arrow.append(value)
    def insert_arrow_at(self, index, value):
        self.arrow.insert(index, value)
    def replace_arrow_at(self, index, value):
        self.arrow[index] = value
    def get_handbell(self):
        return self.handbell
    def set_handbell(self, handbell):
        self.handbell = handbell
    def add_handbell(self, value):
        self.handbell.append(value)
    def insert_handbell_at(self, index, value):
        self.handbell.insert(index, value)
    def replace_handbell_at(self, index, value):
        self.handbell[index] = value
    def get_brass_bend(self):
        return self.brass_bend
    def set_brass_bend(self, brass_bend):
        self.brass_bend = brass_bend
    def add_brass_bend(self, value):
        self.brass_bend.append(value)
    def insert_brass_bend_at(self, index, value):
        self.brass_bend.insert(index, value)
    def replace_brass_bend_at(self, index, value):
        self.brass_bend[index] = value
    def get_flip(self):
        return self.flip
    def set_flip(self, flip):
        self.flip = flip
    def add_flip(self, value):
        self.flip.append(value)
    def insert_flip_at(self, index, value):
        self.flip.insert(index, value)
    def replace_flip_at(self, index, value):
        self.flip[index] = value
    def get_smear(self):
        return self.smear
    def set_smear(self, smear):
        self.smear = smear
    def add_smear(self, value):
        self.smear.append(value)
    def insert_smear_at(self, index, value):
        self.smear.insert(index, value)
    def replace_smear_at(self, index, value):
        self.smear[index] = value
    def get_open(self):
        return self.open
    def set_open(self, open):
        self.open = open
    def add_open(self, value):
        self.open.append(value)
    def insert_open_at(self, index, value):
        self.open.insert(index, value)
    def replace_open_at(self, index, value):
        self.open[index] = value
    def get_half_muted(self):
        return self.half_muted
    def set_half_muted(self, half_muted):
        self.half_muted = half_muted
    def add_half_muted(self, value):
        self.half_muted.append(value)
    def insert_half_muted_at(self, index, value):
        self.half_muted.insert(index, value)
    def replace_half_muted_at(self, index, value):
        self.half_muted[index] = value
    def get_harmon_mute(self):
        return self.harmon_mute
    def set_harmon_mute(self, harmon_mute):
        self.harmon_mute = harmon_mute
    def add_harmon_mute(self, value):
        self.harmon_mute.append(value)
    def insert_harmon_mute_at(self, index, value):
        self.harmon_mute.insert(index, value)
    def replace_harmon_mute_at(self, index, value):
        self.harmon_mute[index] = value
    def get_golpe(self):
        return self.golpe
    def set_golpe(self, golpe):
        self.golpe = golpe
    def add_golpe(self, value):
        self.golpe.append(value)
    def insert_golpe_at(self, index, value):
        self.golpe.insert(index, value)
    def replace_golpe_at(self, index, value):
        self.golpe[index] = value
    def get_other_technical(self):
        return self.other_technical
    def set_other_technical(self, other_technical):
        self.other_technical = other_technical
    def add_other_technical(self, value):
        self.other_technical.append(value)
    def insert_other_technical_at(self, index, value):
        self.other_technical.insert(index, value)
    def replace_other_technical_at(self, index, value):
        self.other_technical[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.up_bow or
            self.down_bow or
            self.harmonic or
            self.open_string or
            self.thumb_position or
            self.fingering or
            self.pluck or
            self.double_tongue or
            self.triple_tongue or
            self.stopped or
            self.snap_pizzicato or
            self.fret or
            self.string or
            self.hammer_on or
            self.pull_off or
            self.bend or
            self.tap or
            self.heel or
            self.toe or
            self.fingernails or
            self.hole or
            self.arrow or
            self.handbell or
            self.brass_bend or
            self.flip or
            self.smear or
            self.open or
            self.half_muted or
            self.harmon_mute or
            self.golpe or
            self.other_technical
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='technical', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('technical')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'technical':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='technical')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='technical', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='technical'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='technical', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for up_bow_ in self.up_bow:
            namespaceprefix_ = self.up_bow_nsprefix_ + ':' if (UseCapturedNS_ and self.up_bow_nsprefix_) else ''
            up_bow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='up-bow', pretty_print=pretty_print)
        for down_bow_ in self.down_bow:
            namespaceprefix_ = self.down_bow_nsprefix_ + ':' if (UseCapturedNS_ and self.down_bow_nsprefix_) else ''
            down_bow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='down-bow', pretty_print=pretty_print)
        for harmonic_ in self.harmonic:
            namespaceprefix_ = self.harmonic_nsprefix_ + ':' if (UseCapturedNS_ and self.harmonic_nsprefix_) else ''
            harmonic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='harmonic', pretty_print=pretty_print)
        for open_string_ in self.open_string:
            namespaceprefix_ = self.open_string_nsprefix_ + ':' if (UseCapturedNS_ and self.open_string_nsprefix_) else ''
            open_string_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='open-string', pretty_print=pretty_print)
        for thumb_position_ in self.thumb_position:
            namespaceprefix_ = self.thumb_position_nsprefix_ + ':' if (UseCapturedNS_ and self.thumb_position_nsprefix_) else ''
            thumb_position_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumb-position', pretty_print=pretty_print)
        for fingering_ in self.fingering:
            namespaceprefix_ = self.fingering_nsprefix_ + ':' if (UseCapturedNS_ and self.fingering_nsprefix_) else ''
            fingering_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fingering', pretty_print=pretty_print)
        for pluck_ in self.pluck:
            namespaceprefix_ = self.pluck_nsprefix_ + ':' if (UseCapturedNS_ and self.pluck_nsprefix_) else ''
            pluck_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pluck', pretty_print=pretty_print)
        for double_tongue_ in self.double_tongue:
            namespaceprefix_ = self.double_tongue_nsprefix_ + ':' if (UseCapturedNS_ and self.double_tongue_nsprefix_) else ''
            double_tongue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='double-tongue', pretty_print=pretty_print)
        for triple_tongue_ in self.triple_tongue:
            namespaceprefix_ = self.triple_tongue_nsprefix_ + ':' if (UseCapturedNS_ and self.triple_tongue_nsprefix_) else ''
            triple_tongue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='triple-tongue', pretty_print=pretty_print)
        for stopped_ in self.stopped:
            namespaceprefix_ = self.stopped_nsprefix_ + ':' if (UseCapturedNS_ and self.stopped_nsprefix_) else ''
            stopped_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='stopped', pretty_print=pretty_print)
        for snap_pizzicato_ in self.snap_pizzicato:
            namespaceprefix_ = self.snap_pizzicato_nsprefix_ + ':' if (UseCapturedNS_ and self.snap_pizzicato_nsprefix_) else ''
            snap_pizzicato_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='snap-pizzicato', pretty_print=pretty_print)
        for fret_ in self.fret:
            namespaceprefix_ = self.fret_nsprefix_ + ':' if (UseCapturedNS_ and self.fret_nsprefix_) else ''
            fret_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fret', pretty_print=pretty_print)
        for string_ in self.string:
            namespaceprefix_ = self.string_nsprefix_ + ':' if (UseCapturedNS_ and self.string_nsprefix_) else ''
            string_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='string', pretty_print=pretty_print)
        for hammer_on_ in self.hammer_on:
            namespaceprefix_ = self.hammer_on_nsprefix_ + ':' if (UseCapturedNS_ and self.hammer_on_nsprefix_) else ''
            hammer_on_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hammer-on', pretty_print=pretty_print)
        for pull_off_ in self.pull_off:
            namespaceprefix_ = self.pull_off_nsprefix_ + ':' if (UseCapturedNS_ and self.pull_off_nsprefix_) else ''
            pull_off_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pull-off', pretty_print=pretty_print)
        for bend_ in self.bend:
            namespaceprefix_ = self.bend_nsprefix_ + ':' if (UseCapturedNS_ and self.bend_nsprefix_) else ''
            bend_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bend', pretty_print=pretty_print)
        for tap_ in self.tap:
            namespaceprefix_ = self.tap_nsprefix_ + ':' if (UseCapturedNS_ and self.tap_nsprefix_) else ''
            tap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tap', pretty_print=pretty_print)
        for heel_ in self.heel:
            namespaceprefix_ = self.heel_nsprefix_ + ':' if (UseCapturedNS_ and self.heel_nsprefix_) else ''
            heel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='heel', pretty_print=pretty_print)
        for toe_ in self.toe:
            namespaceprefix_ = self.toe_nsprefix_ + ':' if (UseCapturedNS_ and self.toe_nsprefix_) else ''
            toe_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toe', pretty_print=pretty_print)
        for fingernails_ in self.fingernails:
            namespaceprefix_ = self.fingernails_nsprefix_ + ':' if (UseCapturedNS_ and self.fingernails_nsprefix_) else ''
            fingernails_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fingernails', pretty_print=pretty_print)
        for hole_ in self.hole:
            namespaceprefix_ = self.hole_nsprefix_ + ':' if (UseCapturedNS_ and self.hole_nsprefix_) else ''
            hole_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hole', pretty_print=pretty_print)
        for arrow_ in self.arrow:
            namespaceprefix_ = self.arrow_nsprefix_ + ':' if (UseCapturedNS_ and self.arrow_nsprefix_) else ''
            arrow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arrow', pretty_print=pretty_print)
        for handbell_ in self.handbell:
            namespaceprefix_ = self.handbell_nsprefix_ + ':' if (UseCapturedNS_ and self.handbell_nsprefix_) else ''
            handbell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='handbell', pretty_print=pretty_print)
        for brass_bend_ in self.brass_bend:
            namespaceprefix_ = self.brass_bend_nsprefix_ + ':' if (UseCapturedNS_ and self.brass_bend_nsprefix_) else ''
            brass_bend_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='brass-bend', pretty_print=pretty_print)
        for flip_ in self.flip:
            namespaceprefix_ = self.flip_nsprefix_ + ':' if (UseCapturedNS_ and self.flip_nsprefix_) else ''
            flip_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flip', pretty_print=pretty_print)
        for smear_ in self.smear:
            namespaceprefix_ = self.smear_nsprefix_ + ':' if (UseCapturedNS_ and self.smear_nsprefix_) else ''
            smear_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='smear', pretty_print=pretty_print)
        for open_ in self.open:
            namespaceprefix_ = self.open_nsprefix_ + ':' if (UseCapturedNS_ and self.open_nsprefix_) else ''
            open_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='open', pretty_print=pretty_print)
        for half_muted_ in self.half_muted:
            namespaceprefix_ = self.half_muted_nsprefix_ + ':' if (UseCapturedNS_ and self.half_muted_nsprefix_) else ''
            half_muted_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='half-muted', pretty_print=pretty_print)
        for harmon_mute_ in self.harmon_mute:
            namespaceprefix_ = self.harmon_mute_nsprefix_ + ':' if (UseCapturedNS_ and self.harmon_mute_nsprefix_) else ''
            harmon_mute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='harmon-mute', pretty_print=pretty_print)
        for golpe_ in self.golpe:
            namespaceprefix_ = self.golpe_nsprefix_ + ':' if (UseCapturedNS_ and self.golpe_nsprefix_) else ''
            golpe_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='golpe', pretty_print=pretty_print)
        for other_technical_ in self.other_technical:
            namespaceprefix_ = self.other_technical_nsprefix_ + ':' if (UseCapturedNS_ and self.other_technical_nsprefix_) else ''
            other_technical_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='other-technical', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'up-bow':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.up_bow.append(obj_)
            obj_.original_tagname_ = 'up-bow'
        elif nodeName_ == 'down-bow':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.down_bow.append(obj_)
            obj_.original_tagname_ = 'down-bow'
        elif nodeName_ == 'harmonic':
            obj_ = harmonic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.harmonic.append(obj_)
            obj_.original_tagname_ = 'harmonic'
        elif nodeName_ == 'open-string':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.open_string.append(obj_)
            obj_.original_tagname_ = 'open-string'
        elif nodeName_ == 'thumb-position':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.thumb_position.append(obj_)
            obj_.original_tagname_ = 'thumb-position'
        elif nodeName_ == 'fingering':
            obj_ = fingering.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fingering.append(obj_)
            obj_.original_tagname_ = 'fingering'
        elif nodeName_ == 'pluck':
            obj_ = placement_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pluck.append(obj_)
            obj_.original_tagname_ = 'pluck'
        elif nodeName_ == 'double-tongue':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.double_tongue.append(obj_)
            obj_.original_tagname_ = 'double-tongue'
        elif nodeName_ == 'triple-tongue':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.triple_tongue.append(obj_)
            obj_.original_tagname_ = 'triple-tongue'
        elif nodeName_ == 'stopped':
            obj_ = empty_placement_smufl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stopped.append(obj_)
            obj_.original_tagname_ = 'stopped'
        elif nodeName_ == 'snap-pizzicato':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.snap_pizzicato.append(obj_)
            obj_.original_tagname_ = 'snap-pizzicato'
        elif nodeName_ == 'fret':
            obj_ = fret.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fret.append(obj_)
            obj_.original_tagname_ = 'fret'
        elif nodeName_ == 'string':
            obj_ = string.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.string.append(obj_)
            obj_.original_tagname_ = 'string'
        elif nodeName_ == 'hammer-on':
            obj_ = hammer_on_pull_off.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hammer_on.append(obj_)
            obj_.original_tagname_ = 'hammer-on'
        elif nodeName_ == 'pull-off':
            obj_ = hammer_on_pull_off.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pull_off.append(obj_)
            obj_.original_tagname_ = 'pull-off'
        elif nodeName_ == 'bend':
            obj_ = bend.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bend.append(obj_)
            obj_.original_tagname_ = 'bend'
        elif nodeName_ == 'tap':
            obj_ = tap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tap.append(obj_)
            obj_.original_tagname_ = 'tap'
        elif nodeName_ == 'heel':
            obj_ = heel_toe.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.heel.append(obj_)
            obj_.original_tagname_ = 'heel'
        elif nodeName_ == 'toe':
            obj_ = heel_toe.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toe.append(obj_)
            obj_.original_tagname_ = 'toe'
        elif nodeName_ == 'fingernails':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fingernails.append(obj_)
            obj_.original_tagname_ = 'fingernails'
        elif nodeName_ == 'hole':
            obj_ = hole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hole.append(obj_)
            obj_.original_tagname_ = 'hole'
        elif nodeName_ == 'arrow':
            obj_ = arrow.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrow.append(obj_)
            obj_.original_tagname_ = 'arrow'
        elif nodeName_ == 'handbell':
            obj_ = handbell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.handbell.append(obj_)
            obj_.original_tagname_ = 'handbell'
        elif nodeName_ == 'brass-bend':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.brass_bend.append(obj_)
            obj_.original_tagname_ = 'brass-bend'
        elif nodeName_ == 'flip':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flip.append(obj_)
            obj_.original_tagname_ = 'flip'
        elif nodeName_ == 'smear':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.smear.append(obj_)
            obj_.original_tagname_ = 'smear'
        elif nodeName_ == 'open':
            obj_ = empty_placement_smufl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.open.append(obj_)
            obj_.original_tagname_ = 'open'
        elif nodeName_ == 'half-muted':
            obj_ = empty_placement_smufl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.half_muted.append(obj_)
            obj_.original_tagname_ = 'half-muted'
        elif nodeName_ == 'harmon-mute':
            obj_ = harmon_mute.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.harmon_mute.append(obj_)
            obj_.original_tagname_ = 'harmon-mute'
        elif nodeName_ == 'golpe':
            obj_ = empty_placement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.golpe.append(obj_)
            obj_.original_tagname_ = 'golpe'
        elif nodeName_ == 'other-technical':
            obj_ = other_placement_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.other_technical.append(obj_)
            obj_.original_tagname_ = 'other-technical'
# end class technical


class text_element_data(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, underline=None, overline=None, line_through=None, rotation=None, letter_spacing=None, dir=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.underline = _cast(int, underline)
        self.underline_nsprefix_ = None
        self.overline = _cast(int, overline)
        self.overline_nsprefix_ = None
        self.line_through = _cast(int, line_through)
        self.line_through_nsprefix_ = None
        self.rotation = _cast(float, rotation)
        self.rotation_nsprefix_ = None
        self.letter_spacing = _cast(None, letter_spacing)
        self.letter_spacing_nsprefix_ = None
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, text_element_data)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if text_element_data.subclass:
            return text_element_data.subclass(*args_, **kwargs_)
        else:
            return text_element_data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def get_overline(self):
        return self.overline
    def set_overline(self, overline):
        self.overline = overline
    def get_line_through(self):
        return self.line_through
    def set_line_through(self, line_through):
        self.line_through = line_through
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    def get_letter_spacing(self):
        return self.letter_spacing
    def set_letter_spacing(self, letter_spacing):
        self.letter_spacing = letter_spacing
    def get_dir(self):
        return self.dir
    def set_dir(self, dir):
        self.dir = dir
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_number_of_lines(self, value):
        # Validate type number-of-lines, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
            if value > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-of-lines' % {"value": value, "lineno": lineno} )
                result = False
    def validate_rotation_degrees(self, value):
        # Validate type rotation-degrees, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on rotation-degrees' % {"value": value, "lineno": lineno} )
                result = False
    def validate_number_or_normal(self, value):
        # Validate type number-or-normal, a restriction on xs:token.
        pass
    def validate_text_direction(self, value):
        # Validate type text-direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ltr', 'rtl', 'lro', 'rlo']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on text-direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='text-element-data', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('text-element-data')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'text-element-data':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='text-element-data')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='text-element-data', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='text-element-data'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.underline is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            outfile.write(' underline="%s"' % self.gds_format_integer(self.underline, input_name='underline'))
        if self.overline is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            outfile.write(' overline="%s"' % self.gds_format_integer(self.overline, input_name='overline'))
        if self.line_through is not None and 'line_through' not in already_processed:
            already_processed.add('line_through')
            outfile.write(' line-through="%s"' % self.gds_format_integer(self.line_through, input_name='line-through'))
        if self.rotation is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            outfile.write(' rotation="%s"' % self.gds_format_decimal(self.rotation, input_name='rotation'))
        if self.letter_spacing is not None and 'letter_spacing' not in already_processed:
            already_processed.add('letter_spacing')
            outfile.write(' letter-spacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.letter_spacing), input_name='letter-spacing')), ))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='text-element-data', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('underline', node)
        if value is not None and 'underline' not in already_processed:
            already_processed.add('underline')
            self.underline = self.gds_parse_integer(value, node, 'underline')
            if self.underline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.underline)    # validate type number-of-lines
        value = find_attr_value_('overline', node)
        if value is not None and 'overline' not in already_processed:
            already_processed.add('overline')
            self.overline = self.gds_parse_integer(value, node, 'overline')
            if self.overline < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.overline)    # validate type number-of-lines
        value = find_attr_value_('line-through', node)
        if value is not None and 'line-through' not in already_processed:
            already_processed.add('line-through')
            self.line_through = self.gds_parse_integer(value, node, 'line-through')
            if self.line_through < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_number_of_lines(self.line_through)    # validate type number-of-lines
        value = find_attr_value_('rotation', node)
        if value is not None and 'rotation' not in already_processed:
            already_processed.add('rotation')
            value = self.gds_parse_decimal(value, node, 'rotation')
            self.rotation = value
            self.validate_rotation_degrees(self.rotation)    # validate type rotation-degrees
        value = find_attr_value_('letter-spacing', node)
        if value is not None and 'letter-spacing' not in already_processed:
            already_processed.add('letter-spacing')
            self.letter_spacing = value
            self.letter_spacing = ' '.join(self.letter_spacing.split())
            self.validate_number_or_normal(self.letter_spacing)    # validate type number-or-normal
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.dir = ' '.join(self.dir.split())
            self.validate_text_direction(self.dir)    # validate type text-direction
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class text_element_data


class tie(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, time_only=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.time_only = _cast(None, time_only)
        self.time_only_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tie)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tie.subclass:
            return tie.subclass(*args_, **kwargs_)
        else:
            return tie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_time_only(self):
        return self.time_only
    def set_time_only(self, time_only):
        self.time_only = time_only
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_time_only(self, value):
        # Validate type time-only, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_time_only_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_time_only_patterns_, ))
    validate_time_only_patterns_ = [['^([1-9][0-9]*(, ?[1-9][0-9]*)*)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tie', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tie')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tie':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tie')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tie', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tie'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.time_only is not None and 'time_only' not in already_processed:
            already_processed.add('time_only')
            outfile.write(' time-only=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time_only), input_name='time-only')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tie', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('time-only', node)
        if value is not None and 'time-only' not in already_processed:
            already_processed.add('time-only')
            self.time_only = value
            self.time_only = ' '.join(self.time_only.split())
            self.validate_time_only(self.time_only)    # validate type time-only
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tie


class tied(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, line_type=None, dash_length=None, space_length=None, default_x=None, default_y=None, relative_x=None, relative_y=None, placement=None, orientation=None, bezier_x=None, bezier_y=None, bezier_x2=None, bezier_y2=None, bezier_offset=None, bezier_offset2=None, color=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.line_type = _cast(None, line_type)
        self.line_type_nsprefix_ = None
        self.dash_length = _cast(float, dash_length)
        self.dash_length_nsprefix_ = None
        self.space_length = _cast(float, space_length)
        self.space_length_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.bezier_x = _cast(float, bezier_x)
        self.bezier_x_nsprefix_ = None
        self.bezier_y = _cast(float, bezier_y)
        self.bezier_y_nsprefix_ = None
        self.bezier_x2 = _cast(float, bezier_x2)
        self.bezier_x2_nsprefix_ = None
        self.bezier_y2 = _cast(float, bezier_y2)
        self.bezier_y2_nsprefix_ = None
        self.bezier_offset = _cast(float, bezier_offset)
        self.bezier_offset_nsprefix_ = None
        self.bezier_offset2 = _cast(float, bezier_offset2)
        self.bezier_offset2_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tied)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tied.subclass:
            return tied.subclass(*args_, **kwargs_)
        else:
            return tied(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_line_type(self):
        return self.line_type
    def set_line_type(self, line_type):
        self.line_type = line_type
    def get_dash_length(self):
        return self.dash_length
    def set_dash_length(self, dash_length):
        self.dash_length = dash_length
    def get_space_length(self):
        return self.space_length
    def set_space_length(self, space_length):
        self.space_length = space_length
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_bezier_x(self):
        return self.bezier_x
    def set_bezier_x(self, bezier_x):
        self.bezier_x = bezier_x
    def get_bezier_y(self):
        return self.bezier_y
    def set_bezier_y(self, bezier_y):
        self.bezier_y = bezier_y
    def get_bezier_x2(self):
        return self.bezier_x2
    def set_bezier_x2(self, bezier_x2):
        self.bezier_x2 = bezier_x2
    def get_bezier_y2(self):
        return self.bezier_y2
    def set_bezier_y2(self, bezier_y2):
        self.bezier_y2 = bezier_y2
    def get_bezier_offset(self):
        return self.bezier_offset
    def set_bezier_offset(self, bezier_offset):
        self.bezier_offset = bezier_offset
    def get_bezier_offset2(self):
        return self.bezier_offset2
    def set_bezier_offset2(self, bezier_offset2):
        self.bezier_offset2 = bezier_offset2
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_tied_type(self, value):
        # Validate type tied-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'continue', 'let-ring']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tied-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_line_type(self, value):
        # Validate type line-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['solid', 'dashed', 'dotted', 'wavy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_over_under(self, value):
        # Validate type over-under, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['over', 'under']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on over-under' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tied', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tied')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tied':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tied')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tied', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tied'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.line_type is not None and 'line_type' not in already_processed:
            already_processed.add('line_type')
            outfile.write(' line-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_type), input_name='line-type')), ))
        if self.dash_length is not None and 'dash_length' not in already_processed:
            already_processed.add('dash_length')
            outfile.write(' dash-length="%s"' % self.gds_format_decimal(self.dash_length, input_name='dash-length'))
        if self.space_length is not None and 'space_length' not in already_processed:
            already_processed.add('space_length')
            outfile.write(' space-length="%s"' % self.gds_format_decimal(self.space_length, input_name='space-length'))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.bezier_x is not None and 'bezier_x' not in already_processed:
            already_processed.add('bezier_x')
            outfile.write(' bezier-x="%s"' % self.gds_format_decimal(self.bezier_x, input_name='bezier-x'))
        if self.bezier_y is not None and 'bezier_y' not in already_processed:
            already_processed.add('bezier_y')
            outfile.write(' bezier-y="%s"' % self.gds_format_decimal(self.bezier_y, input_name='bezier-y'))
        if self.bezier_x2 is not None and 'bezier_x2' not in already_processed:
            already_processed.add('bezier_x2')
            outfile.write(' bezier-x2="%s"' % self.gds_format_decimal(self.bezier_x2, input_name='bezier-x2'))
        if self.bezier_y2 is not None and 'bezier_y2' not in already_processed:
            already_processed.add('bezier_y2')
            outfile.write(' bezier-y2="%s"' % self.gds_format_decimal(self.bezier_y2, input_name='bezier-y2'))
        if self.bezier_offset is not None and 'bezier_offset' not in already_processed:
            already_processed.add('bezier_offset')
            outfile.write(' bezier-offset="%s"' % self.gds_format_decimal(self.bezier_offset, input_name='bezier-offset'))
        if self.bezier_offset2 is not None and 'bezier_offset2' not in already_processed:
            already_processed.add('bezier_offset2')
            outfile.write(' bezier-offset2="%s"' % self.gds_format_decimal(self.bezier_offset2, input_name='bezier-offset2'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tied', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_tied_type(self.type_)    # validate type tied-type
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('line-type', node)
        if value is not None and 'line-type' not in already_processed:
            already_processed.add('line-type')
            self.line_type = value
            self.line_type = ' '.join(self.line_type.split())
            self.validate_line_type(self.line_type)    # validate type line-type
        value = find_attr_value_('dash-length', node)
        if value is not None and 'dash-length' not in already_processed:
            already_processed.add('dash-length')
            value = self.gds_parse_decimal(value, node, 'dash-length')
            self.dash_length = value
        value = find_attr_value_('space-length', node)
        if value is not None and 'space-length' not in already_processed:
            already_processed.add('space-length')
            value = self.gds_parse_decimal(value, node, 'space-length')
            self.space_length = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.orientation = ' '.join(self.orientation.split())
            self.validate_over_under(self.orientation)    # validate type over-under
        value = find_attr_value_('bezier-x', node)
        if value is not None and 'bezier-x' not in already_processed:
            already_processed.add('bezier-x')
            value = self.gds_parse_decimal(value, node, 'bezier-x')
            self.bezier_x = value
        value = find_attr_value_('bezier-y', node)
        if value is not None and 'bezier-y' not in already_processed:
            already_processed.add('bezier-y')
            value = self.gds_parse_decimal(value, node, 'bezier-y')
            self.bezier_y = value
        value = find_attr_value_('bezier-x2', node)
        if value is not None and 'bezier-x2' not in already_processed:
            already_processed.add('bezier-x2')
            value = self.gds_parse_decimal(value, node, 'bezier-x2')
            self.bezier_x2 = value
        value = find_attr_value_('bezier-y2', node)
        if value is not None and 'bezier-y2' not in already_processed:
            already_processed.add('bezier-y2')
            value = self.gds_parse_decimal(value, node, 'bezier-y2')
            self.bezier_y2 = value
        value = find_attr_value_('bezier-offset', node)
        if value is not None and 'bezier-offset' not in already_processed:
            already_processed.add('bezier-offset')
            value = self.gds_parse_decimal(value, node, 'bezier-offset')
            self.bezier_offset = value
        value = find_attr_value_('bezier-offset2', node)
        if value is not None and 'bezier-offset2' not in already_processed:
            already_processed.add('bezier-offset2')
            value = self.gds_parse_decimal(value, node, 'bezier-offset2')
            self.bezier_offset2 = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tied


class time_modification(GeneratedsSuper):
    """actual-notes -- The actual-notes element describes how many notes are played in the time usually occupied by the number in the normal-notes element.
    normal-notes -- The normal-notes element describes how many notes are usually played in the time occupied by the number in the actual-notes element.
    normal-type -- If the type associated with the number in the normal-notes element is different than the current note type (e.g., a quarter note within an eighth note triplet), then the normal-notes type (e.g. eighth) is specified in the normal-type and normal-dot elements.
    normal-dot -- The normal-dot element is used to specify dotted normal tuplet types.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, actual_notes=None, normal_notes=None, normal_type=None, normal_dot=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.actual_notes = actual_notes
        self.actual_notes_nsprefix_ = None
        self.normal_notes = normal_notes
        self.normal_notes_nsprefix_ = None
        self.normal_type = normal_type
        self.validate_note_type_value(self.normal_type)
        self.normal_type_nsprefix_ = None
        if normal_dot is None:
            self.normal_dot = []
        else:
            self.normal_dot = normal_dot
        self.normal_dot_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, time_modification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if time_modification.subclass:
            return time_modification.subclass(*args_, **kwargs_)
        else:
            return time_modification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_actual_notes(self):
        return self.actual_notes
    def set_actual_notes(self, actual_notes):
        self.actual_notes = actual_notes
    def get_normal_notes(self):
        return self.normal_notes
    def set_normal_notes(self, normal_notes):
        self.normal_notes = normal_notes
    def get_normal_type(self):
        return self.normal_type
    def set_normal_type(self, normal_type):
        self.normal_type = normal_type
    def get_normal_dot(self):
        return self.normal_dot
    def set_normal_dot(self, normal_dot):
        self.normal_dot = normal_dot
    def add_normal_dot(self, value):
        self.normal_dot.append(value)
    def insert_normal_dot_at(self, index, value):
        self.normal_dot.insert(index, value)
    def replace_normal_dot_at(self, index, value):
        self.normal_dot[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_note_type_value(self, value):
        result = True
        # Validate type note-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.actual_notes is not None or
            self.normal_notes is not None or
            self.normal_type is not None or
            self.normal_dot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='time-modification', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('time-modification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'time-modification':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='time-modification')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='time-modification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='time-modification'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='time-modification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.actual_notes is not None:
            namespaceprefix_ = self.actual_notes_nsprefix_ + ':' if (UseCapturedNS_ and self.actual_notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactual-notes>%s</%sactual-notes>%s' % (namespaceprefix_ , self.gds_format_integer(self.actual_notes, input_name='actual-notes'), namespaceprefix_ , eol_))
        if self.normal_notes is not None:
            namespaceprefix_ = self.normal_notes_nsprefix_ + ':' if (UseCapturedNS_ and self.normal_notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snormal-notes>%s</%snormal-notes>%s' % (namespaceprefix_ , self.gds_format_integer(self.normal_notes, input_name='normal-notes'), namespaceprefix_ , eol_))
        if self.normal_type is not None:
            namespaceprefix_ = self.normal_type_nsprefix_ + ':' if (UseCapturedNS_ and self.normal_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snormal-type>%s</%snormal-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.normal_type), input_name='normal-type')), namespaceprefix_ , eol_))
        for normal_dot_ in self.normal_dot:
            namespaceprefix_ = self.normal_dot_nsprefix_ + ':' if (UseCapturedNS_ and self.normal_dot_nsprefix_) else ''
            normal_dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='normal-dot', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'actual-notes' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'actual_notes')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'actual_notes')
            self.actual_notes = ival_
            self.actual_notes_nsprefix_ = child_.prefix
        elif nodeName_ == 'normal-notes' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'normal_notes')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'normal_notes')
            self.normal_notes = ival_
            self.normal_notes_nsprefix_ = child_.prefix
        elif nodeName_ == 'normal-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'normal_type')
            value_ = self.gds_validate_string(value_, node, 'normal_type')
            self.normal_type = value_
            self.normal_type_nsprefix_ = child_.prefix
            # validate type note-type-value
            self.validate_note_type_value(self.normal_type)
        elif nodeName_ == 'normal-dot':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.normal_dot.append(obj_)
            obj_.original_tagname_ = 'normal-dot'
# end class time_modification


class tremolo(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='single', default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, placement=None, smufl=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.smufl = _cast(None, smufl)
        self.smufl_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tremolo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tremolo.subclass:
            return tremolo.subclass(*args_, **kwargs_)
        else:
            return tremolo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_smufl(self):
        return self.smufl
    def set_smufl(self, smufl):
        self.smufl = smufl
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tremolo_marks(self, value):
        result = True
        # Validate type tremolo-marks, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on tremolo-marks' % {"value": value, "lineno": lineno} )
                result = False
            if value > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on tremolo-marks' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_tremolo_type(self, value):
        # Validate type tremolo-type, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop', 'single', 'unmeasured']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tremolo-type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_smufl_glyph_name(self, value):
        # Validate type smufl-glyph-name, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tremolo', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tremolo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tremolo':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tremolo')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tremolo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tremolo'):
        if self.type_ != "single" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.smufl is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            outfile.write(' smufl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smufl), input_name='smufl')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tremolo', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_tremolo_type(self.type_)    # validate type tremolo-type
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('smufl', node)
        if value is not None and 'smufl' not in already_processed:
            already_processed.add('smufl')
            self.smufl = value
            self.validate_smufl_glyph_name(self.smufl)    # validate type smufl-glyph-name
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tremolo


class tuplet(GeneratedsSuper):
    """tuplet-actual -- The tuplet-actual element provide optional full control over how the actual part of the tuplet is displayed, including number and note type (with dots). If any of these elements are absent, their values are based on the time-modification element.
    tuplet-normal -- The tuplet-normal element provide optional full control over how the normal part of the tuplet is displayed, including number and note type (with dots). If any of these elements are absent, their values are based on the time-modification element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number=None, bracket=None, show_number=None, show_type=None, line_shape=None, default_x=None, default_y=None, relative_x=None, relative_y=None, placement=None, id=None, tuplet_actual=None, tuplet_normal=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.bracket = _cast(None, bracket)
        self.bracket_nsprefix_ = None
        self.show_number = _cast(None, show_number)
        self.show_number_nsprefix_ = None
        self.show_type = _cast(None, show_type)
        self.show_type_nsprefix_ = None
        self.line_shape = _cast(None, line_shape)
        self.line_shape_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.placement = _cast(None, placement)
        self.placement_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.tuplet_actual = tuplet_actual
        self.tuplet_actual_nsprefix_ = None
        self.tuplet_normal = tuplet_normal
        self.tuplet_normal_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tuplet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tuplet.subclass:
            return tuplet.subclass(*args_, **kwargs_)
        else:
            return tuplet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tuplet_actual(self):
        return self.tuplet_actual
    def set_tuplet_actual(self, tuplet_actual):
        self.tuplet_actual = tuplet_actual
    def get_tuplet_normal(self):
        return self.tuplet_normal
    def set_tuplet_normal(self, tuplet_normal):
        self.tuplet_normal = tuplet_normal
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_bracket(self):
        return self.bracket
    def set_bracket(self, bracket):
        self.bracket = bracket
    def get_show_number(self):
        return self.show_number
    def set_show_number(self, show_number):
        self.show_number = show_number
    def get_show_type(self):
        return self.show_type
    def set_show_type(self, show_type):
        self.show_type = show_type
    def get_line_shape(self):
        return self.line_shape
    def set_line_shape(self, line_shape):
        self.line_shape = line_shape
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_placement(self):
        return self.placement
    def set_placement(self, placement):
        self.placement = placement
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_number_level(self, value):
        # Validate type number-level, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
            if value > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on number-level' % {"value": value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_show_tuplet(self, value):
        # Validate type show-tuplet, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['actual', 'both', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on show-tuplet' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_line_shape(self, value):
        # Validate type line-shape, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['straight', 'curved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on line-shape' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_above_below(self, value):
        # Validate type above-below, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['above', 'below']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on above-below' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.tuplet_actual is not None or
            self.tuplet_normal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tuplet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tuplet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tuplet')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tuplet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tuplet'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.bracket is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            outfile.write(' bracket=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bracket), input_name='bracket')), ))
        if self.show_number is not None and 'show_number' not in already_processed:
            already_processed.add('show_number')
            outfile.write(' show-number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show_number), input_name='show-number')), ))
        if self.show_type is not None and 'show_type' not in already_processed:
            already_processed.add('show_type')
            outfile.write(' show-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show_type), input_name='show-type')), ))
        if self.line_shape is not None and 'line_shape' not in already_processed:
            already_processed.add('line_shape')
            outfile.write(' line-shape=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.line_shape), input_name='line-shape')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.placement is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            outfile.write(' placement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placement), input_name='placement')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tuplet_actual is not None:
            namespaceprefix_ = self.tuplet_actual_nsprefix_ + ':' if (UseCapturedNS_ and self.tuplet_actual_nsprefix_) else ''
            self.tuplet_actual.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tuplet-actual', pretty_print=pretty_print)
        if self.tuplet_normal is not None:
            namespaceprefix_ = self.tuplet_normal_nsprefix_ + ':' if (UseCapturedNS_ and self.tuplet_normal_nsprefix_) else ''
            self.tuplet_normal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tuplet-normal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_number_level(self.number)    # validate type number-level
        value = find_attr_value_('bracket', node)
        if value is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            self.bracket = value
            self.bracket = ' '.join(self.bracket.split())
            self.validate_yes_no(self.bracket)    # validate type yes-no
        value = find_attr_value_('show-number', node)
        if value is not None and 'show-number' not in already_processed:
            already_processed.add('show-number')
            self.show_number = value
            self.show_number = ' '.join(self.show_number.split())
            self.validate_show_tuplet(self.show_number)    # validate type show-tuplet
        value = find_attr_value_('show-type', node)
        if value is not None and 'show-type' not in already_processed:
            already_processed.add('show-type')
            self.show_type = value
            self.show_type = ' '.join(self.show_type.split())
            self.validate_show_tuplet(self.show_type)    # validate type show-tuplet
        value = find_attr_value_('line-shape', node)
        if value is not None and 'line-shape' not in already_processed:
            already_processed.add('line-shape')
            self.line_shape = value
            self.line_shape = ' '.join(self.line_shape.split())
            self.validate_line_shape(self.line_shape)    # validate type line-shape
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('placement', node)
        if value is not None and 'placement' not in already_processed:
            already_processed.add('placement')
            self.placement = value
            self.placement = ' '.join(self.placement.split())
            self.validate_above_below(self.placement)    # validate type above-below
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tuplet-actual':
            obj_ = tuplet_portion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tuplet_actual = obj_
            obj_.original_tagname_ = 'tuplet-actual'
        elif nodeName_ == 'tuplet-normal':
            obj_ = tuplet_portion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tuplet_normal = obj_
            obj_.original_tagname_ = 'tuplet-normal'
# end class tuplet


class tuplet_dot(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tuplet_dot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tuplet_dot.subclass:
            return tuplet_dot.subclass(*args_, **kwargs_)
        else:
            return tuplet_dot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet-dot', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tuplet-dot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tuplet-dot':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tuplet-dot')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tuplet-dot', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tuplet-dot'):
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet-dot', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tuplet_dot


class tuplet_number(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tuplet_number)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tuplet_number.subclass:
            return tuplet_number.subclass(*args_, **kwargs_)
        else:
            return tuplet_number(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet-number', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tuplet-number')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tuplet-number':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tuplet-number')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tuplet-number', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tuplet-number'):
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet-number', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tuplet_number


class tuplet_portion(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tuplet_number=None, tuplet_type=None, tuplet_dot=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tuplet_number = tuplet_number
        self.tuplet_number_nsprefix_ = None
        self.tuplet_type = tuplet_type
        self.tuplet_type_nsprefix_ = None
        if tuplet_dot is None:
            self.tuplet_dot = []
        else:
            self.tuplet_dot = tuplet_dot
        self.tuplet_dot_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tuplet_portion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tuplet_portion.subclass:
            return tuplet_portion.subclass(*args_, **kwargs_)
        else:
            return tuplet_portion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tuplet_number(self):
        return self.tuplet_number
    def set_tuplet_number(self, tuplet_number):
        self.tuplet_number = tuplet_number
    def get_tuplet_type(self):
        return self.tuplet_type
    def set_tuplet_type(self, tuplet_type):
        self.tuplet_type = tuplet_type
    def get_tuplet_dot(self):
        return self.tuplet_dot
    def set_tuplet_dot(self, tuplet_dot):
        self.tuplet_dot = tuplet_dot
    def add_tuplet_dot(self, value):
        self.tuplet_dot.append(value)
    def insert_tuplet_dot_at(self, index, value):
        self.tuplet_dot.insert(index, value)
    def replace_tuplet_dot_at(self, index, value):
        self.tuplet_dot[index] = value
    def _hasContent(self):
        if (
            self.tuplet_number is not None or
            self.tuplet_type is not None or
            self.tuplet_dot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet-portion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tuplet-portion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tuplet-portion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tuplet-portion')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tuplet-portion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tuplet-portion'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet-portion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tuplet_number is not None:
            namespaceprefix_ = self.tuplet_number_nsprefix_ + ':' if (UseCapturedNS_ and self.tuplet_number_nsprefix_) else ''
            self.tuplet_number.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tuplet-number', pretty_print=pretty_print)
        if self.tuplet_type is not None:
            namespaceprefix_ = self.tuplet_type_nsprefix_ + ':' if (UseCapturedNS_ and self.tuplet_type_nsprefix_) else ''
            self.tuplet_type.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tuplet-type', pretty_print=pretty_print)
        for tuplet_dot_ in self.tuplet_dot:
            namespaceprefix_ = self.tuplet_dot_nsprefix_ + ':' if (UseCapturedNS_ and self.tuplet_dot_nsprefix_) else ''
            tuplet_dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tuplet-dot', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tuplet-number':
            obj_ = tuplet_number.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tuplet_number = obj_
            obj_.original_tagname_ = 'tuplet-number'
        elif nodeName_ == 'tuplet-type':
            obj_ = tuplet_type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tuplet_type = obj_
            obj_.original_tagname_ = 'tuplet-type'
        elif nodeName_ == 'tuplet-dot':
            obj_ = tuplet_dot.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tuplet_dot.append(obj_)
            obj_.original_tagname_ = 'tuplet-dot'
# end class tuplet_portion


class tuplet_type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tuplet_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tuplet_type.subclass:
            return tuplet_type.subclass(*args_, **kwargs_)
        else:
            return tuplet_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_note_type_value(self, value):
        result = True
        # Validate type note-type-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1024th', '512th', '256th', '128th', '64th', '32nd', '16th', 'eighth', 'quarter', 'half', 'whole', 'breve', 'long', 'maxima']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on note-type-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet-type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tuplet-type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tuplet-type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tuplet-type')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tuplet-type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tuplet-type'):
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tuplet-type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tuplet_type


class unpitched(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, display_step=None, display_octave=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.display_step = display_step
        self.validate_step(self.display_step)
        self.display_step_nsprefix_ = None
        self.display_octave = display_octave
        self.validate_octave(self.display_octave)
        self.display_octave_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unpitched)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unpitched.subclass:
            return unpitched.subclass(*args_, **kwargs_)
        else:
            return unpitched(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_display_step(self):
        return self.display_step
    def set_display_step(self, display_step):
        self.display_step = display_step
    def get_display_octave(self):
        return self.display_octave
    def set_display_octave(self, display_octave):
        self.display_octave = display_octave
    def validate_step(self, value):
        result = True
        # Validate type step, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on step' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_octave(self, value):
        result = True
        # Validate type octave, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
            if value > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on octave' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.display_step is not None or
            self.display_octave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='unpitched', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unpitched')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unpitched':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unpitched')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unpitched', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='unpitched'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='unpitched', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.display_step is not None:
            namespaceprefix_ = self.display_step_nsprefix_ + ':' if (UseCapturedNS_ and self.display_step_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplay-step>%s</%sdisplay-step>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.display_step), input_name='display-step')), namespaceprefix_ , eol_))
        if self.display_octave is not None:
            namespaceprefix_ = self.display_octave_nsprefix_ + ':' if (UseCapturedNS_ and self.display_octave_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplay-octave>%s</%sdisplay-octave>%s' % (namespaceprefix_ , self.gds_format_integer(self.display_octave, input_name='display-octave'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'display-step':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'display_step')
            value_ = self.gds_validate_string(value_, node, 'display_step')
            self.display_step = value_
            self.display_step_nsprefix_ = child_.prefix
            # validate type step
            self.validate_step(self.display_step)
        elif nodeName_ == 'display-octave' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'display_octave')
            ival_ = self.gds_validate_integer(ival_, node, 'display_octave')
            self.display_octave = ival_
            self.display_octave_nsprefix_ = child_.prefix
            # validate type octave
            self.validate_octave(self.display_octave)
# end class unpitched


class wait(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, player=None, time_only=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.player = _cast(None, player)
        self.player_nsprefix_ = None
        self.time_only = _cast(None, time_only)
        self.time_only_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wait)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wait.subclass:
            return wait.subclass(*args_, **kwargs_)
        else:
            return wait(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_player(self):
        return self.player
    def set_player(self, player):
        self.player = player
    def get_time_only(self):
        return self.time_only
    def set_time_only(self, time_only):
        self.time_only = time_only
    def validate_time_only(self, value):
        # Validate type time-only, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_time_only_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_time_only_patterns_, ))
    validate_time_only_patterns_ = [['^([1-9][0-9]*(, ?[1-9][0-9]*)*)$']]
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='wait', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wait')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'wait':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='wait')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='wait', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='wait'):
        if self.player is not None and 'player' not in already_processed:
            already_processed.add('player')
            outfile.write(' player=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.player), input_name='player')), ))
        if self.time_only is not None and 'time_only' not in already_processed:
            already_processed.add('time_only')
            outfile.write(' time-only=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time_only), input_name='time-only')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='wait', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('player', node)
        if value is not None and 'player' not in already_processed:
            already_processed.add('player')
            self.player = value
        value = find_attr_value_('time-only', node)
        if value is not None and 'time-only' not in already_processed:
            already_processed.add('time-only')
            self.time_only = value
            self.time_only = ' '.join(self.time_only.split())
            self.validate_time_only(self.time_only)    # validate type time-only
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class wait


class credit(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, page=None, id=None, credit_type=None, credit_image=None, link=None, bookmark=None, credit_words=None, credit_symbol=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.page = _cast(int, page)
        self.page_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if credit_type is None:
            self.credit_type = []
        else:
            self.credit_type = credit_type
        self.credit_type_nsprefix_ = None
        self.credit_image = credit_image
        self.credit_image_nsprefix_ = None
        if link is None:
            self.link = []
        else:
            self.link = link
        self.link_nsprefix_ = None
        if bookmark is None:
            self.bookmark = []
        else:
            self.bookmark = bookmark
        self.bookmark_nsprefix_ = None
        if credit_words is None:
            self.credit_words = []
        else:
            self.credit_words = credit_words
        self.credit_words_nsprefix_ = None
        if credit_symbol is None:
            self.credit_symbol = []
        else:
            self.credit_symbol = credit_symbol
        self.credit_symbol_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, credit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if credit.subclass:
            return credit.subclass(*args_, **kwargs_)
        else:
            return credit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_credit_type(self):
        return self.credit_type
    def set_credit_type(self, credit_type):
        self.credit_type = credit_type
    def add_credit_type(self, value):
        self.credit_type.append(value)
    def insert_credit_type_at(self, index, value):
        self.credit_type.insert(index, value)
    def replace_credit_type_at(self, index, value):
        self.credit_type[index] = value
    def get_credit_image(self):
        return self.credit_image
    def set_credit_image(self, credit_image):
        self.credit_image = credit_image
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def add_link(self, value):
        self.link.append(value)
    def insert_link_at(self, index, value):
        self.link.insert(index, value)
    def replace_link_at(self, index, value):
        self.link[index] = value
    def get_bookmark(self):
        return self.bookmark
    def set_bookmark(self, bookmark):
        self.bookmark = bookmark
    def add_bookmark(self, value):
        self.bookmark.append(value)
    def insert_bookmark_at(self, index, value):
        self.bookmark.insert(index, value)
    def replace_bookmark_at(self, index, value):
        self.bookmark[index] = value
    def get_credit_words(self):
        return self.credit_words
    def set_credit_words(self, credit_words):
        self.credit_words = credit_words
    def add_credit_words(self, value):
        self.credit_words.append(value)
    def insert_credit_words_at(self, index, value):
        self.credit_words.insert(index, value)
    def replace_credit_words_at(self, index, value):
        self.credit_words[index] = value
    def get_credit_symbol(self):
        return self.credit_symbol
    def set_credit_symbol(self, credit_symbol):
        self.credit_symbol = credit_symbol
    def add_credit_symbol(self, value):
        self.credit_symbol.append(value)
    def insert_credit_symbol_at(self, index, value):
        self.credit_symbol.insert(index, value)
    def replace_credit_symbol_at(self, index, value):
        self.credit_symbol[index] = value
    def get_page(self):
        return self.page
    def set_page(self, page):
        self.page = page
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.credit_type or
            self.credit_image is not None or
            self.link or
            self.bookmark or
            self.credit_words or
            self.credit_symbol
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='credit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('credit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'credit':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='credit')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='credit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='credit'):
        if self.page is not None and 'page' not in already_processed:
            already_processed.add('page')
            outfile.write(' page="%s"' % self.gds_format_integer(self.page, input_name='page'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='credit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for credit_type_ in self.credit_type:
            namespaceprefix_ = self.credit_type_nsprefix_ + ':' if (UseCapturedNS_ and self.credit_type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scredit-type>%s</%scredit-type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(credit_type_), input_name='credit-type')), namespaceprefix_ , eol_))
        if self.credit_image is not None:
            namespaceprefix_ = self.credit_image_nsprefix_ + ':' if (UseCapturedNS_ and self.credit_image_nsprefix_) else ''
            self.credit_image.export(outfile, level, namespaceprefix_, namespacedef_='', name_='credit-image', pretty_print=pretty_print)
        for link_ in self.link:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            link_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for bookmark_ in self.bookmark:
            namespaceprefix_ = self.bookmark_nsprefix_ + ':' if (UseCapturedNS_ and self.bookmark_nsprefix_) else ''
            bookmark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bookmark', pretty_print=pretty_print)
        for credit_words_ in self.credit_words:
            namespaceprefix_ = self.credit_words_nsprefix_ + ':' if (UseCapturedNS_ and self.credit_words_nsprefix_) else ''
            credit_words_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='credit-words', pretty_print=pretty_print)
        for credit_symbol_ in self.credit_symbol:
            namespaceprefix_ = self.credit_symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.credit_symbol_nsprefix_) else ''
            credit_symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='credit-symbol', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('page', node)
        if value is not None and 'page' not in already_processed:
            already_processed.add('page')
            self.page = self.gds_parse_integer(value, node, 'page')
            if self.page <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'credit-type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'credit_type')
            value_ = self.gds_validate_string(value_, node, 'credit_type')
            self.credit_type.append(value_)
            self.credit_type_nsprefix_ = child_.prefix
        elif nodeName_ == 'credit-image':
            obj_ = image.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.credit_image = obj_
            obj_.original_tagname_ = 'credit-image'
        elif nodeName_ == 'link':
            obj_ = link.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'bookmark':
            obj_ = bookmark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bookmark.append(obj_)
            obj_.original_tagname_ = 'bookmark'
        elif nodeName_ == 'credit-words':
            obj_ = formatted_text_id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.credit_words.append(obj_)
            obj_.original_tagname_ = 'credit-words'
        elif nodeName_ == 'credit-symbol':
            obj_ = formatted_symbol_id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.credit_symbol.append(obj_)
            obj_.original_tagname_ = 'credit-symbol'
# end class credit


class defaults(GeneratedsSuper):
    """concert-score -- The presence of a concert-score element indicates that a score is displayed in concert pitch. It is used for scores that contain parts for transposing instruments.
    A document with a concert-score element may not contain any transpose elements that have non-zero values for either the diatonic or chromatic elements. Concert scores may include octave transpositions, so transpose elements with a double element or a non-zero octave-change element value are permitted.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, scaling=None, concert_score=None, page_layout=None, system_layout=None, staff_layout=None, appearance=None, music_font=None, word_font=None, lyric_font=None, lyric_language=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.scaling = scaling
        self.scaling_nsprefix_ = None
        self.concert_score = concert_score
        self.concert_score_nsprefix_ = None
        self.page_layout = page_layout
        self.page_layout_nsprefix_ = None
        self.system_layout = system_layout
        self.system_layout_nsprefix_ = None
        if staff_layout is None:
            self.staff_layout = []
        else:
            self.staff_layout = staff_layout
        self.staff_layout_nsprefix_ = None
        self.appearance = appearance
        self.appearance_nsprefix_ = None
        self.music_font = music_font
        self.music_font_nsprefix_ = None
        self.word_font = word_font
        self.word_font_nsprefix_ = None
        if lyric_font is None:
            self.lyric_font = []
        else:
            self.lyric_font = lyric_font
        self.lyric_font_nsprefix_ = None
        if lyric_language is None:
            self.lyric_language = []
        else:
            self.lyric_language = lyric_language
        self.lyric_language_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, defaults)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if defaults.subclass:
            return defaults.subclass(*args_, **kwargs_)
        else:
            return defaults(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_scaling(self):
        return self.scaling
    def set_scaling(self, scaling):
        self.scaling = scaling
    def get_concert_score(self):
        return self.concert_score
    def set_concert_score(self, concert_score):
        self.concert_score = concert_score
    def get_page_layout(self):
        return self.page_layout
    def set_page_layout(self, page_layout):
        self.page_layout = page_layout
    def get_system_layout(self):
        return self.system_layout
    def set_system_layout(self, system_layout):
        self.system_layout = system_layout
    def get_staff_layout(self):
        return self.staff_layout
    def set_staff_layout(self, staff_layout):
        self.staff_layout = staff_layout
    def add_staff_layout(self, value):
        self.staff_layout.append(value)
    def insert_staff_layout_at(self, index, value):
        self.staff_layout.insert(index, value)
    def replace_staff_layout_at(self, index, value):
        self.staff_layout[index] = value
    def get_appearance(self):
        return self.appearance
    def set_appearance(self, appearance):
        self.appearance = appearance
    def get_music_font(self):
        return self.music_font
    def set_music_font(self, music_font):
        self.music_font = music_font
    def get_word_font(self):
        return self.word_font
    def set_word_font(self, word_font):
        self.word_font = word_font
    def get_lyric_font(self):
        return self.lyric_font
    def set_lyric_font(self, lyric_font):
        self.lyric_font = lyric_font
    def add_lyric_font(self, value):
        self.lyric_font.append(value)
    def insert_lyric_font_at(self, index, value):
        self.lyric_font.insert(index, value)
    def replace_lyric_font_at(self, index, value):
        self.lyric_font[index] = value
    def get_lyric_language(self):
        return self.lyric_language
    def set_lyric_language(self, lyric_language):
        self.lyric_language = lyric_language
    def add_lyric_language(self, value):
        self.lyric_language.append(value)
    def insert_lyric_language_at(self, index, value):
        self.lyric_language.insert(index, value)
    def replace_lyric_language_at(self, index, value):
        self.lyric_language[index] = value
    def _hasContent(self):
        if (
            self.scaling is not None or
            self.concert_score is not None or
            self.page_layout is not None or
            self.system_layout is not None or
            self.staff_layout or
            self.appearance is not None or
            self.music_font is not None or
            self.word_font is not None or
            self.lyric_font or
            self.lyric_language
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='defaults', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('defaults')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'defaults':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defaults')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='defaults', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='defaults'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='defaults', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scaling is not None:
            namespaceprefix_ = self.scaling_nsprefix_ + ':' if (UseCapturedNS_ and self.scaling_nsprefix_) else ''
            self.scaling.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scaling', pretty_print=pretty_print)
        if self.concert_score is not None:
            namespaceprefix_ = self.concert_score_nsprefix_ + ':' if (UseCapturedNS_ and self.concert_score_nsprefix_) else ''
            self.concert_score.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concert-score', pretty_print=pretty_print)
        if self.page_layout is not None:
            namespaceprefix_ = self.page_layout_nsprefix_ + ':' if (UseCapturedNS_ and self.page_layout_nsprefix_) else ''
            self.page_layout.export(outfile, level, namespaceprefix_, namespacedef_='', name_='page-layout', pretty_print=pretty_print)
        if self.system_layout is not None:
            namespaceprefix_ = self.system_layout_nsprefix_ + ':' if (UseCapturedNS_ and self.system_layout_nsprefix_) else ''
            self.system_layout.export(outfile, level, namespaceprefix_, namespacedef_='', name_='system-layout', pretty_print=pretty_print)
        for staff_layout_ in self.staff_layout:
            namespaceprefix_ = self.staff_layout_nsprefix_ + ':' if (UseCapturedNS_ and self.staff_layout_nsprefix_) else ''
            staff_layout_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='staff-layout', pretty_print=pretty_print)
        if self.appearance is not None:
            namespaceprefix_ = self.appearance_nsprefix_ + ':' if (UseCapturedNS_ and self.appearance_nsprefix_) else ''
            self.appearance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='appearance', pretty_print=pretty_print)
        if self.music_font is not None:
            namespaceprefix_ = self.music_font_nsprefix_ + ':' if (UseCapturedNS_ and self.music_font_nsprefix_) else ''
            self.music_font.export(outfile, level, namespaceprefix_, namespacedef_='', name_='music-font', pretty_print=pretty_print)
        if self.word_font is not None:
            namespaceprefix_ = self.word_font_nsprefix_ + ':' if (UseCapturedNS_ and self.word_font_nsprefix_) else ''
            self.word_font.export(outfile, level, namespaceprefix_, namespacedef_='', name_='word-font', pretty_print=pretty_print)
        for lyric_font_ in self.lyric_font:
            namespaceprefix_ = self.lyric_font_nsprefix_ + ':' if (UseCapturedNS_ and self.lyric_font_nsprefix_) else ''
            lyric_font_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lyric-font', pretty_print=pretty_print)
        for lyric_language_ in self.lyric_language:
            namespaceprefix_ = self.lyric_language_nsprefix_ + ':' if (UseCapturedNS_ and self.lyric_language_nsprefix_) else ''
            lyric_language_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lyric-language', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'scaling':
            obj_ = scaling.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scaling = obj_
            obj_.original_tagname_ = 'scaling'
        elif nodeName_ == 'concert-score':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concert_score = obj_
            obj_.original_tagname_ = 'concert-score'
        elif nodeName_ == 'page-layout':
            obj_ = page_layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.page_layout = obj_
            obj_.original_tagname_ = 'page-layout'
        elif nodeName_ == 'system-layout':
            obj_ = system_layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.system_layout = obj_
            obj_.original_tagname_ = 'system-layout'
        elif nodeName_ == 'staff-layout':
            obj_ = staff_layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.staff_layout.append(obj_)
            obj_.original_tagname_ = 'staff-layout'
        elif nodeName_ == 'appearance':
            obj_ = appearance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.appearance = obj_
            obj_.original_tagname_ = 'appearance'
        elif nodeName_ == 'music-font':
            obj_ = empty_font.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.music_font = obj_
            obj_.original_tagname_ = 'music-font'
        elif nodeName_ == 'word-font':
            obj_ = empty_font.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.word_font = obj_
            obj_.original_tagname_ = 'word-font'
        elif nodeName_ == 'lyric-font':
            obj_ = lyric_font.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lyric_font.append(obj_)
            obj_.original_tagname_ = 'lyric-font'
        elif nodeName_ == 'lyric-language':
            obj_ = lyric_language.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lyric_language.append(obj_)
            obj_.original_tagname_ = 'lyric-language'
# end class defaults


class empty_font(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, font_family=None, font_style=None, font_size=None, font_weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, empty_font)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if empty_font.subclass:
            return empty_font.subclass(*args_, **kwargs_)
        else:
            return empty_font(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-font', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('empty-font')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'empty-font':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='empty-font')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='empty-font', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='empty-font'):
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='empty-font', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class empty_font


class group_barline(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, group_barline)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if group_barline.subclass:
            return group_barline.subclass(*args_, **kwargs_)
        else:
            return group_barline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_group_barline_value(self, value):
        result = True
        # Validate type group-barline-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no', 'Mensurstrich']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on group-barline-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='group-barline', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('group-barline')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'group-barline':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='group-barline')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='group-barline', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='group-barline'):
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='group-barline', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class group_barline


class group_name(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, justify=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, group_name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if group_name.subclass:
            return group_name.subclass(*args_, **kwargs_)
        else:
            return group_name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='group-name', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('group-name')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'group-name':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='group-name')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='group-name', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='group-name'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='group-name', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class group_name


class group_symbol(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, group_symbol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if group_symbol.subclass:
            return group_symbol.subclass(*args_, **kwargs_)
        else:
            return group_symbol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_group_symbol_value(self, value):
        result = True
        # Validate type group-symbol-value, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'brace', 'line', 'bracket', 'square']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on group-symbol-value' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='group-symbol', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('group-symbol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'group-symbol':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='group-symbol')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='group-symbol', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='group-symbol'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='group-symbol', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class group_symbol


class instrument_link(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instrument_link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instrument_link.subclass:
            return instrument_link.subclass(*args_, **kwargs_)
        else:
            return instrument_link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='instrument-link', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instrument-link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instrument-link':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instrument-link')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instrument-link', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='instrument-link'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='instrument-link', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class instrument_link


class lyric_font(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, name=None, font_family=None, font_style=None, font_size=None, font_weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lyric_font)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lyric_font.subclass:
            return lyric_font.subclass(*args_, **kwargs_)
        else:
            return lyric_font(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lyric-font', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lyric-font')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lyric-font':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lyric-font')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lyric-font', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lyric-font'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.number), input_name='number')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lyric-font', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.name = ' '.join(self.name.split())
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class lyric_font


class lyric_language(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, name=None, lang=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lyric_language)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lyric_language.subclass:
            return lyric_language.subclass(*args_, **kwargs_)
        else:
            return lyric_language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lyric-language', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lyric-language')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lyric-language':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lyric-language')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lyric-language', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lyric-language'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.number), input_name='number')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lyric-language', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.name = ' '.join(self.name.split())
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class lyric_language


class opus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, type_='simple', role=None, title=None, show='replace', actuate='onRequest', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, opus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if opus.subclass:
            return opus.subclass(*args_, **kwargs_)
        else:
            return opus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='opus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('opus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'opus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='opus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='opus', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='opus'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' xlink:href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' xlink:role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' xlink:title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.show != "replace" and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' xlink:show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate != "onRequest" and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' xlink:actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='opus', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.role = ' '.join(self.role.split())
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.title = ' '.join(self.title.split())
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class opus


class part_group(GeneratedsSuper):
    """group-name-display -- Formatting specified in the group-name-display element overrides formatting specified in the group-name element.
    group-abbreviation-display -- Formatting specified in the group-abbreviation-display element overrides formatting specified in the group-abbreviation element.
    group-time -- The group-time element indicates that the displayed time signatures should stretch across all parts and staves in the group.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, number='1', group_name=None, group_name_display=None, group_abbreviation=None, group_abbreviation_display=None, group_symbol=None, group_barline=None, group_time=None, footnote=None, level=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.group_name = group_name
        self.group_name_nsprefix_ = None
        self.group_name_display = group_name_display
        self.group_name_display_nsprefix_ = None
        self.group_abbreviation = group_abbreviation
        self.group_abbreviation_nsprefix_ = None
        self.group_abbreviation_display = group_abbreviation_display
        self.group_abbreviation_display_nsprefix_ = None
        self.group_symbol = group_symbol
        self.group_symbol_nsprefix_ = None
        self.group_barline = group_barline
        self.group_barline_nsprefix_ = None
        self.group_time = group_time
        self.group_time_nsprefix_ = None
        self.footnote = footnote
        self.footnote_nsprefix_ = None
        self.level = level
        self.level_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, part_group)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if part_group.subclass:
            return part_group.subclass(*args_, **kwargs_)
        else:
            return part_group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group_name(self):
        return self.group_name
    def set_group_name(self, group_name):
        self.group_name = group_name
    def get_group_name_display(self):
        return self.group_name_display
    def set_group_name_display(self, group_name_display):
        self.group_name_display = group_name_display
    def get_group_abbreviation(self):
        return self.group_abbreviation
    def set_group_abbreviation(self, group_abbreviation):
        self.group_abbreviation = group_abbreviation
    def get_group_abbreviation_display(self):
        return self.group_abbreviation_display
    def set_group_abbreviation_display(self, group_abbreviation_display):
        self.group_abbreviation_display = group_abbreviation_display
    def get_group_symbol(self):
        return self.group_symbol
    def set_group_symbol(self, group_symbol):
        self.group_symbol = group_symbol
    def get_group_barline(self):
        return self.group_barline
    def set_group_barline(self, group_barline):
        self.group_barline = group_barline
    def get_group_time(self):
        return self.group_time
    def set_group_time(self, group_time):
        self.group_time = group_time
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.group_name is not None or
            self.group_name_display is not None or
            self.group_abbreviation is not None or
            self.group_abbreviation_display is not None or
            self.group_symbol is not None or
            self.group_barline is not None or
            self.group_time is not None or
            self.footnote is not None or
            self.level is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-group', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('part-group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'part-group':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='part-group')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='part-group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='part-group'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.number != "1" and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.number), input_name='number')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-group', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group_name is not None:
            namespaceprefix_ = self.group_name_nsprefix_ + ':' if (UseCapturedNS_ and self.group_name_nsprefix_) else ''
            self.group_name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group-name', pretty_print=pretty_print)
        if self.group_name_display is not None:
            namespaceprefix_ = self.group_name_display_nsprefix_ + ':' if (UseCapturedNS_ and self.group_name_display_nsprefix_) else ''
            self.group_name_display.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group-name-display', pretty_print=pretty_print)
        if self.group_abbreviation is not None:
            namespaceprefix_ = self.group_abbreviation_nsprefix_ + ':' if (UseCapturedNS_ and self.group_abbreviation_nsprefix_) else ''
            self.group_abbreviation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group-abbreviation', pretty_print=pretty_print)
        if self.group_abbreviation_display is not None:
            namespaceprefix_ = self.group_abbreviation_display_nsprefix_ + ':' if (UseCapturedNS_ and self.group_abbreviation_display_nsprefix_) else ''
            self.group_abbreviation_display.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group-abbreviation-display', pretty_print=pretty_print)
        if self.group_symbol is not None:
            namespaceprefix_ = self.group_symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.group_symbol_nsprefix_) else ''
            self.group_symbol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group-symbol', pretty_print=pretty_print)
        if self.group_barline is not None:
            namespaceprefix_ = self.group_barline_nsprefix_ + ':' if (UseCapturedNS_ and self.group_barline_nsprefix_) else ''
            self.group_barline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group-barline', pretty_print=pretty_print)
        if self.group_time is not None:
            namespaceprefix_ = self.group_time_nsprefix_ + ':' if (UseCapturedNS_ and self.group_time_nsprefix_) else ''
            self.group_time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group-time', pretty_print=pretty_print)
        if self.footnote is not None:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            self.footnote.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            self.level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='level', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
            self.number = ' '.join(self.number.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group-name':
            obj_ = group_name.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group_name = obj_
            obj_.original_tagname_ = 'group-name'
        elif nodeName_ == 'group-name-display':
            obj_ = name_display.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group_name_display = obj_
            obj_.original_tagname_ = 'group-name-display'
        elif nodeName_ == 'group-abbreviation':
            obj_ = group_name.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group_abbreviation = obj_
            obj_.original_tagname_ = 'group-abbreviation'
        elif nodeName_ == 'group-abbreviation-display':
            obj_ = name_display.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group_abbreviation_display = obj_
            obj_.original_tagname_ = 'group-abbreviation-display'
        elif nodeName_ == 'group-symbol':
            obj_ = group_symbol.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group_symbol = obj_
            obj_.original_tagname_ = 'group-symbol'
        elif nodeName_ == 'group-barline':
            obj_ = group_barline.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group_barline = obj_
            obj_.original_tagname_ = 'group-barline'
        elif nodeName_ == 'group-time':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group_time = obj_
            obj_.original_tagname_ = 'group-time'
        elif nodeName_ == 'footnote':
            obj_ = formatted_text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.footnote = obj_
            obj_.original_tagname_ = 'footnote'
        elif nodeName_ == 'level':
            obj_ = level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.level = obj_
            obj_.original_tagname_ = 'level'
# end class part_group


class part_link(GeneratedsSuper):
    """group-link -- Multiple part-link elements can reference different types of linked documents, such as parts and condensed score. The optional group-link elements identify the groups used in the linked document. The content of a group-link element should match the content of a group element in the linked document.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, type_='simple', role=None, title=None, show='replace', actuate='onRequest', instrument_link=None, group_link=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        if instrument_link is None:
            self.instrument_link = []
        else:
            self.instrument_link = instrument_link
        self.instrument_link_nsprefix_ = None
        if group_link is None:
            self.group_link = []
        else:
            self.group_link = group_link
        self.group_link_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, part_link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if part_link.subclass:
            return part_link.subclass(*args_, **kwargs_)
        else:
            return part_link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_instrument_link(self):
        return self.instrument_link
    def set_instrument_link(self, instrument_link):
        self.instrument_link = instrument_link
    def add_instrument_link(self, value):
        self.instrument_link.append(value)
    def insert_instrument_link_at(self, index, value):
        self.instrument_link.insert(index, value)
    def replace_instrument_link_at(self, index, value):
        self.instrument_link[index] = value
    def get_group_link(self):
        return self.group_link
    def set_group_link(self, group_link):
        self.group_link = group_link
    def add_group_link(self, value):
        self.group_link.append(value)
    def insert_group_link_at(self, index, value):
        self.group_link.insert(index, value)
    def replace_group_link_at(self, index, value):
        self.group_link[index] = value
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def _hasContent(self):
        if (
            self.instrument_link or
            self.group_link
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-link', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('part-link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'part-link':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='part-link')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='part-link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='part-link'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' xlink:href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' xlink:role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' xlink:title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.show != "replace" and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' xlink:show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate != "onRequest" and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' xlink:actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-link', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrument_link_ in self.instrument_link:
            namespaceprefix_ = self.instrument_link_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_link_nsprefix_) else ''
            instrument_link_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instrument-link', pretty_print=pretty_print)
        for group_link_ in self.group_link:
            namespaceprefix_ = self.group_link_nsprefix_ + ':' if (UseCapturedNS_ and self.group_link_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup-link>%s</%sgroup-link>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(group_link_), input_name='group-link')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.role = ' '.join(self.role.split())
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.title = ' '.join(self.title.split())
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'instrument-link':
            obj_ = instrument_link.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instrument_link.append(obj_)
            obj_.original_tagname_ = 'instrument-link'
        elif nodeName_ == 'group-link':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group_link')
            value_ = self.gds_validate_string(value_, node, 'group_link')
            self.group_link.append(value_)
            self.group_link_nsprefix_ = child_.prefix
# end class part_link


class part_list(GeneratedsSuper):
    """score-part -- Each MusicXML part corresponds to a track in a Standard MIDI Format 1 file. The score-instrument elements are used when there are multiple instruments per track. The midi-device element is used to make a MIDI device or port assignment for the given track. Initial midi-instrument assignments may be made here as well.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, part_group=None, score_part=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if part_group is None:
            self.part_group = []
        else:
            self.part_group = part_group
        self.part_group_nsprefix_ = None
        if score_part is None:
            self.score_part = []
        else:
            self.score_part = score_part
        self.score_part_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, part_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if part_list.subclass:
            return part_list.subclass(*args_, **kwargs_)
        else:
            return part_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_part_group(self):
        return self.part_group
    def set_part_group(self, part_group):
        self.part_group = part_group
    def add_part_group(self, value):
        self.part_group.append(value)
    def insert_part_group_at(self, index, value):
        self.part_group.insert(index, value)
    def replace_part_group_at(self, index, value):
        self.part_group[index] = value
    def get_score_part(self):
        return self.score_part
    def set_score_part(self, score_part):
        self.score_part = score_part
    def add_score_part(self, value):
        self.score_part.append(value)
    def insert_score_part_at(self, index, value):
        self.score_part.insert(index, value)
    def replace_score_part_at(self, index, value):
        self.score_part[index] = value
    def _hasContent(self):
        if (
            self.part_group or
            self.score_part
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-list', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('part-list')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'part-list':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='part-list')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='part-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='part-list'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for part_group_ in self.part_group:
            namespaceprefix_ = self.part_group_nsprefix_ + ':' if (UseCapturedNS_ and self.part_group_nsprefix_) else ''
            part_group_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-group', pretty_print=pretty_print)
        for score_part_ in self.score_part:
            namespaceprefix_ = self.score_part_nsprefix_ + ':' if (UseCapturedNS_ and self.score_part_nsprefix_) else ''
            score_part_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='score-part', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'part-group':
            obj_ = part_group.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_group.append(obj_)
            obj_.original_tagname_ = 'part-group'
        elif nodeName_ == 'score-part':
            obj_ = score_part.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.score_part.append(obj_)
            obj_.original_tagname_ = 'score-part'
# end class part_list


class part_name(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, print_object=None, justify=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.print_object = _cast(None, print_object)
        self.print_object_nsprefix_ = None
        self.justify = _cast(None, justify)
        self.justify_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, part_name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if part_name.subclass:
            return part_name.subclass(*args_, **kwargs_)
        else:
            return part_name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_print_object(self):
        return self.print_object
    def set_print_object(self, print_object):
        self.print_object = print_object
    def get_justify(self):
        return self.justify
    def set_justify(self, justify):
        self.justify = justify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_left_center_right(self, value):
        # Validate type left-center-right, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on left-center-right' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-name', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('part-name')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'part-name':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='part-name')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='part-name', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='part-name'):
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.print_object is not None and 'print_object' not in already_processed:
            already_processed.add('print_object')
            outfile.write(' print-object=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.print_object), input_name='print-object')), ))
        if self.justify is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            outfile.write(' justify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.justify), input_name='justify')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='part-name', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
        value = find_attr_value_('print-object', node)
        if value is not None and 'print-object' not in already_processed:
            already_processed.add('print-object')
            self.print_object = value
            self.print_object = ' '.join(self.print_object.split())
            self.validate_yes_no(self.print_object)    # validate type yes-no
        value = find_attr_value_('justify', node)
        if value is not None and 'justify' not in already_processed:
            already_processed.add('justify')
            self.justify = value
            self.justify = ' '.join(self.justify.split())
            self.validate_left_center_right(self.justify)    # validate type left-center-right
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class part_name


class player(GeneratedsSuper):
    """player-name -- The player-name element is typically used within a software application, rather than appearing on the printed page of a score.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, player_name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.player_name = player_name
        self.player_name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, player)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if player.subclass:
            return player.subclass(*args_, **kwargs_)
        else:
            return player(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_player_name(self):
        return self.player_name
    def set_player_name(self, player_name):
        self.player_name = player_name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.player_name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='player', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('player')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'player':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='player')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='player', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='player'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='player', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.player_name is not None:
            namespaceprefix_ = self.player_name_nsprefix_ + ':' if (UseCapturedNS_ and self.player_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splayer-name>%s</%splayer-name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.player_name), input_name='player-name')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'player-name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'player_name')
            value_ = self.gds_validate_string(value_, node, 'player_name')
            self.player_name = value_
            self.player_name_nsprefix_ = child_.prefix
# end class player


class score_instrument(GeneratedsSuper):
    """instrument-name -- The instrument-name element is typically used within a software application, rather than appearing on the printed page of a score.
    instrument-abbreviation -- The optional instrument-abbreviation element is typically used within a software application, rather than appearing on the printed page of a score.
    instrument-sound -- The instrument-sound element describes the default timbre of the score-instrument. This description is independent of a particular virtual or MIDI instrument specification and allows playback to be shared more easily between applications and libraries.
    solo -- The solo element is present if performance is intended by a solo instrument.
    ensemble -- The ensemble element is present if performance is intended by an ensemble such as an orchestral section. The text of the ensemble element contains the size of the section, or is empty if the ensemble size is not specified.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, instrument_name=None, instrument_abbreviation=None, instrument_sound=None, solo=None, ensemble=None, virtual_instrument=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.instrument_name = instrument_name
        self.instrument_name_nsprefix_ = None
        self.instrument_abbreviation = instrument_abbreviation
        self.instrument_abbreviation_nsprefix_ = None
        self.instrument_sound = instrument_sound
        self.instrument_sound_nsprefix_ = None
        self.solo = solo
        self.solo_nsprefix_ = None
        self.ensemble = ensemble
        self.validate_positive_integer_or_empty(self.ensemble)
        self.ensemble_nsprefix_ = None
        self.virtual_instrument = virtual_instrument
        self.virtual_instrument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, score_instrument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if score_instrument.subclass:
            return score_instrument.subclass(*args_, **kwargs_)
        else:
            return score_instrument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_instrument_name(self):
        return self.instrument_name
    def set_instrument_name(self, instrument_name):
        self.instrument_name = instrument_name
    def get_instrument_abbreviation(self):
        return self.instrument_abbreviation
    def set_instrument_abbreviation(self, instrument_abbreviation):
        self.instrument_abbreviation = instrument_abbreviation
    def get_instrument_sound(self):
        return self.instrument_sound
    def set_instrument_sound(self, instrument_sound):
        self.instrument_sound = instrument_sound
    def get_solo(self):
        return self.solo
    def set_solo(self, solo):
        self.solo = solo
    def get_ensemble(self):
        return self.ensemble
    def set_ensemble(self, ensemble):
        self.ensemble = ensemble
    def get_virtual_instrument(self):
        return self.virtual_instrument
    def set_virtual_instrument(self, virtual_instrument):
        self.virtual_instrument = virtual_instrument
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_positive_integer_or_empty(self, value):
        result = True
        # Validate type positive-integer-or-empty, a restriction on xs:string.
        pass
        return result
    def _hasContent(self):
        if (
            self.instrument_name is not None or
            self.instrument_abbreviation is not None or
            self.instrument_sound is not None or
            self.solo is not None or
            self.ensemble is not None or
            self.virtual_instrument is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='score-instrument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('score-instrument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'score-instrument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='score-instrument')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='score-instrument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='score-instrument'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='score-instrument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.instrument_name is not None:
            namespaceprefix_ = self.instrument_name_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstrument-name>%s</%sinstrument-name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.instrument_name), input_name='instrument-name')), namespaceprefix_ , eol_))
        if self.instrument_abbreviation is not None:
            namespaceprefix_ = self.instrument_abbreviation_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_abbreviation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstrument-abbreviation>%s</%sinstrument-abbreviation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.instrument_abbreviation), input_name='instrument-abbreviation')), namespaceprefix_ , eol_))
        if self.instrument_sound is not None:
            namespaceprefix_ = self.instrument_sound_nsprefix_ + ':' if (UseCapturedNS_ and self.instrument_sound_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstrument-sound>%s</%sinstrument-sound>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.instrument_sound), input_name='instrument-sound')), namespaceprefix_ , eol_))
        if self.solo is not None:
            namespaceprefix_ = self.solo_nsprefix_ + ':' if (UseCapturedNS_ and self.solo_nsprefix_) else ''
            self.solo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='solo', pretty_print=pretty_print)
        if self.ensemble is not None:
            namespaceprefix_ = self.ensemble_nsprefix_ + ':' if (UseCapturedNS_ and self.ensemble_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sensemble>%s</%sensemble>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ensemble), input_name='ensemble')), namespaceprefix_ , eol_))
        if self.virtual_instrument is not None:
            namespaceprefix_ = self.virtual_instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.virtual_instrument_nsprefix_) else ''
            self.virtual_instrument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='virtual-instrument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'instrument-name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'instrument_name')
            value_ = self.gds_validate_string(value_, node, 'instrument_name')
            self.instrument_name = value_
            self.instrument_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'instrument-abbreviation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'instrument_abbreviation')
            value_ = self.gds_validate_string(value_, node, 'instrument_abbreviation')
            self.instrument_abbreviation = value_
            self.instrument_abbreviation_nsprefix_ = child_.prefix
        elif nodeName_ == 'instrument-sound':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'instrument_sound')
            value_ = self.gds_validate_string(value_, node, 'instrument_sound')
            self.instrument_sound = value_
            self.instrument_sound_nsprefix_ = child_.prefix
        elif nodeName_ == 'solo':
            class_obj_ = self.get_class_obj_(child_, empty)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.solo = obj_
            obj_.original_tagname_ = 'solo'
        elif nodeName_ == 'ensemble':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ensemble')
            value_ = self.gds_validate_string(value_, node, 'ensemble')
            self.ensemble = value_
            self.ensemble_nsprefix_ = child_.prefix
            # validate type positive-integer-or-empty
            self.validate_positive_integer_or_empty(self.ensemble)
        elif nodeName_ == 'virtual-instrument':
            obj_ = virtual_instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.virtual_instrument = obj_
            obj_.original_tagname_ = 'virtual-instrument'
# end class score_instrument


class score_part(GeneratedsSuper):
    """group -- The group element allows the use of different versions of the part for different purposes. Typical values include score, parts, sound, and data. Ordering information can be derived from the ordering within a MusicXML score or opus.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, identification=None, part_link=None, part_name=None, part_name_display=None, part_abbreviation=None, part_abbreviation_display=None, group=None, score_instrument=None, player=None, midi_device=None, midi_instrument=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.identification = identification
        self.identification_nsprefix_ = None
        if part_link is None:
            self.part_link = []
        else:
            self.part_link = part_link
        self.part_link_nsprefix_ = None
        self.part_name = part_name
        self.part_name_nsprefix_ = None
        self.part_name_display = part_name_display
        self.part_name_display_nsprefix_ = None
        self.part_abbreviation = part_abbreviation
        self.part_abbreviation_nsprefix_ = None
        self.part_abbreviation_display = part_abbreviation_display
        self.part_abbreviation_display_nsprefix_ = None
        if group is None:
            self.group = []
        else:
            self.group = group
        self.group_nsprefix_ = None
        if score_instrument is None:
            self.score_instrument = []
        else:
            self.score_instrument = score_instrument
        self.score_instrument_nsprefix_ = None
        if player is None:
            self.player = []
        else:
            self.player = player
        self.player_nsprefix_ = None
        if midi_device is None:
            self.midi_device = []
        else:
            self.midi_device = midi_device
        self.midi_device_nsprefix_ = None
        if midi_instrument is None:
            self.midi_instrument = []
        else:
            self.midi_instrument = midi_instrument
        self.midi_instrument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, score_part)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if score_part.subclass:
            return score_part.subclass(*args_, **kwargs_)
        else:
            return score_part(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_identification(self):
        return self.identification
    def set_identification(self, identification):
        self.identification = identification
    def get_part_link(self):
        return self.part_link
    def set_part_link(self, part_link):
        self.part_link = part_link
    def add_part_link(self, value):
        self.part_link.append(value)
    def insert_part_link_at(self, index, value):
        self.part_link.insert(index, value)
    def replace_part_link_at(self, index, value):
        self.part_link[index] = value
    def get_part_name(self):
        return self.part_name
    def set_part_name(self, part_name):
        self.part_name = part_name
    def get_part_name_display(self):
        return self.part_name_display
    def set_part_name_display(self, part_name_display):
        self.part_name_display = part_name_display
    def get_part_abbreviation(self):
        return self.part_abbreviation
    def set_part_abbreviation(self, part_abbreviation):
        self.part_abbreviation = part_abbreviation
    def get_part_abbreviation_display(self):
        return self.part_abbreviation_display
    def set_part_abbreviation_display(self, part_abbreviation_display):
        self.part_abbreviation_display = part_abbreviation_display
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    def get_score_instrument(self):
        return self.score_instrument
    def set_score_instrument(self, score_instrument):
        self.score_instrument = score_instrument
    def add_score_instrument(self, value):
        self.score_instrument.append(value)
    def insert_score_instrument_at(self, index, value):
        self.score_instrument.insert(index, value)
    def replace_score_instrument_at(self, index, value):
        self.score_instrument[index] = value
    def get_player(self):
        return self.player
    def set_player(self, player):
        self.player = player
    def add_player(self, value):
        self.player.append(value)
    def insert_player_at(self, index, value):
        self.player.insert(index, value)
    def replace_player_at(self, index, value):
        self.player[index] = value
    def get_midi_device(self):
        return self.midi_device
    def set_midi_device(self, midi_device):
        self.midi_device = midi_device
    def add_midi_device(self, value):
        self.midi_device.append(value)
    def insert_midi_device_at(self, index, value):
        self.midi_device.insert(index, value)
    def replace_midi_device_at(self, index, value):
        self.midi_device[index] = value
    def get_midi_instrument(self):
        return self.midi_instrument
    def set_midi_instrument(self, midi_instrument):
        self.midi_instrument = midi_instrument
    def add_midi_instrument(self, value):
        self.midi_instrument.append(value)
    def insert_midi_instrument_at(self, index, value):
        self.midi_instrument.insert(index, value)
    def replace_midi_instrument_at(self, index, value):
        self.midi_instrument[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.identification is not None or
            self.part_link or
            self.part_name is not None or
            self.part_name_display is not None or
            self.part_abbreviation is not None or
            self.part_abbreviation_display is not None or
            self.group or
            self.score_instrument or
            self.player or
            self.midi_device or
            self.midi_instrument
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='score-part', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('score-part')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'score-part':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='score-part')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='score-part', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='score-part'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='score-part', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identification is not None:
            namespaceprefix_ = self.identification_nsprefix_ + ':' if (UseCapturedNS_ and self.identification_nsprefix_) else ''
            self.identification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='identification', pretty_print=pretty_print)
        for part_link_ in self.part_link:
            namespaceprefix_ = self.part_link_nsprefix_ + ':' if (UseCapturedNS_ and self.part_link_nsprefix_) else ''
            part_link_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-link', pretty_print=pretty_print)
        if self.part_name is not None:
            namespaceprefix_ = self.part_name_nsprefix_ + ':' if (UseCapturedNS_ and self.part_name_nsprefix_) else ''
            self.part_name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-name', pretty_print=pretty_print)
        if self.part_name_display is not None:
            namespaceprefix_ = self.part_name_display_nsprefix_ + ':' if (UseCapturedNS_ and self.part_name_display_nsprefix_) else ''
            self.part_name_display.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-name-display', pretty_print=pretty_print)
        if self.part_abbreviation is not None:
            namespaceprefix_ = self.part_abbreviation_nsprefix_ + ':' if (UseCapturedNS_ and self.part_abbreviation_nsprefix_) else ''
            self.part_abbreviation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-abbreviation', pretty_print=pretty_print)
        if self.part_abbreviation_display is not None:
            namespaceprefix_ = self.part_abbreviation_display_nsprefix_ + ':' if (UseCapturedNS_ and self.part_abbreviation_display_nsprefix_) else ''
            self.part_abbreviation_display.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-abbreviation-display', pretty_print=pretty_print)
        for group_ in self.group:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(group_), input_name='group')), namespaceprefix_ , eol_))
        for score_instrument_ in self.score_instrument:
            namespaceprefix_ = self.score_instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.score_instrument_nsprefix_) else ''
            score_instrument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='score-instrument', pretty_print=pretty_print)
        for player_ in self.player:
            namespaceprefix_ = self.player_nsprefix_ + ':' if (UseCapturedNS_ and self.player_nsprefix_) else ''
            player_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='player', pretty_print=pretty_print)
        for midi_device_ in self.midi_device:
            namespaceprefix_ = self.midi_device_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_device_nsprefix_) else ''
            midi_device_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='midi-device', pretty_print=pretty_print)
        for midi_instrument_ in self.midi_instrument:
            namespaceprefix_ = self.midi_instrument_nsprefix_ + ':' if (UseCapturedNS_ and self.midi_instrument_nsprefix_) else ''
            midi_instrument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='midi-instrument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'identification':
            obj_ = identification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identification = obj_
            obj_.original_tagname_ = 'identification'
        elif nodeName_ == 'part-link':
            obj_ = part_link.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_link.append(obj_)
            obj_.original_tagname_ = 'part-link'
        elif nodeName_ == 'part-name':
            obj_ = part_name.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_name = obj_
            obj_.original_tagname_ = 'part-name'
        elif nodeName_ == 'part-name-display':
            obj_ = name_display.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_name_display = obj_
            obj_.original_tagname_ = 'part-name-display'
        elif nodeName_ == 'part-abbreviation':
            obj_ = part_name.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_abbreviation = obj_
            obj_.original_tagname_ = 'part-abbreviation'
        elif nodeName_ == 'part-abbreviation-display':
            obj_ = name_display.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_abbreviation_display = obj_
            obj_.original_tagname_ = 'part-abbreviation-display'
        elif nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group.append(value_)
            self.group_nsprefix_ = child_.prefix
        elif nodeName_ == 'score-instrument':
            obj_ = score_instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.score_instrument.append(obj_)
            obj_.original_tagname_ = 'score-instrument'
        elif nodeName_ == 'player':
            obj_ = player.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.player.append(obj_)
            obj_.original_tagname_ = 'player'
        elif nodeName_ == 'midi-device':
            obj_ = midi_device.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.midi_device.append(obj_)
            obj_.original_tagname_ = 'midi-device'
        elif nodeName_ == 'midi-instrument':
            obj_ = midi_instrument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.midi_instrument.append(obj_)
            obj_.original_tagname_ = 'midi-instrument'
# end class score_part


class virtual_instrument(GeneratedsSuper):
    """virtual-library -- The virtual-library element indicates the virtual instrument library name.
    virtual-name -- The virtual-name element indicates the library-specific name for the virtual instrument.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, virtual_library=None, virtual_name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.virtual_library = virtual_library
        self.virtual_library_nsprefix_ = None
        self.virtual_name = virtual_name
        self.virtual_name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, virtual_instrument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if virtual_instrument.subclass:
            return virtual_instrument.subclass(*args_, **kwargs_)
        else:
            return virtual_instrument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_virtual_library(self):
        return self.virtual_library
    def set_virtual_library(self, virtual_library):
        self.virtual_library = virtual_library
    def get_virtual_name(self):
        return self.virtual_name
    def set_virtual_name(self, virtual_name):
        self.virtual_name = virtual_name
    def _hasContent(self):
        if (
            self.virtual_library is not None or
            self.virtual_name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='virtual-instrument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('virtual-instrument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'virtual-instrument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='virtual-instrument')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='virtual-instrument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='virtual-instrument'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='virtual-instrument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.virtual_library is not None:
            namespaceprefix_ = self.virtual_library_nsprefix_ + ':' if (UseCapturedNS_ and self.virtual_library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-library>%s</%svirtual-library>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.virtual_library), input_name='virtual-library')), namespaceprefix_ , eol_))
        if self.virtual_name is not None:
            namespaceprefix_ = self.virtual_name_nsprefix_ + ':' if (UseCapturedNS_ and self.virtual_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-name>%s</%svirtual-name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.virtual_name), input_name='virtual-name')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'virtual-library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'virtual_library')
            value_ = self.gds_validate_string(value_, node, 'virtual_library')
            self.virtual_library = value_
            self.virtual_library_nsprefix_ = child_.prefix
        elif nodeName_ == 'virtual-name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'virtual_name')
            value_ = self.gds_validate_string(value_, node, 'virtual_name')
            self.virtual_name = value_
            self.virtual_name_nsprefix_ = child_.prefix
# end class virtual_instrument


class work(GeneratedsSuper):
    """work-number -- The work-number element specifies the number of a work, such as its opus number.
    work-title -- The work-title element specifies the title of a work, not including its opus or other work number.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, work_number=None, work_title=None, opus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.work_number = work_number
        self.work_number_nsprefix_ = None
        self.work_title = work_title
        self.work_title_nsprefix_ = None
        self.opus = opus
        self.opus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, work)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if work.subclass:
            return work.subclass(*args_, **kwargs_)
        else:
            return work(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_work_number(self):
        return self.work_number
    def set_work_number(self, work_number):
        self.work_number = work_number
    def get_work_title(self):
        return self.work_title
    def set_work_title(self, work_title):
        self.work_title = work_title
    def get_opus(self):
        return self.opus
    def set_opus(self, opus):
        self.opus = opus
    def _hasContent(self):
        if (
            self.work_number is not None or
            self.work_title is not None or
            self.opus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='work', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('work')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'work':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='work')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='work', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='work'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='work', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.work_number is not None:
            namespaceprefix_ = self.work_number_nsprefix_ + ':' if (UseCapturedNS_ and self.work_number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swork-number>%s</%swork-number>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.work_number), input_name='work-number')), namespaceprefix_ , eol_))
        if self.work_title is not None:
            namespaceprefix_ = self.work_title_nsprefix_ + ':' if (UseCapturedNS_ and self.work_title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swork-title>%s</%swork-title>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.work_title), input_name='work-title')), namespaceprefix_ , eol_))
        if self.opus is not None:
            namespaceprefix_ = self.opus_nsprefix_ + ':' if (UseCapturedNS_ and self.opus_nsprefix_) else ''
            self.opus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opus', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'work-number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'work_number')
            value_ = self.gds_validate_string(value_, node, 'work_number')
            self.work_number = value_
            self.work_number_nsprefix_ = child_.prefix
        elif nodeName_ == 'work-title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'work_title')
            value_ = self.gds_validate_string(value_, node, 'work_title')
            self.work_title = value_
            self.work_title_nsprefix_ = child_.prefix
        elif nodeName_ == 'opus':
            obj_ = opus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opus = obj_
            obj_.original_tagname_ = 'opus'
# end class work


class score_partwise(GeneratedsSuper):
    """movement-number -- The movement-number element specifies the number of a movement.
    movement-title -- The movement-title element specifies the title of a movement, not including its number.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, version='1.0', work=None, movement_number=None, movement_title=None, identification=None, defaults=None, credit=None, part_list=None, part=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.work = work
        self.work_nsprefix_ = None
        self.movement_number = movement_number
        self.movement_number_nsprefix_ = None
        self.movement_title = movement_title
        self.movement_title_nsprefix_ = None
        self.identification = identification
        self.identification_nsprefix_ = None
        self.defaults = defaults
        self.defaults_nsprefix_ = None
        if credit is None:
            self.credit = []
        else:
            self.credit = credit
        self.credit_nsprefix_ = None
        self.part_list = part_list
        self.part_list_nsprefix_ = None
        if part is None:
            self.part = []
        else:
            self.part = part
        self.part_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, score_partwise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if score_partwise.subclass:
            return score_partwise.subclass(*args_, **kwargs_)
        else:
            return score_partwise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_work(self):
        return self.work
    def set_work(self, work):
        self.work = work
    def get_movement_number(self):
        return self.movement_number
    def set_movement_number(self, movement_number):
        self.movement_number = movement_number
    def get_movement_title(self):
        return self.movement_title
    def set_movement_title(self, movement_title):
        self.movement_title = movement_title
    def get_identification(self):
        return self.identification
    def set_identification(self, identification):
        self.identification = identification
    def get_defaults(self):
        return self.defaults
    def set_defaults(self, defaults):
        self.defaults = defaults
    def get_credit(self):
        return self.credit
    def set_credit(self, credit):
        self.credit = credit
    def add_credit(self, value):
        self.credit.append(value)
    def insert_credit_at(self, index, value):
        self.credit.insert(index, value)
    def replace_credit_at(self, index, value):
        self.credit[index] = value
    def get_part_list(self):
        return self.part_list
    def set_part_list(self, part_list):
        self.part_list = part_list
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def add_part(self, value):
        self.part.append(value)
    def insert_part_at(self, index, value):
        self.part.insert(index, value)
    def replace_part_at(self, index, value):
        self.part[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def _hasContent(self):
        if (
            self.work is not None or
            self.movement_number is not None or
            self.movement_title is not None or
            self.identification is not None or
            self.defaults is not None or
            self.credit or
            self.part_list is not None or
            self.part
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='score-partwise', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('score-partwise')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'score-partwise':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='score-partwise')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='score-partwise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='score-partwise'):
        if self.version != "1.0" and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='score-partwise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.work is not None:
            namespaceprefix_ = self.work_nsprefix_ + ':' if (UseCapturedNS_ and self.work_nsprefix_) else ''
            self.work.export(outfile, level, namespaceprefix_, namespacedef_='', name_='work', pretty_print=pretty_print)
        if self.movement_number is not None:
            namespaceprefix_ = self.movement_number_nsprefix_ + ':' if (UseCapturedNS_ and self.movement_number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smovement-number>%s</%smovement-number>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.movement_number), input_name='movement-number')), namespaceprefix_ , eol_))
        if self.movement_title is not None:
            namespaceprefix_ = self.movement_title_nsprefix_ + ':' if (UseCapturedNS_ and self.movement_title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smovement-title>%s</%smovement-title>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.movement_title), input_name='movement-title')), namespaceprefix_ , eol_))
        if self.identification is not None:
            namespaceprefix_ = self.identification_nsprefix_ + ':' if (UseCapturedNS_ and self.identification_nsprefix_) else ''
            self.identification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='identification', pretty_print=pretty_print)
        if self.defaults is not None:
            namespaceprefix_ = self.defaults_nsprefix_ + ':' if (UseCapturedNS_ and self.defaults_nsprefix_) else ''
            self.defaults.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defaults', pretty_print=pretty_print)
        for credit_ in self.credit:
            namespaceprefix_ = self.credit_nsprefix_ + ':' if (UseCapturedNS_ and self.credit_nsprefix_) else ''
            credit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='credit', pretty_print=pretty_print)
        if self.part_list is not None:
            namespaceprefix_ = self.part_list_nsprefix_ + ':' if (UseCapturedNS_ and self.part_list_nsprefix_) else ''
            self.part_list.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-list', pretty_print=pretty_print)
        for part_ in self.part:
            namespaceprefix_ = self.part_nsprefix_ + ':' if (UseCapturedNS_ and self.part_nsprefix_) else ''
            part_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
            self.version = ' '.join(self.version.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'work':
            obj_ = work.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work = obj_
            obj_.original_tagname_ = 'work'
        elif nodeName_ == 'movement-number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'movement_number')
            value_ = self.gds_validate_string(value_, node, 'movement_number')
            self.movement_number = value_
            self.movement_number_nsprefix_ = child_.prefix
        elif nodeName_ == 'movement-title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'movement_title')
            value_ = self.gds_validate_string(value_, node, 'movement_title')
            self.movement_title = value_
            self.movement_title_nsprefix_ = child_.prefix
        elif nodeName_ == 'identification':
            obj_ = identification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identification = obj_
            obj_.original_tagname_ = 'identification'
        elif nodeName_ == 'defaults':
            obj_ = defaults.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defaults = obj_
            obj_.original_tagname_ = 'defaults'
        elif nodeName_ == 'credit':
            obj_ = credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.credit.append(obj_)
            obj_.original_tagname_ = 'credit'
        elif nodeName_ == 'part-list':
            obj_ = part_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_list = obj_
            obj_.original_tagname_ = 'part-list'
        elif nodeName_ == 'part':
            obj_ = partType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part.append(obj_)
            obj_.original_tagname_ = 'part'
# end class score_partwise


class score_timewise(GeneratedsSuper):
    """movement-number -- The movement-number element specifies the number of a movement.
    movement-title -- The movement-title element specifies the title of a movement, not including its number.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, version='1.0', work=None, movement_number=None, movement_title=None, identification=None, defaults=None, credit=None, part_list=None, measure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.work = work
        self.work_nsprefix_ = None
        self.movement_number = movement_number
        self.movement_number_nsprefix_ = None
        self.movement_title = movement_title
        self.movement_title_nsprefix_ = None
        self.identification = identification
        self.identification_nsprefix_ = None
        self.defaults = defaults
        self.defaults_nsprefix_ = None
        if credit is None:
            self.credit = []
        else:
            self.credit = credit
        self.credit_nsprefix_ = None
        self.part_list = part_list
        self.part_list_nsprefix_ = None
        if measure is None:
            self.measure = []
        else:
            self.measure = measure
        self.measure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, score_timewise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if score_timewise.subclass:
            return score_timewise.subclass(*args_, **kwargs_)
        else:
            return score_timewise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_work(self):
        return self.work
    def set_work(self, work):
        self.work = work
    def get_movement_number(self):
        return self.movement_number
    def set_movement_number(self, movement_number):
        self.movement_number = movement_number
    def get_movement_title(self):
        return self.movement_title
    def set_movement_title(self, movement_title):
        self.movement_title = movement_title
    def get_identification(self):
        return self.identification
    def set_identification(self, identification):
        self.identification = identification
    def get_defaults(self):
        return self.defaults
    def set_defaults(self, defaults):
        self.defaults = defaults
    def get_credit(self):
        return self.credit
    def set_credit(self, credit):
        self.credit = credit
    def add_credit(self, value):
        self.credit.append(value)
    def insert_credit_at(self, index, value):
        self.credit.insert(index, value)
    def replace_credit_at(self, index, value):
        self.credit[index] = value
    def get_part_list(self):
        return self.part_list
    def set_part_list(self, part_list):
        self.part_list = part_list
    def get_measure(self):
        return self.measure
    def set_measure(self, measure):
        self.measure = measure
    def add_measure(self, value):
        self.measure.append(value)
    def insert_measure_at(self, index, value):
        self.measure.insert(index, value)
    def replace_measure_at(self, index, value):
        self.measure[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def _hasContent(self):
        if (
            self.work is not None or
            self.movement_number is not None or
            self.movement_title is not None or
            self.identification is not None or
            self.defaults is not None or
            self.credit or
            self.part_list is not None or
            self.measure
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='score-timewise', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('score-timewise')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'score-timewise':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='score-timewise')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='score-timewise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='score-timewise'):
        if self.version != "1.0" and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='score-timewise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.work is not None:
            namespaceprefix_ = self.work_nsprefix_ + ':' if (UseCapturedNS_ and self.work_nsprefix_) else ''
            self.work.export(outfile, level, namespaceprefix_, namespacedef_='', name_='work', pretty_print=pretty_print)
        if self.movement_number is not None:
            namespaceprefix_ = self.movement_number_nsprefix_ + ':' if (UseCapturedNS_ and self.movement_number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smovement-number>%s</%smovement-number>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.movement_number), input_name='movement-number')), namespaceprefix_ , eol_))
        if self.movement_title is not None:
            namespaceprefix_ = self.movement_title_nsprefix_ + ':' if (UseCapturedNS_ and self.movement_title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smovement-title>%s</%smovement-title>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.movement_title), input_name='movement-title')), namespaceprefix_ , eol_))
        if self.identification is not None:
            namespaceprefix_ = self.identification_nsprefix_ + ':' if (UseCapturedNS_ and self.identification_nsprefix_) else ''
            self.identification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='identification', pretty_print=pretty_print)
        if self.defaults is not None:
            namespaceprefix_ = self.defaults_nsprefix_ + ':' if (UseCapturedNS_ and self.defaults_nsprefix_) else ''
            self.defaults.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defaults', pretty_print=pretty_print)
        for credit_ in self.credit:
            namespaceprefix_ = self.credit_nsprefix_ + ':' if (UseCapturedNS_ and self.credit_nsprefix_) else ''
            credit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='credit', pretty_print=pretty_print)
        if self.part_list is not None:
            namespaceprefix_ = self.part_list_nsprefix_ + ':' if (UseCapturedNS_ and self.part_list_nsprefix_) else ''
            self.part_list.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part-list', pretty_print=pretty_print)
        for measure_ in self.measure:
            namespaceprefix_ = self.measure_nsprefix_ + ':' if (UseCapturedNS_ and self.measure_nsprefix_) else ''
            measure_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='measure', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
            self.version = ' '.join(self.version.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'work':
            obj_ = work.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.work = obj_
            obj_.original_tagname_ = 'work'
        elif nodeName_ == 'movement-number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'movement_number')
            value_ = self.gds_validate_string(value_, node, 'movement_number')
            self.movement_number = value_
            self.movement_number_nsprefix_ = child_.prefix
        elif nodeName_ == 'movement-title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'movement_title')
            value_ = self.gds_validate_string(value_, node, 'movement_title')
            self.movement_title = value_
            self.movement_title_nsprefix_ = child_.prefix
        elif nodeName_ == 'identification':
            obj_ = identification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identification = obj_
            obj_.original_tagname_ = 'identification'
        elif nodeName_ == 'defaults':
            obj_ = defaults.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defaults = obj_
            obj_.original_tagname_ = 'defaults'
        elif nodeName_ == 'credit':
            obj_ = credit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.credit.append(obj_)
            obj_.original_tagname_ = 'credit'
        elif nodeName_ == 'part-list':
            obj_ = part_list.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part_list = obj_
            obj_.original_tagname_ = 'part-list'
        elif nodeName_ == 'measure':
            obj_ = measureType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.measure.append(obj_)
            obj_.original_tagname_ = 'measure'
# end class score_timewise


class directiveType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, default_x=None, default_y=None, relative_x=None, relative_y=None, font_family=None, font_style=None, font_size=None, font_weight=None, color=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.default_x = _cast(float, default_x)
        self.default_x_nsprefix_ = None
        self.default_y = _cast(float, default_y)
        self.default_y_nsprefix_ = None
        self.relative_x = _cast(float, relative_x)
        self.relative_x_nsprefix_ = None
        self.relative_y = _cast(float, relative_y)
        self.relative_y_nsprefix_ = None
        self.font_family = _cast(None, font_family)
        self.font_family_nsprefix_ = None
        self.font_style = _cast(None, font_style)
        self.font_style_nsprefix_ = None
        self.font_size = _cast(None, font_size)
        self.font_size_nsprefix_ = None
        self.font_weight = _cast(None, font_weight)
        self.font_weight_nsprefix_ = None
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, directiveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if directiveType.subclass:
            return directiveType.subclass(*args_, **kwargs_)
        else:
            return directiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_default_x(self):
        return self.default_x
    def set_default_x(self, default_x):
        self.default_x = default_x
    def get_default_y(self):
        return self.default_y
    def set_default_y(self, default_y):
        self.default_y = default_y
    def get_relative_x(self):
        return self.relative_x
    def set_relative_x(self, relative_x):
        self.relative_x = relative_x
    def get_relative_y(self):
        return self.relative_y
    def set_relative_y(self, relative_y):
        self.relative_y = relative_y
    def get_font_family(self):
        return self.font_family
    def set_font_family(self, font_family):
        self.font_family = font_family
    def get_font_style(self):
        return self.font_style
    def set_font_style(self, font_style):
        self.font_style = font_style
    def get_font_size(self):
        return self.font_size
    def set_font_size(self, font_size):
        self.font_size = font_size
    def get_font_weight(self):
        return self.font_weight
    def set_font_weight(self, font_weight):
        self.font_weight = font_weight
    def get_color(self):
        return self.color
    def set_color(self, color):
        self.color = color
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_font_family(self, value):
        # Validate type font-family, a restriction on comma-separated-text.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_font_family_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_font_family_patterns_, ))
    validate_font_family_patterns_ = [['^([^,]+(, ?[^,]+)*)$']]
    def validate_font_style(self, value):
        # Validate type font-style, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'italic']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-style' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_font_size(self, value):
        # Validate type font-size, a restriction on None.
        pass
    def validate_font_weight(self, value):
        # Validate type font-weight, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on font-weight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_color(self, value):
        # Validate type color, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_color_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_color_patterns_, ))
    validate_color_patterns_ = [['^(#[\\dA-F]{6}([\\dA-F][\\dA-F])?)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='directiveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('directiveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'directiveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='directiveType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='directiveType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='directiveType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.default_x is not None and 'default_x' not in already_processed:
            already_processed.add('default_x')
            outfile.write(' default-x="%s"' % self.gds_format_decimal(self.default_x, input_name='default-x'))
        if self.default_y is not None and 'default_y' not in already_processed:
            already_processed.add('default_y')
            outfile.write(' default-y="%s"' % self.gds_format_decimal(self.default_y, input_name='default-y'))
        if self.relative_x is not None and 'relative_x' not in already_processed:
            already_processed.add('relative_x')
            outfile.write(' relative-x="%s"' % self.gds_format_decimal(self.relative_x, input_name='relative-x'))
        if self.relative_y is not None and 'relative_y' not in already_processed:
            already_processed.add('relative_y')
            outfile.write(' relative-y="%s"' % self.gds_format_decimal(self.relative_y, input_name='relative-y'))
        if self.font_family is not None and 'font_family' not in already_processed:
            already_processed.add('font_family')
            outfile.write(' font-family=%s' % (quote_attrib(self.font_family), ))
        if self.font_style is not None and 'font_style' not in already_processed:
            already_processed.add('font_style')
            outfile.write(' font-style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_style), input_name='font-style')), ))
        if self.font_size is not None and 'font_size' not in already_processed:
            already_processed.add('font_size')
            outfile.write(' font-size=%s' % (quote_attrib(self.font_size), ))
        if self.font_weight is not None and 'font_weight' not in already_processed:
            already_processed.add('font_weight')
            outfile.write(' font-weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.font_weight), input_name='font-weight')), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='directiveType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('default-x', node)
        if value is not None and 'default-x' not in already_processed:
            already_processed.add('default-x')
            value = self.gds_parse_decimal(value, node, 'default-x')
            self.default_x = value
        value = find_attr_value_('default-y', node)
        if value is not None and 'default-y' not in already_processed:
            already_processed.add('default-y')
            value = self.gds_parse_decimal(value, node, 'default-y')
            self.default_y = value
        value = find_attr_value_('relative-x', node)
        if value is not None and 'relative-x' not in already_processed:
            already_processed.add('relative-x')
            value = self.gds_parse_decimal(value, node, 'relative-x')
            self.relative_x = value
        value = find_attr_value_('relative-y', node)
        if value is not None and 'relative-y' not in already_processed:
            already_processed.add('relative-y')
            value = self.gds_parse_decimal(value, node, 'relative-y')
            self.relative_y = value
        value = find_attr_value_('font-family', node)
        if value is not None and 'font-family' not in already_processed:
            already_processed.add('font-family')
            self.font_family = value
            self.font_family = ' '.join(self.font_family.split())
            self.validate_font_family(self.font_family)    # validate type font-family
        value = find_attr_value_('font-style', node)
        if value is not None and 'font-style' not in already_processed:
            already_processed.add('font-style')
            self.font_style = value
            self.font_style = ' '.join(self.font_style.split())
            self.validate_font_style(self.font_style)    # validate type font-style
        value = find_attr_value_('font-size', node)
        if value is not None and 'font-size' not in already_processed:
            already_processed.add('font-size')
            self.font_size = value
            self.validate_font_size(self.font_size)    # validate type font-size
        value = find_attr_value_('font-weight', node)
        if value is not None and 'font-weight' not in already_processed:
            already_processed.add('font-weight')
            self.font_weight = value
            self.font_weight = ' '.join(self.font_weight.split())
            self.validate_font_weight(self.font_weight)    # validate type font-weight
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.color = ' '.join(self.color.split())
            self.validate_color(self.color)    # validate type color
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class directiveType


class partType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, measure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if measure is None:
            self.measure = []
        else:
            self.measure = measure
        self.measure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, partType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if partType.subclass:
            return partType.subclass(*args_, **kwargs_)
        else:
            return partType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_measure(self):
        return self.measure
    def set_measure(self, measure):
        self.measure = measure
    def add_measure(self, value):
        self.measure.append(value)
    def insert_measure_at(self, index, value):
        self.measure.insert(index, value)
    def replace_measure_at(self, index, value):
        self.measure[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.measure
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='partType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('partType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'partType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='partType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='partType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='partType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='partType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for measure_ in self.measure:
            namespaceprefix_ = self.measure_nsprefix_ + ':' if (UseCapturedNS_ and self.measure_nsprefix_) else ''
            measure_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='measure', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'measure':
            obj_ = measureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.measure.append(obj_)
            obj_.original_tagname_ = 'measure'
# end class partType


class measureType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, text=None, implicit=None, non_controlling=None, width=None, id=None, note=None, backup=None, forward=None, direction=None, attributes=None, harmony=None, figured_bass=None, print=None, sound=None, listening=None, barline=None, grouping=None, link=None, bookmark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.implicit = _cast(None, implicit)
        self.implicit_nsprefix_ = None
        self.non_controlling = _cast(None, non_controlling)
        self.non_controlling_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None
        if backup is None:
            self.backup = []
        else:
            self.backup = backup
        self.backup_nsprefix_ = None
        if forward is None:
            self.forward = []
        else:
            self.forward = forward
        self.forward_nsprefix_ = None
        if direction is None:
            self.direction = []
        else:
            self.direction = direction
        self.direction_nsprefix_ = None
        if attributes is None:
            self.attributes = []
        else:
            self.attributes = attributes
        self.attributes_nsprefix_ = None
        if harmony is None:
            self.harmony = []
        else:
            self.harmony = harmony
        self.harmony_nsprefix_ = None
        if figured_bass is None:
            self.figured_bass = []
        else:
            self.figured_bass = figured_bass
        self.figured_bass_nsprefix_ = None
        if print is None:
            self.print = []
        else:
            self.print = print
        self.print_nsprefix_ = None
        if sound is None:
            self.sound = []
        else:
            self.sound = sound
        self.sound_nsprefix_ = None
        if listening is None:
            self.listening = []
        else:
            self.listening = listening
        self.listening_nsprefix_ = None
        if barline is None:
            self.barline = []
        else:
            self.barline = barline
        self.barline_nsprefix_ = None
        if grouping is None:
            self.grouping = []
        else:
            self.grouping = grouping
        self.grouping_nsprefix_ = None
        if link is None:
            self.link = []
        else:
            self.link = link
        self.link_nsprefix_ = None
        if bookmark is None:
            self.bookmark = []
        else:
            self.bookmark = bookmark
        self.bookmark_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, measureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if measureType.subclass:
            return measureType.subclass(*args_, **kwargs_)
        else:
            return measureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def get_backup(self):
        return self.backup
    def set_backup(self, backup):
        self.backup = backup
    def add_backup(self, value):
        self.backup.append(value)
    def insert_backup_at(self, index, value):
        self.backup.insert(index, value)
    def replace_backup_at(self, index, value):
        self.backup[index] = value
    def get_forward(self):
        return self.forward
    def set_forward(self, forward):
        self.forward = forward
    def add_forward(self, value):
        self.forward.append(value)
    def insert_forward_at(self, index, value):
        self.forward.insert(index, value)
    def replace_forward_at(self, index, value):
        self.forward[index] = value
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def add_direction(self, value):
        self.direction.append(value)
    def insert_direction_at(self, index, value):
        self.direction.insert(index, value)
    def replace_direction_at(self, index, value):
        self.direction[index] = value
    def get_attributes(self):
        return self.attributes
    def set_attributes(self, attributes):
        self.attributes = attributes
    def add_attributes(self, value):
        self.attributes.append(value)
    def insert_attributes_at(self, index, value):
        self.attributes.insert(index, value)
    def replace_attributes_at(self, index, value):
        self.attributes[index] = value
    def get_harmony(self):
        return self.harmony
    def set_harmony(self, harmony):
        self.harmony = harmony
    def add_harmony(self, value):
        self.harmony.append(value)
    def insert_harmony_at(self, index, value):
        self.harmony.insert(index, value)
    def replace_harmony_at(self, index, value):
        self.harmony[index] = value
    def get_figured_bass(self):
        return self.figured_bass
    def set_figured_bass(self, figured_bass):
        self.figured_bass = figured_bass
    def add_figured_bass(self, value):
        self.figured_bass.append(value)
    def insert_figured_bass_at(self, index, value):
        self.figured_bass.insert(index, value)
    def replace_figured_bass_at(self, index, value):
        self.figured_bass[index] = value
    def get_print(self):
        return self.print
    def set_print(self, print):
        self.print = print
    def add_print(self, value):
        self.print.append(value)
    def insert_print_at(self, index, value):
        self.print.insert(index, value)
    def replace_print_at(self, index, value):
        self.print[index] = value
    def get_sound(self):
        return self.sound
    def set_sound(self, sound):
        self.sound = sound
    def add_sound(self, value):
        self.sound.append(value)
    def insert_sound_at(self, index, value):
        self.sound.insert(index, value)
    def replace_sound_at(self, index, value):
        self.sound[index] = value
    def get_listening(self):
        return self.listening
    def set_listening(self, listening):
        self.listening = listening
    def add_listening(self, value):
        self.listening.append(value)
    def insert_listening_at(self, index, value):
        self.listening.insert(index, value)
    def replace_listening_at(self, index, value):
        self.listening[index] = value
    def get_barline(self):
        return self.barline
    def set_barline(self, barline):
        self.barline = barline
    def add_barline(self, value):
        self.barline.append(value)
    def insert_barline_at(self, index, value):
        self.barline.insert(index, value)
    def replace_barline_at(self, index, value):
        self.barline[index] = value
    def get_grouping(self):
        return self.grouping
    def set_grouping(self, grouping):
        self.grouping = grouping
    def add_grouping(self, value):
        self.grouping.append(value)
    def insert_grouping_at(self, index, value):
        self.grouping.insert(index, value)
    def replace_grouping_at(self, index, value):
        self.grouping[index] = value
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def add_link(self, value):
        self.link.append(value)
    def insert_link_at(self, index, value):
        self.link.insert(index, value)
    def replace_link_at(self, index, value):
        self.link[index] = value
    def get_bookmark(self):
        return self.bookmark
    def set_bookmark(self, bookmark):
        self.bookmark = bookmark
    def add_bookmark(self, value):
        self.bookmark.append(value)
    def insert_bookmark_at(self, index, value):
        self.bookmark.insert(index, value)
    def replace_bookmark_at(self, index, value):
        self.bookmark[index] = value
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_implicit(self):
        return self.implicit
    def set_implicit(self, implicit):
        self.implicit = implicit
    def get_non_controlling(self):
        return self.non_controlling
    def set_non_controlling(self, non_controlling):
        self.non_controlling = non_controlling
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_measure_text(self, value):
        # Validate type measure-text, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on measure-text' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.note or
            self.backup or
            self.forward or
            self.direction or
            self.attributes or
            self.harmony or
            self.figured_bass or
            self.print or
            self.sound or
            self.listening or
            self.barline or
            self.grouping or
            self.link or
            self.bookmark
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('measureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'measureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='measureType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='measureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='measureType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.number), input_name='number')), ))
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.implicit is not None and 'implicit' not in already_processed:
            already_processed.add('implicit')
            outfile.write(' implicit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.implicit), input_name='implicit')), ))
        if self.non_controlling is not None and 'non_controlling' not in already_processed:
            already_processed.add('non_controlling')
            outfile.write(' non-controlling=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.non_controlling), input_name='non-controlling')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_decimal(self.width, input_name='width'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for note_ in self.note:
            namespaceprefix_ = self.note_nsprefix_ + ':' if (UseCapturedNS_ and self.note_nsprefix_) else ''
            note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='note', pretty_print=pretty_print)
        for backup_ in self.backup:
            namespaceprefix_ = self.backup_nsprefix_ + ':' if (UseCapturedNS_ and self.backup_nsprefix_) else ''
            backup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='backup', pretty_print=pretty_print)
        for forward_ in self.forward:
            namespaceprefix_ = self.forward_nsprefix_ + ':' if (UseCapturedNS_ and self.forward_nsprefix_) else ''
            forward_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forward', pretty_print=pretty_print)
        for direction_ in self.direction:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            direction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='direction', pretty_print=pretty_print)
        for attributes_ in self.attributes:
            namespaceprefix_ = self.attributes_nsprefix_ + ':' if (UseCapturedNS_ and self.attributes_nsprefix_) else ''
            attributes_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attributes', pretty_print=pretty_print)
        for harmony_ in self.harmony:
            namespaceprefix_ = self.harmony_nsprefix_ + ':' if (UseCapturedNS_ and self.harmony_nsprefix_) else ''
            harmony_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='harmony', pretty_print=pretty_print)
        for figured_bass_ in self.figured_bass:
            namespaceprefix_ = self.figured_bass_nsprefix_ + ':' if (UseCapturedNS_ and self.figured_bass_nsprefix_) else ''
            figured_bass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='figured-bass', pretty_print=pretty_print)
        for print_ in self.print:
            namespaceprefix_ = self.print_nsprefix_ + ':' if (UseCapturedNS_ and self.print_nsprefix_) else ''
            print_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='print', pretty_print=pretty_print)
        for sound_ in self.sound:
            namespaceprefix_ = self.sound_nsprefix_ + ':' if (UseCapturedNS_ and self.sound_nsprefix_) else ''
            sound_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sound', pretty_print=pretty_print)
        for listening_ in self.listening:
            namespaceprefix_ = self.listening_nsprefix_ + ':' if (UseCapturedNS_ and self.listening_nsprefix_) else ''
            listening_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listening', pretty_print=pretty_print)
        for barline_ in self.barline:
            namespaceprefix_ = self.barline_nsprefix_ + ':' if (UseCapturedNS_ and self.barline_nsprefix_) else ''
            barline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='barline', pretty_print=pretty_print)
        for grouping_ in self.grouping:
            namespaceprefix_ = self.grouping_nsprefix_ + ':' if (UseCapturedNS_ and self.grouping_nsprefix_) else ''
            grouping_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='grouping', pretty_print=pretty_print)
        for link_ in self.link:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            link_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for bookmark_ in self.bookmark:
            namespaceprefix_ = self.bookmark_nsprefix_ + ':' if (UseCapturedNS_ and self.bookmark_nsprefix_) else ''
            bookmark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bookmark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
            self.number = ' '.join(self.number.split())
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
            self.validate_measure_text(self.text)    # validate type measure-text
        value = find_attr_value_('implicit', node)
        if value is not None and 'implicit' not in already_processed:
            already_processed.add('implicit')
            self.implicit = value
            self.implicit = ' '.join(self.implicit.split())
            self.validate_yes_no(self.implicit)    # validate type yes-no
        value = find_attr_value_('non-controlling', node)
        if value is not None and 'non-controlling' not in already_processed:
            already_processed.add('non-controlling')
            self.non_controlling = value
            self.non_controlling = ' '.join(self.non_controlling.split())
            self.validate_yes_no(self.non_controlling)    # validate type yes-no
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_decimal(value, node, 'width')
            self.width = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'note':
            obj_ = note.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
        elif nodeName_ == 'backup':
            obj_ = backup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.backup.append(obj_)
            obj_.original_tagname_ = 'backup'
        elif nodeName_ == 'forward':
            obj_ = forward.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward.append(obj_)
            obj_.original_tagname_ = 'forward'
        elif nodeName_ == 'direction':
            obj_ = direction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.direction.append(obj_)
            obj_.original_tagname_ = 'direction'
        elif nodeName_ == 'attributes':
            obj_ = attributes.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attributes.append(obj_)
            obj_.original_tagname_ = 'attributes'
        elif nodeName_ == 'harmony':
            obj_ = harmony.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.harmony.append(obj_)
            obj_.original_tagname_ = 'harmony'
        elif nodeName_ == 'figured-bass':
            obj_ = figured_bass.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.figured_bass.append(obj_)
            obj_.original_tagname_ = 'figured-bass'
        elif nodeName_ == 'print':
            obj_ = print.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.print.append(obj_)
            obj_.original_tagname_ = 'print'
        elif nodeName_ == 'sound':
            obj_ = sound.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sound.append(obj_)
            obj_.original_tagname_ = 'sound'
        elif nodeName_ == 'listening':
            obj_ = listening.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listening.append(obj_)
            obj_.original_tagname_ = 'listening'
        elif nodeName_ == 'barline':
            obj_ = barline.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.barline.append(obj_)
            obj_.original_tagname_ = 'barline'
        elif nodeName_ == 'grouping':
            obj_ = grouping.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.grouping.append(obj_)
            obj_.original_tagname_ = 'grouping'
        elif nodeName_ == 'link':
            obj_ = link.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'bookmark':
            obj_ = bookmark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bookmark.append(obj_)
            obj_.original_tagname_ = 'bookmark'
# end class measureType


class measureType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, text=None, implicit=None, non_controlling=None, width=None, id=None, part=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.implicit = _cast(None, implicit)
        self.implicit_nsprefix_ = None
        self.non_controlling = _cast(None, non_controlling)
        self.non_controlling_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if part is None:
            self.part = []
        else:
            self.part = part
        self.part_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, measureType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if measureType1.subclass:
            return measureType1.subclass(*args_, **kwargs_)
        else:
            return measureType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def add_part(self, value):
        self.part.append(value)
    def insert_part_at(self, index, value):
        self.part.insert(index, value)
    def replace_part_at(self, index, value):
        self.part[index] = value
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_implicit(self):
        return self.implicit
    def set_implicit(self, implicit):
        self.implicit = implicit
    def get_non_controlling(self):
        return self.non_controlling
    def set_non_controlling(self, non_controlling):
        self.non_controlling = non_controlling
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_measure_text(self, value):
        # Validate type measure-text, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on measure-text' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.part
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measureType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('measureType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'measureType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='measureType1')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='measureType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='measureType1'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.number), input_name='number')), ))
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.implicit is not None and 'implicit' not in already_processed:
            already_processed.add('implicit')
            outfile.write(' implicit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.implicit), input_name='implicit')), ))
        if self.non_controlling is not None and 'non_controlling' not in already_processed:
            already_processed.add('non_controlling')
            outfile.write(' non-controlling=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.non_controlling), input_name='non-controlling')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_decimal(self.width, input_name='width'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='measureType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for part_ in self.part:
            namespaceprefix_ = self.part_nsprefix_ + ':' if (UseCapturedNS_ and self.part_nsprefix_) else ''
            part_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
            self.number = ' '.join(self.number.split())
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
            self.text = ' '.join(self.text.split())
            self.validate_measure_text(self.text)    # validate type measure-text
        value = find_attr_value_('implicit', node)
        if value is not None and 'implicit' not in already_processed:
            already_processed.add('implicit')
            self.implicit = value
            self.implicit = ' '.join(self.implicit.split())
            self.validate_yes_no(self.implicit)    # validate type yes-no
        value = find_attr_value_('non-controlling', node)
        if value is not None and 'non-controlling' not in already_processed:
            already_processed.add('non-controlling')
            self.non_controlling = value
            self.non_controlling = ' '.join(self.non_controlling.split())
            self.validate_yes_no(self.non_controlling)    # validate type yes-no
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_decimal(value, node, 'width')
            self.width = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'part':
            obj_ = partType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part.append(obj_)
            obj_.original_tagname_ = 'part'
# end class measureType1


class partType2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, note=None, backup=None, forward=None, direction=None, attributes=None, harmony=None, figured_bass=None, print=None, sound=None, listening=None, barline=None, grouping=None, link=None, bookmark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None
        if backup is None:
            self.backup = []
        else:
            self.backup = backup
        self.backup_nsprefix_ = None
        if forward is None:
            self.forward = []
        else:
            self.forward = forward
        self.forward_nsprefix_ = None
        if direction is None:
            self.direction = []
        else:
            self.direction = direction
        self.direction_nsprefix_ = None
        if attributes is None:
            self.attributes = []
        else:
            self.attributes = attributes
        self.attributes_nsprefix_ = None
        if harmony is None:
            self.harmony = []
        else:
            self.harmony = harmony
        self.harmony_nsprefix_ = None
        if figured_bass is None:
            self.figured_bass = []
        else:
            self.figured_bass = figured_bass
        self.figured_bass_nsprefix_ = None
        if print is None:
            self.print = []
        else:
            self.print = print
        self.print_nsprefix_ = None
        if sound is None:
            self.sound = []
        else:
            self.sound = sound
        self.sound_nsprefix_ = None
        if listening is None:
            self.listening = []
        else:
            self.listening = listening
        self.listening_nsprefix_ = None
        if barline is None:
            self.barline = []
        else:
            self.barline = barline
        self.barline_nsprefix_ = None
        if grouping is None:
            self.grouping = []
        else:
            self.grouping = grouping
        self.grouping_nsprefix_ = None
        if link is None:
            self.link = []
        else:
            self.link = link
        self.link_nsprefix_ = None
        if bookmark is None:
            self.bookmark = []
        else:
            self.bookmark = bookmark
        self.bookmark_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, partType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if partType2.subclass:
            return partType2.subclass(*args_, **kwargs_)
        else:
            return partType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def get_backup(self):
        return self.backup
    def set_backup(self, backup):
        self.backup = backup
    def add_backup(self, value):
        self.backup.append(value)
    def insert_backup_at(self, index, value):
        self.backup.insert(index, value)
    def replace_backup_at(self, index, value):
        self.backup[index] = value
    def get_forward(self):
        return self.forward
    def set_forward(self, forward):
        self.forward = forward
    def add_forward(self, value):
        self.forward.append(value)
    def insert_forward_at(self, index, value):
        self.forward.insert(index, value)
    def replace_forward_at(self, index, value):
        self.forward[index] = value
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def add_direction(self, value):
        self.direction.append(value)
    def insert_direction_at(self, index, value):
        self.direction.insert(index, value)
    def replace_direction_at(self, index, value):
        self.direction[index] = value
    def get_attributes(self):
        return self.attributes
    def set_attributes(self, attributes):
        self.attributes = attributes
    def add_attributes(self, value):
        self.attributes.append(value)
    def insert_attributes_at(self, index, value):
        self.attributes.insert(index, value)
    def replace_attributes_at(self, index, value):
        self.attributes[index] = value
    def get_harmony(self):
        return self.harmony
    def set_harmony(self, harmony):
        self.harmony = harmony
    def add_harmony(self, value):
        self.harmony.append(value)
    def insert_harmony_at(self, index, value):
        self.harmony.insert(index, value)
    def replace_harmony_at(self, index, value):
        self.harmony[index] = value
    def get_figured_bass(self):
        return self.figured_bass
    def set_figured_bass(self, figured_bass):
        self.figured_bass = figured_bass
    def add_figured_bass(self, value):
        self.figured_bass.append(value)
    def insert_figured_bass_at(self, index, value):
        self.figured_bass.insert(index, value)
    def replace_figured_bass_at(self, index, value):
        self.figured_bass[index] = value
    def get_print(self):
        return self.print
    def set_print(self, print):
        self.print = print
    def add_print(self, value):
        self.print.append(value)
    def insert_print_at(self, index, value):
        self.print.insert(index, value)
    def replace_print_at(self, index, value):
        self.print[index] = value
    def get_sound(self):
        return self.sound
    def set_sound(self, sound):
        self.sound = sound
    def add_sound(self, value):
        self.sound.append(value)
    def insert_sound_at(self, index, value):
        self.sound.insert(index, value)
    def replace_sound_at(self, index, value):
        self.sound[index] = value
    def get_listening(self):
        return self.listening
    def set_listening(self, listening):
        self.listening = listening
    def add_listening(self, value):
        self.listening.append(value)
    def insert_listening_at(self, index, value):
        self.listening.insert(index, value)
    def replace_listening_at(self, index, value):
        self.listening[index] = value
    def get_barline(self):
        return self.barline
    def set_barline(self, barline):
        self.barline = barline
    def add_barline(self, value):
        self.barline.append(value)
    def insert_barline_at(self, index, value):
        self.barline.insert(index, value)
    def replace_barline_at(self, index, value):
        self.barline[index] = value
    def get_grouping(self):
        return self.grouping
    def set_grouping(self, grouping):
        self.grouping = grouping
    def add_grouping(self, value):
        self.grouping.append(value)
    def insert_grouping_at(self, index, value):
        self.grouping.insert(index, value)
    def replace_grouping_at(self, index, value):
        self.grouping[index] = value
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def add_link(self, value):
        self.link.append(value)
    def insert_link_at(self, index, value):
        self.link.insert(index, value)
    def replace_link_at(self, index, value):
        self.link[index] = value
    def get_bookmark(self):
        return self.bookmark
    def set_bookmark(self, bookmark):
        self.bookmark = bookmark
    def add_bookmark(self, value):
        self.bookmark.append(value)
    def insert_bookmark_at(self, index, value):
        self.bookmark.insert(index, value)
    def replace_bookmark_at(self, index, value):
        self.bookmark[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.note or
            self.backup or
            self.forward or
            self.direction or
            self.attributes or
            self.harmony or
            self.figured_bass or
            self.print or
            self.sound or
            self.listening or
            self.barline or
            self.grouping or
            self.link or
            self.bookmark
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='partType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('partType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'partType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='partType2')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='partType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='partType2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='partType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for note_ in self.note:
            namespaceprefix_ = self.note_nsprefix_ + ':' if (UseCapturedNS_ and self.note_nsprefix_) else ''
            note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='note', pretty_print=pretty_print)
        for backup_ in self.backup:
            namespaceprefix_ = self.backup_nsprefix_ + ':' if (UseCapturedNS_ and self.backup_nsprefix_) else ''
            backup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='backup', pretty_print=pretty_print)
        for forward_ in self.forward:
            namespaceprefix_ = self.forward_nsprefix_ + ':' if (UseCapturedNS_ and self.forward_nsprefix_) else ''
            forward_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forward', pretty_print=pretty_print)
        for direction_ in self.direction:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            direction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='direction', pretty_print=pretty_print)
        for attributes_ in self.attributes:
            namespaceprefix_ = self.attributes_nsprefix_ + ':' if (UseCapturedNS_ and self.attributes_nsprefix_) else ''
            attributes_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='attributes', pretty_print=pretty_print)
        for harmony_ in self.harmony:
            namespaceprefix_ = self.harmony_nsprefix_ + ':' if (UseCapturedNS_ and self.harmony_nsprefix_) else ''
            harmony_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='harmony', pretty_print=pretty_print)
        for figured_bass_ in self.figured_bass:
            namespaceprefix_ = self.figured_bass_nsprefix_ + ':' if (UseCapturedNS_ and self.figured_bass_nsprefix_) else ''
            figured_bass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='figured-bass', pretty_print=pretty_print)
        for print_ in self.print:
            namespaceprefix_ = self.print_nsprefix_ + ':' if (UseCapturedNS_ and self.print_nsprefix_) else ''
            print_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='print', pretty_print=pretty_print)
        for sound_ in self.sound:
            namespaceprefix_ = self.sound_nsprefix_ + ':' if (UseCapturedNS_ and self.sound_nsprefix_) else ''
            sound_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sound', pretty_print=pretty_print)
        for listening_ in self.listening:
            namespaceprefix_ = self.listening_nsprefix_ + ':' if (UseCapturedNS_ and self.listening_nsprefix_) else ''
            listening_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listening', pretty_print=pretty_print)
        for barline_ in self.barline:
            namespaceprefix_ = self.barline_nsprefix_ + ':' if (UseCapturedNS_ and self.barline_nsprefix_) else ''
            barline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='barline', pretty_print=pretty_print)
        for grouping_ in self.grouping:
            namespaceprefix_ = self.grouping_nsprefix_ + ':' if (UseCapturedNS_ and self.grouping_nsprefix_) else ''
            grouping_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='grouping', pretty_print=pretty_print)
        for link_ in self.link:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            link_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for bookmark_ in self.bookmark:
            namespaceprefix_ = self.bookmark_nsprefix_ + ':' if (UseCapturedNS_ and self.bookmark_nsprefix_) else ''
            bookmark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bookmark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'note':
            obj_ = note.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
        elif nodeName_ == 'backup':
            obj_ = backup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.backup.append(obj_)
            obj_.original_tagname_ = 'backup'
        elif nodeName_ == 'forward':
            obj_ = forward.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward.append(obj_)
            obj_.original_tagname_ = 'forward'
        elif nodeName_ == 'direction':
            obj_ = direction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.direction.append(obj_)
            obj_.original_tagname_ = 'direction'
        elif nodeName_ == 'attributes':
            obj_ = attributes.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.attributes.append(obj_)
            obj_.original_tagname_ = 'attributes'
        elif nodeName_ == 'harmony':
            obj_ = harmony.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.harmony.append(obj_)
            obj_.original_tagname_ = 'harmony'
        elif nodeName_ == 'figured-bass':
            obj_ = figured_bass.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.figured_bass.append(obj_)
            obj_.original_tagname_ = 'figured-bass'
        elif nodeName_ == 'print':
            obj_ = print.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.print.append(obj_)
            obj_.original_tagname_ = 'print'
        elif nodeName_ == 'sound':
            obj_ = sound.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sound.append(obj_)
            obj_.original_tagname_ = 'sound'
        elif nodeName_ == 'listening':
            obj_ = listening.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listening.append(obj_)
            obj_.original_tagname_ = 'listening'
        elif nodeName_ == 'barline':
            obj_ = barline.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.barline.append(obj_)
            obj_.original_tagname_ = 'barline'
        elif nodeName_ == 'grouping':
            obj_ = grouping.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.grouping.append(obj_)
            obj_.original_tagname_ = 'grouping'
        elif nodeName_ == 'link':
            obj_ = link.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'bookmark':
            obj_ = bookmark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bookmark.append(obj_)
            obj_.original_tagname_ = 'bookmark'
# end class partType2


class metronome_tuplet(time_modification):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = time_modification
    def __init__(self, actual_notes=None, normal_notes=None, normal_type=None, normal_dot=None, type_=None, bracket=None, show_number=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("metronome_tuplet"), self).__init__(actual_notes, normal_notes, normal_type, normal_dot,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.bracket = _cast(None, bracket)
        self.bracket_nsprefix_ = None
        self.show_number = _cast(None, show_number)
        self.show_number_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metronome_tuplet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metronome_tuplet.subclass:
            return metronome_tuplet.subclass(*args_, **kwargs_)
        else:
            return metronome_tuplet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_bracket(self):
        return self.bracket
    def set_bracket(self, bracket):
        self.bracket = bracket
    def get_show_number(self):
        return self.show_number
    def set_show_number(self, show_number):
        self.show_number = show_number
    def validate_start_stop(self, value):
        # Validate type start-stop, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'stop']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on start-stop' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_yes_no(self, value):
        # Validate type yes-no, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on yes-no' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_show_tuplet(self, value):
        # Validate type show-tuplet, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['actual', 'both', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on show-tuplet' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            super(metronome_tuplet, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome-tuplet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metronome-tuplet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metronome-tuplet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metronome-tuplet')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metronome-tuplet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metronome-tuplet'):
        super(metronome_tuplet, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metronome-tuplet')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.bracket is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            outfile.write(' bracket=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bracket), input_name='bracket')), ))
        if self.show_number is not None and 'show_number' not in already_processed:
            already_processed.add('show_number')
            outfile.write(' show-number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show_number), input_name='show-number')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metronome-tuplet', fromsubclass_=False, pretty_print=True):
        super(metronome_tuplet, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_start_stop(self.type_)    # validate type start-stop
        value = find_attr_value_('bracket', node)
        if value is not None and 'bracket' not in already_processed:
            already_processed.add('bracket')
            self.bracket = value
            self.bracket = ' '.join(self.bracket.split())
            self.validate_yes_no(self.bracket)    # validate type yes-no
        value = find_attr_value_('show-number', node)
        if value is not None and 'show-number' not in already_processed:
            already_processed.add('show-number')
            self.show_number = value
            self.show_number = ' '.join(self.show_number.split())
            self.validate_show_tuplet(self.show_number)    # validate type show-tuplet
        super(metronome_tuplet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(metronome_tuplet, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class metronome_tuplet


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'score_partwise'
        rootClass = score_partwise
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'score_partwise'
        rootClass = score_partwise
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'score_partwise'
        rootClass = score_partwise
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'score_partwise'
        rootClass = score_partwise
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from musicxml import *\n\n')
        sys.stdout.write('import musicxml as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://www.w3.org/1999/xlink': [], 'http://www.w3.org/XML/1998/namespace': []}

__all__ = [
    "accidental",
    "accidental_mark",
    "accidental_text",
    "accord",
    "accordion_registration",
    "appearance",
    "arpeggiate",
    "arrow",
    "articulations",
    "assess",
    "attributes",
    "backup",
    "bar_style_color",
    "barline",
    "barre",
    "bass",
    "bass_step",
    "beam",
    "beat_repeat",
    "beat_unit_tied",
    "beater",
    "bend",
    "bookmark",
    "bracket",
    "breath_mark",
    "caesura",
    "cancel",
    "clef",
    "coda",
    "credit",
    "dashes",
    "defaults",
    "degree",
    "degree_alter",
    "degree_type",
    "degree_value",
    "direction",
    "direction_type",
    "directiveType",
    "distance",
    "double",
    "dynamics",
    "effect",
    "elision",
    "empty",
    "empty_font",
    "empty_line",
    "empty_placement",
    "empty_placement_smufl",
    "empty_print_object_style_align",
    "empty_print_style",
    "empty_print_style_align",
    "empty_print_style_align_id",
    "empty_trill_sound",
    "encoding",
    "ending",
    "extend",
    "feature",
    "fermata",
    "figure",
    "figured_bass",
    "fingering",
    "first_fret",
    "for_part",
    "formatted_symbol",
    "formatted_symbol_id",
    "formatted_text",
    "formatted_text_id",
    "forward",
    "frame",
    "frame_note",
    "fret",
    "glass",
    "glissando",
    "glyph",
    "grace",
    "group_barline",
    "group_name",
    "group_symbol",
    "grouping",
    "hammer_on_pull_off",
    "handbell",
    "harmon_closed",
    "harmon_mute",
    "harmonic",
    "harmony",
    "harmony_alter",
    "harp_pedals",
    "heel_toe",
    "hole",
    "hole_closed",
    "horizontal_turn",
    "identification",
    "image",
    "instrument",
    "instrument_change",
    "instrument_link",
    "interchangeable",
    "inversion",
    "key",
    "key_accidental",
    "key_octave",
    "kind",
    "level",
    "line_detail",
    "line_width",
    "link",
    "listen",
    "listening",
    "lyric",
    "lyric_font",
    "lyric_language",
    "measureType",
    "measureType1",
    "measure_layout",
    "measure_numbering",
    "measure_repeat",
    "measure_style",
    "membrane",
    "metal",
    "metronome",
    "metronome_beam",
    "metronome_note",
    "metronome_tied",
    "metronome_tuplet",
    "midi_device",
    "midi_instrument",
    "miscellaneous",
    "miscellaneous_field",
    "mordent",
    "multiple_rest",
    "name_display",
    "non_arpeggiate",
    "notations",
    "note",
    "note_size",
    "note_type",
    "notehead",
    "notehead_text",
    "numeral",
    "numeral_key",
    "numeral_root",
    "octave_shift",
    "offset",
    "opus",
    "ornaments",
    "other_appearance",
    "other_direction",
    "other_listening",
    "other_notation",
    "other_placement_text",
    "other_play",
    "other_text",
    "page_layout",
    "page_margins",
    "partType",
    "partType2",
    "part_clef",
    "part_group",
    "part_link",
    "part_list",
    "part_name",
    "part_symbol",
    "part_transpose",
    "pedal",
    "pedal_tuning",
    "per_minute",
    "percussion",
    "pitch",
    "pitched",
    "placement_text",
    "play",
    "player",
    "principal_voice",
    "print",
    "release",
    "repeat",
    "rest",
    "root",
    "root_step",
    "scaling",
    "scordatura",
    "score_instrument",
    "score_part",
    "score_partwise",
    "score_timewise",
    "segno",
    "slash",
    "slide",
    "slur",
    "sound",
    "staff_details",
    "staff_divide",
    "staff_layout",
    "staff_size",
    "staff_tuning",
    "stem",
    "stick",
    "string",
    "string_mute",
    "strong_accent",
    "style_text",
    "supports",
    "swing",
    "sync",
    "system_dividers",
    "system_layout",
    "system_margins",
    "tap",
    "technical",
    "text_element_data",
    "tie",
    "tied",
    "time",
    "time_modification",
    "timpani",
    "transpose",
    "tremolo",
    "tuplet",
    "tuplet_dot",
    "tuplet_number",
    "tuplet_portion",
    "tuplet_type",
    "typed_text",
    "unpitched",
    "virtual_instrument",
    "wait",
    "wavy_line",
    "wedge",
    "wood",
    "work"
]
