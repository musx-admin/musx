'''
Author: Michael Gogins

This module translates MIDI files generated by musx to standard Csound scores
where each note is an "i" statement in the format:
```
i instrument_number time_seconds duration_seconds midi_key midi_velocity
```
Assigns a duration to the event at the given index in the given MIDI sequence.
If the event is a note on event, the duration is the difference between the 
time of the first matching note off message and the time of the note on event.

For unisons, the first note on is also the first note turned off.
'''
import math
from musx.midi import MidiNote, MidiSeq, MidiFile

'''
Assuming the event at the index is a note on event, searches forwards in time 
in the sequence until the first note off event whose MIDI channel and MIDI key 
number match the note on event, and which has not already been used as a note 
off event, e.g. in a unison. When a match is found, the duration is obtained 
and assigned to the note on event, and the note off is saved in a set that 
identified it as having already been used. Thus, in unisons, the first note on 
events are also the first notes turned off.
'''
def assign_duration(index, midiseq, turnoffs):
    event = midiseq[index]
    event.duration = 0
    if event.is_note_on() == True:
        for off_index in range(index, len(midiseq)):
            note_off = midiseq[off_index]
            # Value semantics are required here.
            note_off_key = (note_off.channel, note_off.keynum)
            if note_off_key not in turnoffs:
                if note_off.is_note_off():
                    if note_off.keynum() == event.keynum() and note_off.channel() == event.channel():
                        event.duration = note_off.time - event.time
                        turnoffs.add(note_off_key)
                        break
    return event
    
'''
Assigns a duration to each MIDI event in each MIDI sequence in the MIDI file.
'''
def assign_durations(midifile):
    for track in midifile:
        turnoffs = set()
        for index in range(len(track)):
            event = assign_duration(index, track, turnoffs)
                
'''
Translates the MIDI event into a Csound "i" statement.
'''
def to_i_statement(channel, time_, duration, midi_key, midi_velocity):
    i_statement = "i {} {} {} {} {}".format(1 + channel, time_, duration, midi_key, midi_velocity)
    return i_statement
    
'''
Returns a Csound score file as a single string, translated from the MIDI file.
It is assumed that times are in seconds.
'''
def to_csound_score(midifile):
    assign_durations(midifile)
    fractional_keys_for_channels, channels_per_instrument = tuning_system(midifile)
    csound_score = []
    for track in midifile:
        for event in track:
            if event.is_note_on():
                if event.duration > 0:
                    channel = event.channel()
                    key = event.keynum()
                    # Adjust channel and MIDI key for microtonality?
                    if channels_per_instrument > 1:
                        fraction = fractional_keys_for_channels[channel]
                        fractional_key = key + fraction
                        #print("fractional_key:", fractional_key, "original channel:", channel)
                        channel = math.floor(channel / channels_per_instrument)
                        #print("corrected channel:", channel)
                        key = fractional_key
                    i_statement = to_i_statement(channel, event.time, event.duration, key, event.velocity())
                    csound_score.append(i_statement + "\n")
    return ''.join(csound_score)
    
'''
Assuming that musx's system of microtonality is being used, returns 
a lookup table of fractional MIDI keys to be added to note on and note off 
messages for each channel; also returns the number of channels used for 
each (microtonal) instrument.
'''
def tuning_system(midifile):
    semitones_for_channels = {}
    for midiseq in midifile:
        for event in midiseq:
            if event.is_pitch_bend() == True:
                channel = event.channel()
                # No pitch bend is 0x2000.
                # Find the fractional part of the MIDI key number.
                fractional_key = (event.bend() - 0x2000) / 4000
                print("pitch bend: channel: {:3d} bend: {:6d} fractional key: {}".format(channel, event.bend(), fractional_key))
                semitones_for_channels[channel] = fractional_key
    # Find the number of MIDI channels used per microtonal instrument.
    channels_per_instrument = 0
    zeroes = 0
    for key, value in semitones_for_channels.items():
        if value == 0:
            zeroes = zeroes + 1
            if zeroes > 1:
                break
        channels_per_instrument = channels_per_instrument + 1
    print("MIDI channels per microtonal instrument:", channels_per_instrument)
    return semitones_for_channels, channels_per_instrument

