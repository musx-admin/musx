<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>musx.paint API documentation</title>
<meta name="description" content="The paint.py module provides two high-level composers that can produce a wide
variety of interesting textures and music. The `brush()` composer â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>musx.paint</code></h1>
</header>
<section id="section-intro">
<p>The paint.py module provides two high-level composers that can produce a wide
variety of interesting textures and music. The <code><a title="musx.paint.brush" href="#musx.paint.brush">brush()</a></code> composer outputs Notes
in sequential order, similar to how a paint brush makes lines on a canvas. In
contrast, the <code><a title="musx.paint.spray" href="#musx.paint.spray">spray()</a></code> composer generates Notes by applying random selection
to its input parameters.</p>
<p>For examples of using paint.py see gamelan.py, blues.py and messiaen.py in
the demos directory.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">###############################################################################
&#34;&#34;&#34;
The paint.py module provides two high-level composers that can produce a wide
variety of interesting textures and music. The `brush()` composer outputs Notes
in sequential order, similar to how a paint brush makes lines on a canvas. In
contrast, the `spray()` composer generates Notes by applying random selection
to its input parameters.

For examples of using paint.py see gamelan.py, blues.py and messiaen.py in
the demos directory.
&#34;&#34;&#34;


from musx import Note, cycle, choose


def brush(score, *, length=None, end=None, rhythm=.5, duration=None, pitch=60, amplitude=.5, instrument=0, microdivs=1):
    &#34;&#34;&#34;
    Outputs Notes in sequential order, automatically looping parameter
    list values until the algorithm stops.

    Parameters
    ----------
    score : Score
        The Notes that are generated will be added to this score.
    length : number
        The number of MIDI events to generate. Either length or end must be
        specified.
    end : number
        An end time after which no more events will be generated.
        Either end or length must be specified.
    rhythm : number | list
        A rhythm or list of rhythms that specify the amount of time to wait
        between notes. Negative rhythm values are interpreted as musical
        rests, i.e. events are not output but time advances. The default value
        is 0.5.
    duration : number | list
        A duration or list of durations that specify the amount of time each 
        MIDI event lasts. The default value is the current rhythm.
    pitch : number | list
        A MIDI key number or list of key numbers to play. The list can contain
        sublists of key numbers; in this case each sublist is treated as a 
        chord (the key numbers in the sublist are performed simultaneously.)
    amplitude : number | list
        A value or list of values between 0.0 and 1.0 for determining the 
        loudness of the MIDI events.
    instrument : number | list
        A MIDI channel number 0 to 15, or a list of channel numbers. Channel 
        value 9 will send events to the synthesizer&#39;s drum map for triggering
        various percussion sounds.
    tuning : int 
        A value 1 to 16 setting the divisions per semitone used for microtonal
        quantization of floating point keynums. See Note, Seq and the
        micro.py demo file for more information. 
    &#34;&#34;&#34;
    # user must specify either length or end parameter
    counter = 0
    if length:
        if end: raise TypeError(&#34;specify either length or end, not both.&#34;)
        stopitr = length
        thisitr = (lambda: counter)
    else:
        if not end: raise TypeError(&#34;specify either length or end.&#34;)
        stopitr = end
        thisitr = (lambda: score.elapsed)
    # convert all values into cycles
    cyc = (lambda x: cycle(x if type(x) is list else [x]))
    rhy = cyc(rhythm)
    dur = cyc(duration)
    key = cyc(pitch)
    amp = cyc(amplitude)
    chan = cyc(instrument)
    while (thisitr() &lt; stopitr):
        t = score.now
        #print(&#34;counter=&#34;, counter, &#34;now=&#34;, t)
        r = next(rhy)
        d = next(dur)
        k = next(key)
        a = next(amp)
        c = next(chan)
        if r &gt; 0:
            if not d: d = r
            if type(k) is list:
                for j in k: 
                    m = Note(time=t, duration=d, pitch=j, amplitude=a, instrument=c)
                    score.add(m)
            else:
                m = Note(time=t, duration=d, pitch=k, amplitude=a, instrument=c)
                score.add(m)
        counter += 1
        yield abs(r)


def spray(score, *, length=None, end=None, rhythm=.5, duration=None, pitch= 60, band=0, amplitude=.5, instrument=0):
    &#34;&#34;&#34;
    Generates Notes using discrete random selection. Most parameters allow
    lists of values to be specified, in which case elements are randomly selected
    from the lists every time an event is output.

    Parameters
    ----------
    Parameters are the same as brush() except for these changes or additions:

    pitch : number | list
        A MIDI key number or list of key numbers to play. If a list is specified
        a key number is randomly selected from the list for each midi event.

    band : number | list
        A number is treated as a half-step range on either side of the current
        key choice from which the next key number will be chosen.  If a list of
        intervals is specified then randomly selected intervals are added
        added to the current key number to determine the key number played.
        The list can also contain sublists of intervals, in which case each
        sublist is treated as a chord, i.e. the intervals in the sublist are
        added to the current key and performed simultaneously.
    &#34;&#34;&#34; 
    # user must specify either length or end parameter
    counter = 0
    if length:
        if end: raise TypeError(&#34;specify either leng or end, not both.&#34;)
        stopitr = length
        thisitr = (lambda: counter)
    else:
        if not end: raise TypeError(&#34;specify either length or end.&#34;)
        stopitr = end
        thisitr = (lambda: score.elapsed)
    # convert each param into a chooser pattern.
    ran = (lambda x: choose(x if type(x) is list else [x]))
    rhy = ran(rhythm)
    dur = ran(duration)
    key = ran(pitch)
    amp = ran(amplitude)
    chan = ran(instrument)
    band = choose( [i for i in range(-band, band+1)] if type(band) is int else band )
    while (thisitr() &lt; stopitr):
        t = score.now
        #print(&#34;counter=&#34;, counter, &#34;now=&#34;, t)
        r = next(rhy)
        d = next(dur)
        k = next(key)
        a = next(amp)
        c = next(chan)
        b = next(band)
        if type(b) is list:
            k = [k+i for i in b]
        else:
            k = k + b
        #print(&#34;pitch=&#34;, k, end=&#34; &#34;)
        if r &gt; 0:
            if not d: d = r
            if type(k) is list:
                for j in k:
                    m = Note(time=t, duration=d, pitch=j, amplitude=a, instrument=c)
                    score.add(m)
            else:
                m = Note(time=t, duration=d, pitch=k, amplitude=a, instrument=c)
                score.add(m)
        counter += 1
        yield abs(r)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="musx.paint.brush"><code class="name flex">
<span>def <span class="ident">brush</span></span>(<span>score, *, length=None, end=None, rhythm=0.5, duration=None, pitch=60, amplitude=0.5, instrument=0, microdivs=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs Notes in sequential order, automatically looping parameter
list values until the algorithm stops.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>score</code></strong> :&ensp;<code>Score</code></dt>
<dd>The Notes that are generated will be added to this score.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>number</code></dt>
<dd>The number of MIDI events to generate. Either length or end must be
specified.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>number</code></dt>
<dd>An end time after which no more events will be generated.
Either end or length must be specified.</dd>
<dt><strong><code>rhythm</code></strong> :&ensp;<code>number | list</code></dt>
<dd>A rhythm or list of rhythms that specify the amount of time to wait
between notes. Negative rhythm values are interpreted as musical
rests, i.e. events are not output but time advances. The default value
is 0.5.</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>number | list</code></dt>
<dd>A duration or list of durations that specify the amount of time each
MIDI event lasts. The default value is the current rhythm.</dd>
<dt><strong><code>pitch</code></strong> :&ensp;<code>number | list</code></dt>
<dd>A MIDI key number or list of key numbers to play. The list can contain
sublists of key numbers; in this case each sublist is treated as a
chord (the key numbers in the sublist are performed simultaneously.)</dd>
<dt><strong><code>amplitude</code></strong> :&ensp;<code>number | list</code></dt>
<dd>A value or list of values between 0.0 and 1.0 for determining the
loudness of the MIDI events.</dd>
<dt><strong><code>instrument</code></strong> :&ensp;<code>number | list</code></dt>
<dd>A MIDI channel number 0 to 15, or a list of channel numbers. Channel
value 9 will send events to the synthesizer's drum map for triggering
various percussion sounds.</dd>
<dt><strong><code>tuning</code></strong> :&ensp;<code>int </code></dt>
<dd>A value 1 to 16 setting the divisions per semitone used for microtonal
quantization of floating point keynums. See Note, Seq and the
micro.py demo file for more information.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def brush(score, *, length=None, end=None, rhythm=.5, duration=None, pitch=60, amplitude=.5, instrument=0, microdivs=1):
    &#34;&#34;&#34;
    Outputs Notes in sequential order, automatically looping parameter
    list values until the algorithm stops.

    Parameters
    ----------
    score : Score
        The Notes that are generated will be added to this score.
    length : number
        The number of MIDI events to generate. Either length or end must be
        specified.
    end : number
        An end time after which no more events will be generated.
        Either end or length must be specified.
    rhythm : number | list
        A rhythm or list of rhythms that specify the amount of time to wait
        between notes. Negative rhythm values are interpreted as musical
        rests, i.e. events are not output but time advances. The default value
        is 0.5.
    duration : number | list
        A duration or list of durations that specify the amount of time each 
        MIDI event lasts. The default value is the current rhythm.
    pitch : number | list
        A MIDI key number or list of key numbers to play. The list can contain
        sublists of key numbers; in this case each sublist is treated as a 
        chord (the key numbers in the sublist are performed simultaneously.)
    amplitude : number | list
        A value or list of values between 0.0 and 1.0 for determining the 
        loudness of the MIDI events.
    instrument : number | list
        A MIDI channel number 0 to 15, or a list of channel numbers. Channel 
        value 9 will send events to the synthesizer&#39;s drum map for triggering
        various percussion sounds.
    tuning : int 
        A value 1 to 16 setting the divisions per semitone used for microtonal
        quantization of floating point keynums. See Note, Seq and the
        micro.py demo file for more information. 
    &#34;&#34;&#34;
    # user must specify either length or end parameter
    counter = 0
    if length:
        if end: raise TypeError(&#34;specify either length or end, not both.&#34;)
        stopitr = length
        thisitr = (lambda: counter)
    else:
        if not end: raise TypeError(&#34;specify either length or end.&#34;)
        stopitr = end
        thisitr = (lambda: score.elapsed)
    # convert all values into cycles
    cyc = (lambda x: cycle(x if type(x) is list else [x]))
    rhy = cyc(rhythm)
    dur = cyc(duration)
    key = cyc(pitch)
    amp = cyc(amplitude)
    chan = cyc(instrument)
    while (thisitr() &lt; stopitr):
        t = score.now
        #print(&#34;counter=&#34;, counter, &#34;now=&#34;, t)
        r = next(rhy)
        d = next(dur)
        k = next(key)
        a = next(amp)
        c = next(chan)
        if r &gt; 0:
            if not d: d = r
            if type(k) is list:
                for j in k: 
                    m = Note(time=t, duration=d, pitch=j, amplitude=a, instrument=c)
                    score.add(m)
            else:
                m = Note(time=t, duration=d, pitch=k, amplitude=a, instrument=c)
                score.add(m)
        counter += 1
        yield abs(r)</code></pre>
</details>
</dd>
<dt id="musx.paint.spray"><code class="name flex">
<span>def <span class="ident">spray</span></span>(<span>score, *, length=None, end=None, rhythm=0.5, duration=None, pitch=60, band=0, amplitude=0.5, instrument=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates Notes using discrete random selection. Most parameters allow
lists of values to be specified, in which case elements are randomly selected
from the lists every time an event is output.</p>
<h2 id="parameters">Parameters</h2>
<p>Parameters are the same as brush() except for these changes or additions:</p>
<dl>
<dt><strong><code>pitch</code></strong> :&ensp;<code>number | list</code></dt>
<dd>A MIDI key number or list of key numbers to play. If a list is specified
a key number is randomly selected from the list for each midi event.</dd>
<dt><strong><code>band</code></strong> :&ensp;<code>number | list</code></dt>
<dd>A number is treated as a half-step range on either side of the current
key choice from which the next key number will be chosen.
If a list of
intervals is specified then randomly selected intervals are added
added to the current key number to determine the key number played.
The list can also contain sublists of intervals, in which case each
sublist is treated as a chord, i.e. the intervals in the sublist are
added to the current key and performed simultaneously.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spray(score, *, length=None, end=None, rhythm=.5, duration=None, pitch= 60, band=0, amplitude=.5, instrument=0):
    &#34;&#34;&#34;
    Generates Notes using discrete random selection. Most parameters allow
    lists of values to be specified, in which case elements are randomly selected
    from the lists every time an event is output.

    Parameters
    ----------
    Parameters are the same as brush() except for these changes or additions:

    pitch : number | list
        A MIDI key number or list of key numbers to play. If a list is specified
        a key number is randomly selected from the list for each midi event.

    band : number | list
        A number is treated as a half-step range on either side of the current
        key choice from which the next key number will be chosen.  If a list of
        intervals is specified then randomly selected intervals are added
        added to the current key number to determine the key number played.
        The list can also contain sublists of intervals, in which case each
        sublist is treated as a chord, i.e. the intervals in the sublist are
        added to the current key and performed simultaneously.
    &#34;&#34;&#34; 
    # user must specify either length or end parameter
    counter = 0
    if length:
        if end: raise TypeError(&#34;specify either leng or end, not both.&#34;)
        stopitr = length
        thisitr = (lambda: counter)
    else:
        if not end: raise TypeError(&#34;specify either length or end.&#34;)
        stopitr = end
        thisitr = (lambda: score.elapsed)
    # convert each param into a chooser pattern.
    ran = (lambda x: choose(x if type(x) is list else [x]))
    rhy = ran(rhythm)
    dur = ran(duration)
    key = ran(pitch)
    amp = ran(amplitude)
    chan = ran(instrument)
    band = choose( [i for i in range(-band, band+1)] if type(band) is int else band )
    while (thisitr() &lt; stopitr):
        t = score.now
        #print(&#34;counter=&#34;, counter, &#34;now=&#34;, t)
        r = next(rhy)
        d = next(dur)
        k = next(key)
        a = next(amp)
        c = next(chan)
        b = next(band)
        if type(b) is list:
            k = [k+i for i in b]
        else:
            k = k + b
        #print(&#34;pitch=&#34;, k, end=&#34; &#34;)
        if r &gt; 0:
            if not d: d = r
            if type(k) is list:
                for j in k:
                    m = Note(time=t, duration=d, pitch=j, amplitude=a, instrument=c)
                    score.add(m)
            else:
                m = Note(time=t, duration=d, pitch=k, amplitude=a, instrument=c)
                score.add(m)
        counter += 1
        yield abs(r)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="musx" href="index.html">musx</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="musx.paint.brush" href="#musx.paint.brush">brush</a></code></li>
<li><code><a title="musx.paint.spray" href="#musx.paint.spray">spray</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>