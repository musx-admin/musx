<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>musx.mxml.notation API documentation</title>
<meta name="description" content="A module for loading and saving MusicXml scores. As of Aug &#39;21 file loading is implemented." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>musx.mxml.notation</code></h1>
</header>
<section id="section-intro">
<p>A module for loading and saving MusicXml scores. As of Aug '21 file loading is implemented.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A module for loading and saving MusicXml scores. As of Aug &#39;21 file loading is implemented.
&#34;&#34;&#34;

# creating the MusicXml python file:
# (venv) $ generateDS.py -o musicxml.py --root-element &#34;score_partwise&#34; schema/musicxml.xsd 
#
# Working with low-level lxml Element trees (musicxml.py):
# $ python3
# &gt;&gt;&gt; import musx.mxml.musicxml as musicxml
# &gt;&gt;&gt; musicxml.parse(&#34;Scores/001-2s.xml&#34;) 
#
# Working with high-level Notation objects:
# $ python3
# &gt;&gt;&gt; import musx.mxml.notation as notation
# &gt;&gt;&gt; score = notation.load(&#34;scores/HelloWorld.musicxml&#34;)
# &gt;&gt;&gt; score.print()
#
# &gt;&gt;&gt; from musx.note import Note; from fractions import Fraction; from musx.pitch import Pitch
# &gt;&gt;&gt; n=Note(time=Fraction(0,1), duration=Fraction(1,4), pitch=Pitch(&#34;C4&#34;))
# &gt;&gt;&gt; n.add_child(Note(time=Fraction(0,1), duration=Fraction(1,4), pitch=Pitch(&#34;Fs5&#34;)))
# &gt;&gt;&gt; n.add_child(Note(time=Fraction(0,1), duration=Fraction(1,4), pitch=Pitch(&#34;E1&#34;)))

import re, os
from lxml import etree
from enum import Enum, auto
from fractions import Fraction
from . import musicxml
from .barline import Barline
from .clef import Clef
from .key import Key
from .measure import Measure
from .mode import Mode
from .meter import Meter
from .part import Part
from ..pitch import Pitch
from ..note import Note


# A template dictionary defining the &#39;running status&#39; of MusicXml parsing. The
# load() method copies the template for each score it parses and passes it to
# the parsing routines so they can access and store relevant data:
#   score: The Notation being created
#   part: The current Part. This value resets for every new part.
#   measure: The current measure. This value resets for every new measure and every part.
#   divisions: The current division. This value resets for every new division and every part
#   note: The current note. This value changes for every new note, measure, and part.
#   meter: The most recent meter encountered in the score.
#   key: The most recent key encountered in the score.
#   onset: The Fraction onset time for the next note. This value is reset to 0 for each
#          measure, (or to measureDur - noteDur for partial measures) and incremented
#          by the duration of notes, forwards and backups.
_DATA = {
        &#34;score&#34;: None, &#34;part&#34;: None, &#34;measure&#34;: None, &#34;divisions&#34;: None,
        &#34;note&#34;: None, &#34;meter:&#34;: None, &#34;key&#34;: None, &#34;onset&#34;: None
    }


class Notation():
    &#34;&#34;&#34;
    A class representing a MusicXml score. A Notation contains Part objects and
    metadata. A Part contains Measure objects, and a Measure contains Note objects
    as well as non-event notational objects such as Key, Clef, Meter, Barline.

    Given a Notation you can iterate all its elements like this:
    
    for part in notation:
        for measure in part:
            for element in measure:
                print(element)
    
    To access vertical note structures in the score&#39;s measures you can iterate the
    score&#39;s timepoints like this:

    for measure in notation.timepoints():
        for timepoint in measure:
            print(timepoint)
    &#34;&#34;&#34;
    def __init__(self, metadata={}, parts=[]):
        self.metadata = metadata
        &#34;&#34;&#34;A dictionary of MusicXml score metadata.&#34;&#34;&#34;
        self.parts = []
        &#34;&#34;&#34;The score&#39;s list of musical parts.&#34;&#34;&#34;
        for p in parts:
            self.add_part(p)

    def __iter__(self):
        &#34;&#34;&#34;
        Iterates the Part objects in the Notation.
        &#34;&#34;&#34;     
        return iter(self.parts)
    
    def __repr__(self):
        title = self.metadata.get(&#39;work-title&#39;, None)
        if title is None:
            title = self.metadata.get(&#39;movement-title&#39;, &#39;(untitled)&#39;)
        return f&#39;&lt;Notation: &#34;{title}&#34; {hex(id(self))}&gt;&#39;

    __str__ = __repr__

    def add_part(self, part):
        &#34;&#34;&#34;
        Appends a Part to the Notation&#39;s part list.
        &#34;&#34;&#34;
        part.score = self  # back link from part to its score
        self.parts.append(part)
    
    def print(self):
        &#34;&#34;&#34;
        Recursively prints the contents of the Notation.
        &#34;&#34;&#34;
        pad = &#34;  &#34;
        print(pad*0, self, sep=None)
        for p in self:
            print(pad*1, p, sep=None)
            for m in p:
                print(pad*2, m)
                for e in m:
                    print(pad*3, e)
    
    def timepoints(self, trace=False):
        &#34;&#34;&#34;
        Returns a list of Timepoint objects grouped in measures. See: Timepoint.
        &#34;&#34;&#34;
        # Flop the part measures so all measures with the same id are grouped
        # together, e.g.: [[1,2,3],[1,2,3]] =&gt; [[1,1],[2,2],[3,3]]
        groups = [measures for measures in zip(*[part.measures for part in self])]
        # iterate each group of measures
        timepoints = []
        for group in groups:
            # iterate each measure in the group combining their timepoints
            measurepoints = []
            for measure in group:
                for element in measure:
                    if isinstance(element, Note):
                        ident = f&#34;{measure.part.id}.{measure.id}.{element.get_mxml(&#39;voice&#39;)}&#34;
                        onset = element.time
                        try: 
                            have = next((x for x in measurepoints if x.onset == onset))
                            have.notemap[ident] = element
                        except StopIteration:
                            tp = Timepoint(onset)
                            tp.notemap[ident] = element
                            measurepoints.append(tp)
                
            # sort the measure timepoints by their onsets
            measurepoints.sort()
            if trace:
                for tp in measurepoints:
                    print(str(tp))
                    print(&#39;----------------------------------------------------------------&#39;)
            timepoints.append(measurepoints)
        return timepoints

 
class Timepoint():
    &#34;&#34;&#34;
    A Timepoint is an analytical structure that contains an onset time in a
    measure and the vertical &#39;slice&#39; of all the notes that begin at that beat
    irrespective of which part, staff or voice they belong to. The note 
    entries within each Timepoint are maintained in a dictionary whose keys
    are part.measure.voice identifiers and whose values are the notes that
    begin at the Timepoint&#39;s beat.
    
    Parameters
    ----------
    beat : Fraction
        The metric onset of the timepoint in the measure.
    nmap : dict
        The note map of the timepoint is a dictionary of notes whose
        keys are the part/voice identifiers active in the measure.
    &#34;&#34;&#34;
    def __init__(self, onset):
        ## The ratio start time in the measure.
        self.onset = onset
        ## The note map dictionary, keys are pvids (part/voice identifiers)
        # from the score and values are either Notes, Chords or Rests.
        self.notemap = {}

    def __lt__(self, other):
        &#34;&#34;&#34;
        Returns true if self.beat is less than other, otherwise returns false.
        &#34;&#34;&#34;
        return self.onset &lt; other.onset

    def __str__(self):
        &#34;&#34;&#34;
        Returns a string contains the class name, the self.index attribute,
        and a hexidecimal id.
        &#34;&#34;&#34;
        #return f&#34;&lt;Timepoint {str(self.onset)} {len(self.notemap)}&gt;&#34;
        pstr = &#34;, &#34;.join([n._tagged_pitch_str() for n in self.notemap.values()])
        return f&#34;&lt;Timepoint: {str(self.onset)} ({pstr})&gt;&#34;

    __repr__ = __str__


##############################################################################


def _elementinfo(e):
    &#34;&#34;&#34;
    Helper function prints Element info
    &#34;&#34;&#34;
    return f&#34;tag={e.tag}, attrs={e.attrib}, text=&#39;{e.text.strip() if e.text else &#39;&#39;}&#39;, children={len(e)}&#34;


def _parse_barline(elem, DATA):
    text = None
    repeat = None
    barline = None
    location = elem.get(&#39;location&#39;, &#39;right&#39;) # right, left or middle
    for s in iter(elem): # alterates: elem.getchildren() OR list(elem)
        if s.tag == &#39;bar-style&#39;:
            text = s.text
        elif s.tag == &#39;repeat&#39;:
            repeat = s.get(&#39;direction&#39;)
    #print(&#34;text=&#34;, text, &#34;, repeat=&#34;, repeat)
    if text == &#39;regular&#39;: barline = Barline.Regular(location)
    elif text == &#34;light-light&#34;: barline = Barline.InteriorDouble(location)
    elif text == &#34;light-heavy&#34;:
        if repeat == &#39;backward&#39;: barline = Barline.BackwardRepeat(location)
        else: barline = Barline.FinalDouble(location)
    elif text == &#34;dotted&#34;: barline = Barline.Dotted(location)
    elif text == &#34;dashed&#34;: barline = Barline.Dashed(location)
    elif text == &#34;heavy&#34;: barline = Barline.Heavy(location)
    elif text == &#34;heavy-light&#34;:
        if repeat == &#39;forward&#39;: barline = Barline.ForwardRepeat(location)
        else: barline = Barline.HeavyLight(location)
    elif text == &#34;heavy-heavy&#34;: barline = Barline.HeavyHeavy(location)
    elif text == &#34;tick&#34;: barline = Barline.Tick(location)
    elif text == &#34;short&#34;: barline = Barline.Short(location)
    elif text == &#39;none&#39;: barline = Barline.Regular(location) #Barline.INVISIBLE
    elif text == None: barline = Barline.Regular(location) #Barline.INVISIBLE
    assert barline, f&#34;MusicXml: Invalid barline value: &#39;{text}&#39;.&#34;
    #DATA[&#39;measure&#39;].barlines.append(barline)
    DATA[&#39;measure&#39;].add_element(barline)


def _parse_part(elem, DATA):
    # create a new part and add it to the score
    part = Part()
    part.id = elem.get(&#39;id&#39;)
    DATA[&#39;part&#39;] = part
    DATA[&#39;score&#39;].add_part(part)
    # initialize DATA for the new part.
#    DATA[&#39;divisions&#39;] = 1
    DATA[&#39;measure&#39;] = None
    DATA[&#39;note&#39;] = None
    # added these
    # DATA[&#39;onset&#39;] = None
    # DATA[&#39;meter&#39;] = None
    # DATA[&#39;key&#39;] =  None
    # DATA[&#39;onset&#39;] = None


def _parse_measure(elem, DATA):
    # create a new measure and add it to the part
    measure = Measure(elem.get(&#39;number&#39;))
    if elem.get(&#39;implicit&#39;) == &#39;yes&#39;:
        measure.partial = True
    DATA[&#39;measure&#39;] = measure
    # add the new measure to the part
    DATA[&#39;part&#39;].add_measure(measure)
    # initialize data that resets each measure
    DATA[&#39;note&#39;] = None
    DATA[&#39;onset&#39;] = Fraction(0,1)


def _parse_attributes(elem, DATA):
    measure = DATA[&#39;measure&#39;]
    for s in elem.iter(): 
        if s.tag == &#39;divisions&#39;:
            divs = s.text
            DATA[&#39;divisions&#39;] = int(divs)
        elif s.tag == &#39;clef&#39;:
            sign = s.findtext(&#39;sign&#39;)
            line = s.findtext(&#39;line&#39;)
            staff = int(s.get(&#39;number&#39;, &#34;1&#34;))
            clef = None
            if sign == &#39;G&#39;:
                clef = {&#39;1&#39;: Clef.FrenchViolin(staff), &#39;2&#39;: Clef.Treble(staff)}[line]
            elif sign == &#39;F&#39;:
                clef = {&#39;3&#39;: Clef.BaritoneF(staff), &#39;4&#39;: Clef.Bass(staff), &#39;5&#39;: Clef.SubBass(staff)}[line]
            elif sign == &#39;C&#39;:
                clef = {&#39;1&#39;: Clef.Soprano(staff), &#39;2&#39;: Clef.MezzoSoprano(staff),
                        &#39;3&#39;: Clef.Alto(staff), &#39;4&#39;: Clef.Tenor(staff),&#39;5&#39;: Clef.Baritone(staff)}[line]
            elif sign == &#39;percussion&#39;:
                clef = Clef.Percussion(staff)
            assert clef, f&#34;No clef for sign &#39;{sign}&#39; and line &#39;{line}&#39;&#34;
            #measure.clefs.append(clef)
            measure.add_element(clef)
        elif s.tag == &#39;time&#39;:
            num = s.findtext(&#39;beats&#39;)
            den = s.findtext(&#39;beat-type&#39;)
            staff = int(s.get(&#34;number&#34;, &#34;0&#34;)) # 0=all staffs
            meter = Meter(int(num), int(den), staff)
            #measure.meters.append(meter)
            measure.add_element(meter)
            DATA[&#39;meter&#39;] = meter
        elif s.tag == &#39;key&#39;:
            fifths = s.findtext(&#39;fifths&#39;)
            text = s.findtext(&#39;mode&#39;, &#34;major&#34;)
            staff = int(s.get(&#39;number&#39;, &#34;0&#34;)) # 0=all staffs
            mode = {&#39;major&#39;: Mode.MAJOR, &#39;minor&#39;: Mode.MINOR, &#39;dorian&#39;: Mode.DORIAN, &#39;phrygian&#39;: Mode.PHRYGIAN, 
            &#39;lydian&#39;: Mode.LYDIAN, &#39;mixolydian&#39;: Mode.MIXOLYDIAN, &#39;aeolian&#39;: Mode.AEOLIAN, &#39;ionian&#39;: Mode.IONIAN, 
            &#39;locrian&#39;: Mode.LOCRIAN}[text]
            key = Key(int(fifths), mode, staff)
#            measure.keys.append(key)
            measure.add_element(key)
            DATA[&#39;key&#39;] = key


def _parse_note(elem, DATA):
    first = elem[0].tag
    # first can be &#39;grace&#39;, &#39;cue&#39;, &#39;chord&#39;, &#39;rest&#39;
    if first in [&#39;grace&#39;, &#39;cue&#39;]:
        return
    type = &#39;note&#39;
    duration = None
    pitch = None
    voice = 1    # ??? default?
    staff = None # ??? default?
    dots = 0
    note = None
    for e in elem.iter(): 
        if e.tag == &#39;pitch&#39;:
            step = e.findtext(&#39;step&#39;)
            alter = e.findtext(&#39;alter&#39;, &#34;&#34;)
            if alter:
                alter = {-2: &#39;bb&#39;, -1: &#39;b&#39;, 0: &#39;&#39;, 1: &#39;#&#39;, 2: &#39;##&#39;}.get(int(alter), &#39;&#39;)
            octave = e.findtext(&#39;octave&#39;)
            pitch = Pitch(step + alter + octave)
        elif e.tag == &#39;rest&#39;:
            type = e.tag
            pitch = Pitch()
        elif e.tag == &#39;chord&#39;:
            type = e.tag
        elif e.tag == &#39;duration&#39;:
            duration = int(e.text.strip())
        elif e.tag == &#39;dot&#39;:
            dots += 1
        elif e.tag == &#39;type&#39;:
            pass
        elif e.tag == &#39;stem&#39;:
            pass
        elif e.tag == &#39;voice&#39;:
            voice = int(e.text)
        elif e.tag == &#39;staff&#39;:
            pass
        elif e.tag == &#39;notations&#39;:
            pass
    # duration == dur/div * 1/4 == dur/(div*4)
    duration = Fraction(duration, DATA[&#39;divisions&#39;] * 4)
    if DATA[&#39;measure&#39;].partial:
        onset = DATA[&#39;meter&#39;].measure_dur() - duration
        #print(&#34;*****&#34;, &#34;measnum=&#34;, DATA[&#39;measure&#39;].id, &#34;measuredur=&#34;, DATA[&#39;meter&#39;].measure_dur(), &#34;duration=&#34;, duration)
    else:
        onset = DATA[&#39;onset&#39;]
    #print(&#34;part=&#34;, DATA[&#39;part&#39;].id, &#34;measure=&#34;, DATA[&#39;measure&#39;].id, &#34; onset=&#34;, onset, &#34; pitch=&#34;, pitch)
    note = Note(time=onset, duration=duration, pitch=pitch) #, instrument=voice
    note.set_mxml(&#39;voice&#39;, voice)
    if type == &#39;chord&#39;:
        # if chording add note as a child of the previous note
        DATA[&#39;note&#39;].add_child(note)
    else:
        # if note or rest add it to the current measure and update onset time.
        DATA[&#39;note&#39;] = note
        DATA[&#39;measure&#39;].add_element(note)
        DATA[&#39;onset&#39;] += duration
    #print(&#34;***&#34;, &#34;type:&#34;, type, &#34;onset:&#34;, onset, &#34;dur:&#34;, duration, &#34;dots:&#34;, dots, &#34;pitch:&#34;, pitch, &#34;voice:&#34;, voice)
    # score time: if this is a partial measure then the onset time of the note
    # is calcuated as measuredur - duration
    # create the note and fill its attributes. if it is a chord, then update the
    # measure to contain a Chord instead of a Note.


def _parse_backup(elem, DATA):
    duration = int(elem.findtext(&#39;duration&#39;))
    duration = Fraction(duration, DATA[&#39;divisions&#39;] * 4)
    DATA[&#39;onset&#39;] -= duration
    

def _parse_forward(elem, DATA):
    duration = int(elem.findtext(&#39;duration&#39;))
    duration = Fraction(duration, DATA[&#39;divisions&#39;] * 4)
    DATA[&#39;onset&#39;] += duration
    # FIXME: what to do with these?
    #elem.findtext(&#39;staff&#39;)
    #elem.findtext(&#39;voice&#39;)


def _parse_work_title(elem, DATA):
    DATA[&#39;score&#39;].metadata[&#39;title&#39;] = elem.text


def _parse_work_creator(elem, DATA):
    DATA[&#39;score&#39;].metadata[&#39;creator&#39;] = elem.text


def _parse_work_rights(elem, DATA):
    DATA[&#39;score&#39;].metadata[&#39;rights&#39;] = elem.text


# Dictionary of parsing functions accessed by the corresponding MusicXml tag
# name.  Tags that are not in this dictionary are either not parsed or parsed
# by a function that is in the dictionary.
_PARSERS = {
    &#39;part&#39;: _parse_part, 
    &#39;measure&#39;: _parse_measure, 
    &#39;attributes&#39;: _parse_attributes, 
    &#39;barline&#39;: _parse_barline,
    &#39;note&#39;: _parse_note,
    &#39;backup&#39;: _parse_backup,
    &#39;forward&#39;: _parse_forward,
    &#39;work-title&#39;: _parse_work_title,
    &#39;creator&#39;: _parse_work_creator,
    &#39;rights&#39;: _parse_work_rights
    }


def load(path, trace=False):
    &#34;&#34;&#34;
    Loads a MusicXml file into a Notation object.
    &#34;&#34;&#34;
    global _DATA
    document = musicxml.parse(path, silence=True) 
    assert isinstance(document, musicxml.score_partwise), f&#34;not a partwise musicxml file: &#39;{path}&#39;.&#34;
    root = getattr(document, &#39;gds_elementtree_node_&#39;) # root element of document
    assert isinstance(root, etree._Element) and root.tag == &#39;score-partwise&#39;, f&#34;not a score-partwise element: {root}.&#34;
    # a dictionary maintaining the running status of parsing.
    DATA = _DATA.copy()
    DATA[&#39;score&#39;] = Notation(metadata={&#39;file&#39;: os.path.abspath(path)})
    DATA[&#39;divisions&#39;] = 1 # default MusicXml divisions is 1 quarter note.
    # a depth-first traversal of all elements in the document.
    for x in root.iter():
        if trace:
            print(f&#34;tag={x.tag}, attrs={x.attrib}, text=&#39;{x.text.strip() if x.text else &#39;&#39;}&#39;, children={len(x)}&#34;)
        parser = _PARSERS.get(x.tag)
        if parser:
            parser(x, DATA)
    return DATA[&#39;score&#39;]


if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="musx.mxml.notation.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>path, trace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a MusicXml file into a Notation object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(path, trace=False):
    &#34;&#34;&#34;
    Loads a MusicXml file into a Notation object.
    &#34;&#34;&#34;
    global _DATA
    document = musicxml.parse(path, silence=True) 
    assert isinstance(document, musicxml.score_partwise), f&#34;not a partwise musicxml file: &#39;{path}&#39;.&#34;
    root = getattr(document, &#39;gds_elementtree_node_&#39;) # root element of document
    assert isinstance(root, etree._Element) and root.tag == &#39;score-partwise&#39;, f&#34;not a score-partwise element: {root}.&#34;
    # a dictionary maintaining the running status of parsing.
    DATA = _DATA.copy()
    DATA[&#39;score&#39;] = Notation(metadata={&#39;file&#39;: os.path.abspath(path)})
    DATA[&#39;divisions&#39;] = 1 # default MusicXml divisions is 1 quarter note.
    # a depth-first traversal of all elements in the document.
    for x in root.iter():
        if trace:
            print(f&#34;tag={x.tag}, attrs={x.attrib}, text=&#39;{x.text.strip() if x.text else &#39;&#39;}&#39;, children={len(x)}&#34;)
        parser = _PARSERS.get(x.tag)
        if parser:
            parser(x, DATA)
    return DATA[&#39;score&#39;]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="musx.mxml.notation.Notation"><code class="flex name class">
<span>class <span class="ident">Notation</span></span>
<span>(</span><span>metadata={}, parts=[])</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a MusicXml score. A Notation contains Part objects and
metadata. A Part contains Measure objects, and a Measure contains Note objects
as well as non-event notational objects such as Key, Clef, Meter, Barline.</p>
<p>Given a Notation you can iterate all its elements like this:</p>
<p>for part in notation:
for measure in part:
for element in measure:
print(element)</p>
<p>To access vertical note structures in the score's measures you can iterate the
score's timepoints like this:</p>
<p>for measure in notation.timepoints():
for timepoint in measure:
print(timepoint)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Notation():
    &#34;&#34;&#34;
    A class representing a MusicXml score. A Notation contains Part objects and
    metadata. A Part contains Measure objects, and a Measure contains Note objects
    as well as non-event notational objects such as Key, Clef, Meter, Barline.

    Given a Notation you can iterate all its elements like this:
    
    for part in notation:
        for measure in part:
            for element in measure:
                print(element)
    
    To access vertical note structures in the score&#39;s measures you can iterate the
    score&#39;s timepoints like this:

    for measure in notation.timepoints():
        for timepoint in measure:
            print(timepoint)
    &#34;&#34;&#34;
    def __init__(self, metadata={}, parts=[]):
        self.metadata = metadata
        &#34;&#34;&#34;A dictionary of MusicXml score metadata.&#34;&#34;&#34;
        self.parts = []
        &#34;&#34;&#34;The score&#39;s list of musical parts.&#34;&#34;&#34;
        for p in parts:
            self.add_part(p)

    def __iter__(self):
        &#34;&#34;&#34;
        Iterates the Part objects in the Notation.
        &#34;&#34;&#34;     
        return iter(self.parts)
    
    def __repr__(self):
        title = self.metadata.get(&#39;work-title&#39;, None)
        if title is None:
            title = self.metadata.get(&#39;movement-title&#39;, &#39;(untitled)&#39;)
        return f&#39;&lt;Notation: &#34;{title}&#34; {hex(id(self))}&gt;&#39;

    __str__ = __repr__

    def add_part(self, part):
        &#34;&#34;&#34;
        Appends a Part to the Notation&#39;s part list.
        &#34;&#34;&#34;
        part.score = self  # back link from part to its score
        self.parts.append(part)
    
    def print(self):
        &#34;&#34;&#34;
        Recursively prints the contents of the Notation.
        &#34;&#34;&#34;
        pad = &#34;  &#34;
        print(pad*0, self, sep=None)
        for p in self:
            print(pad*1, p, sep=None)
            for m in p:
                print(pad*2, m)
                for e in m:
                    print(pad*3, e)
    
    def timepoints(self, trace=False):
        &#34;&#34;&#34;
        Returns a list of Timepoint objects grouped in measures. See: Timepoint.
        &#34;&#34;&#34;
        # Flop the part measures so all measures with the same id are grouped
        # together, e.g.: [[1,2,3],[1,2,3]] =&gt; [[1,1],[2,2],[3,3]]
        groups = [measures for measures in zip(*[part.measures for part in self])]
        # iterate each group of measures
        timepoints = []
        for group in groups:
            # iterate each measure in the group combining their timepoints
            measurepoints = []
            for measure in group:
                for element in measure:
                    if isinstance(element, Note):
                        ident = f&#34;{measure.part.id}.{measure.id}.{element.get_mxml(&#39;voice&#39;)}&#34;
                        onset = element.time
                        try: 
                            have = next((x for x in measurepoints if x.onset == onset))
                            have.notemap[ident] = element
                        except StopIteration:
                            tp = Timepoint(onset)
                            tp.notemap[ident] = element
                            measurepoints.append(tp)
                
            # sort the measure timepoints by their onsets
            measurepoints.sort()
            if trace:
                for tp in measurepoints:
                    print(str(tp))
                    print(&#39;----------------------------------------------------------------&#39;)
            timepoints.append(measurepoints)
        return timepoints</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="musx.mxml.notation.Notation.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>A dictionary of MusicXml score metadata.</p></div>
</dd>
<dt id="musx.mxml.notation.Notation.parts"><code class="name">var <span class="ident">parts</span></code></dt>
<dd>
<div class="desc"><p>The score's list of musical parts.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="musx.mxml.notation.Notation.add_part"><code class="name flex">
<span>def <span class="ident">add_part</span></span>(<span>self, part)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends a Part to the Notation's part list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_part(self, part):
    &#34;&#34;&#34;
    Appends a Part to the Notation&#39;s part list.
    &#34;&#34;&#34;
    part.score = self  # back link from part to its score
    self.parts.append(part)</code></pre>
</details>
</dd>
<dt id="musx.mxml.notation.Notation.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively prints the contents of the Notation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self):
    &#34;&#34;&#34;
    Recursively prints the contents of the Notation.
    &#34;&#34;&#34;
    pad = &#34;  &#34;
    print(pad*0, self, sep=None)
    for p in self:
        print(pad*1, p, sep=None)
        for m in p:
            print(pad*2, m)
            for e in m:
                print(pad*3, e)</code></pre>
</details>
</dd>
<dt id="musx.mxml.notation.Notation.timepoints"><code class="name flex">
<span>def <span class="ident">timepoints</span></span>(<span>self, trace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of Timepoint objects grouped in measures. See: Timepoint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timepoints(self, trace=False):
    &#34;&#34;&#34;
    Returns a list of Timepoint objects grouped in measures. See: Timepoint.
    &#34;&#34;&#34;
    # Flop the part measures so all measures with the same id are grouped
    # together, e.g.: [[1,2,3],[1,2,3]] =&gt; [[1,1],[2,2],[3,3]]
    groups = [measures for measures in zip(*[part.measures for part in self])]
    # iterate each group of measures
    timepoints = []
    for group in groups:
        # iterate each measure in the group combining their timepoints
        measurepoints = []
        for measure in group:
            for element in measure:
                if isinstance(element, Note):
                    ident = f&#34;{measure.part.id}.{measure.id}.{element.get_mxml(&#39;voice&#39;)}&#34;
                    onset = element.time
                    try: 
                        have = next((x for x in measurepoints if x.onset == onset))
                        have.notemap[ident] = element
                    except StopIteration:
                        tp = Timepoint(onset)
                        tp.notemap[ident] = element
                        measurepoints.append(tp)
            
        # sort the measure timepoints by their onsets
        measurepoints.sort()
        if trace:
            for tp in measurepoints:
                print(str(tp))
                print(&#39;----------------------------------------------------------------&#39;)
        timepoints.append(measurepoints)
    return timepoints</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="musx.mxml.notation.Timepoint"><code class="flex name class">
<span>class <span class="ident">Timepoint</span></span>
<span>(</span><span>onset)</span>
</code></dt>
<dd>
<div class="desc"><p>A Timepoint is an analytical structure that contains an onset time in a
measure and the vertical 'slice' of all the notes that begin at that beat
irrespective of which part, staff or voice they belong to. The note
entries within each Timepoint are maintained in a dictionary whose keys
are part.measure.voice identifiers and whose values are the notes that
begin at the Timepoint's beat.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>beat</code></strong> :&ensp;<code>Fraction</code></dt>
<dd>The metric onset of the timepoint in the measure.</dd>
<dt><strong><code>nmap</code></strong> :&ensp;<code>dict</code></dt>
<dd>The note map of the timepoint is a dictionary of notes whose
keys are the part/voice identifiers active in the measure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timepoint():
    &#34;&#34;&#34;
    A Timepoint is an analytical structure that contains an onset time in a
    measure and the vertical &#39;slice&#39; of all the notes that begin at that beat
    irrespective of which part, staff or voice they belong to. The note 
    entries within each Timepoint are maintained in a dictionary whose keys
    are part.measure.voice identifiers and whose values are the notes that
    begin at the Timepoint&#39;s beat.
    
    Parameters
    ----------
    beat : Fraction
        The metric onset of the timepoint in the measure.
    nmap : dict
        The note map of the timepoint is a dictionary of notes whose
        keys are the part/voice identifiers active in the measure.
    &#34;&#34;&#34;
    def __init__(self, onset):
        ## The ratio start time in the measure.
        self.onset = onset
        ## The note map dictionary, keys are pvids (part/voice identifiers)
        # from the score and values are either Notes, Chords or Rests.
        self.notemap = {}

    def __lt__(self, other):
        &#34;&#34;&#34;
        Returns true if self.beat is less than other, otherwise returns false.
        &#34;&#34;&#34;
        return self.onset &lt; other.onset

    def __str__(self):
        &#34;&#34;&#34;
        Returns a string contains the class name, the self.index attribute,
        and a hexidecimal id.
        &#34;&#34;&#34;
        #return f&#34;&lt;Timepoint {str(self.onset)} {len(self.notemap)}&gt;&#34;
        pstr = &#34;, &#34;.join([n._tagged_pitch_str() for n in self.notemap.values()])
        return f&#34;&lt;Timepoint: {str(self.onset)} ({pstr})&gt;&#34;

    __repr__ = __str__</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="musx.mxml" href="index.html">musx.mxml</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="musx.mxml.notation.load" href="#musx.mxml.notation.load">load</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="musx.mxml.notation.Notation" href="#musx.mxml.notation.Notation">Notation</a></code></h4>
<ul class="">
<li><code><a title="musx.mxml.notation.Notation.add_part" href="#musx.mxml.notation.Notation.add_part">add_part</a></code></li>
<li><code><a title="musx.mxml.notation.Notation.metadata" href="#musx.mxml.notation.Notation.metadata">metadata</a></code></li>
<li><code><a title="musx.mxml.notation.Notation.parts" href="#musx.mxml.notation.Notation.parts">parts</a></code></li>
<li><code><a title="musx.mxml.notation.Notation.print" href="#musx.mxml.notation.Notation.print">print</a></code></li>
<li><code><a title="musx.mxml.notation.Notation.timepoints" href="#musx.mxml.notation.Notation.timepoints">timepoints</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="musx.mxml.notation.Timepoint" href="#musx.mxml.notation.Timepoint">Timepoint</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>