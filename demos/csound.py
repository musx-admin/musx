'''
Author: Michael Gogins

This module translates MIDI files generated by musx to standard Csound scores
where each note is an "i" statement in the format:
```
i instrument_number time_seconds duration_seconds midi_key midi_velocity
```
Assigns a duration to the event at the given index in the given MIDI sequence.
If the event is a note on event, the duration is the difference between the 
time of the first matching note off message and the time of the note on event.

For unisons, the first note on is also the first note turned off.
'''
from musx.midi import MidiNote, MidiSeq, MidiFile

'''
Assuming the event at the index is a note on event, searches forwards in time 
in the sequence until the first note off event whose MIDI channel and MIDI key 
number match the note on event, and which has not already been used as a note 
off event, e.g. in a unison. When a match is found, the duration is obtained 
and assigned to the note on event, and the note off is saved in a set that 
identified it as having already been used. Thus, in unisons, the first note on 
events are also the first notes turned off.
'''
def assign_duration(index, midiseq, turnoffs):
    event = midiseq[index]
    event.duration = 0
    if event.is_note_on() == True:
        for off_index in range(index, len(midiseq)):
            note_off = midiseq[off_index]
            # Value semantics are required here.
            note_off_key = (note_off.channel, note_off.keynum)
            if note_off_key not in turnoffs:
                if note_off.is_note_off():
                    if note_off.keynum() == event.keynum() and note_off.channel() == event.channel():
                        event.duration = note_off.time - event.time
                        turnoffs.add(note_off_key)
                        break
    return event
    
'''
Assigns a duration to each MIDI event in each MIDI sequence in the MIDI file.
'''
def assign_durations(midifile):
    for track in midifile:
        turnoffs = set()
        for index in range(len(track)):
            event = assign_duration(index, track, turnoffs)
            if event.is_note_on() == True:
                i_statement = to_i_statement(event)
'''
Translates the MIDI event into a Csound "i" statement.
'''
def to_i_statement(midi_event):
    i_statement = "i {} {} {} {} {}".format(1 + midi_event.channel(), midi_event.time, midi_event.duration, midi_event.keynum(), midi_event.velocity())
    return i_statement
    
'''
Returns a Csound score file as a single string, translated from the MIDI file.
It is assumed that times are in seconds.
'''
def to_csound_score(midifile):
    assign_durations(midifile)
    csound_score = []
    for track in midifile:
        for event in track:
            if event.is_note_on():
                if event.duration > 0:
                    i_statement = to_i_statement(event)
                    csound_score.append(i_statement + "\n")
    return ''.join(csound_score)
    
                    
